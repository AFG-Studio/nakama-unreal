// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

#ifndef PROTOBUF_api_2eproto__INCLUDED
#define PROTOBUF_api_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace server {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_api_2eproto();
void protobuf_InitDefaults_api_2eproto();
void protobuf_AssignDesc_api_2eproto();
void protobuf_ShutdownFile_api_2eproto();

class AuthenticateRequest;
class AuthenticateRequest_Email;
class AuthenticateRequest_GameCenter;
class AuthenticateResponse;
class AuthenticateResponse_Error;
class AuthenticateResponse_Session;
class Envelope;
class Error;
class Friend;
class Group;
class GroupUser;
class Heartbeat;
class Leaderboard;
class LeaderboardRecord;
class Logout;
class MatchData;
class MatchDataSend;
class MatchPresence;
class MatchmakeMatched;
class Self;
class TFriendAdd;
class TFriendBlock;
class TFriendRemove;
class TFriends;
class TFriendsList;
class TGroup;
class TGroupCreate;
class TGroupJoin;
class TGroupLeave;
class TGroupRemove;
class TGroupUpdate;
class TGroupUserAdd;
class TGroupUserKick;
class TGroupUserPromote;
class TGroupUsers;
class TGroupUsersList;
class TGroups;
class TGroupsFetch;
class TGroupsFetch_GroupIds;
class TGroupsFetch_Names;
class TGroupsList;
class TGroupsSelfList;
class TLeaderboardRecord;
class TLeaderboardRecordWrite;
class TLeaderboardRecords;
class TLeaderboardRecordsFetch;
class TLeaderboardRecordsList;
class TLeaderboardRecordsList_Owners;
class TLeaderboards;
class TLeaderboardsList;
class TLink;
class TMatch;
class TMatchCreate;
class TMatchJoin;
class TMatchLeave;
class TMatchmakeAdd;
class TMatchmakeRemove;
class TMatchmakeTicket;
class TRpc;
class TSelf;
class TSelfFetch;
class TSelfUpdate;
class TStorageData;
class TStorageData_StorageData;
class TStorageFetch;
class TStorageFetch_StorageKey;
class TStorageKey;
class TStorageKey_StorageKey;
class TStorageRemove;
class TStorageRemove_StorageKey;
class TStorageWrite;
class TStorageWrite_StorageData;
class TTopic;
class TTopicJoin;
class TTopicLeave;
class TTopicMessageAck;
class TTopicMessageSend;
class TTopicMessages;
class TTopicMessagesList;
class TUnlink;
class TUsers;
class TUsersFetch;
class TUsersFetch_Handles;
class TUsersFetch_UserIds;
class TopicId;
class TopicMessage;
class TopicPresence;
class User;
class UserPresence;

enum Error_Code {
  Error_Code_RUNTIME_EXCEPTION = 0,
  Error_Code_UNRECOGNIZED_PAYLOAD = 1,
  Error_Code_MISSING_PAYLOAD = 2,
  Error_Code_BAD_INPUT = 3,
  Error_Code_AUTH_ERROR = 4,
  Error_Code_USER_LINK_INUSE = 5,
  Error_Code_USER_LINK_PROVIDER_UNAVAILABLE = 6,
  Error_Code_USER_UNLINK_DISALLOWED = 7,
  Error_Code_USER_HANDLE_INUSE = 8,
  Error_Code_GROUP_NAME_INUSE = 9,
  Error_Code_STORAGE_REJECTED = 10,
  Error_Code_MATCH_NOT_FOUND = 11,
  Error_Code_RUNTIME_FUNCTION_NOT_FOUND = 12,
  Error_Code_RUNTIME_FUNCTION_EXCEPTION = 13,
  Error_Code_Error_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Error_Code_Error_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Error_Code_IsValid(int value);
const Error_Code Error_Code_Code_MIN = Error_Code_RUNTIME_EXCEPTION;
const Error_Code Error_Code_Code_MAX = Error_Code_RUNTIME_FUNCTION_EXCEPTION;
const int Error_Code_Code_ARRAYSIZE = Error_Code_Code_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_Code_descriptor();
inline const ::std::string& Error_Code_Name(Error_Code value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_Code_descriptor(), value);
}
inline bool Error_Code_Parse(
    const ::std::string& name, Error_Code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_Code>(
    Error_Code_descriptor(), name, value);
}
enum StoragePermissionRead {
  NO_READ = 0,
  OWNER_READ = 1,
  PUBLIC_READ = 2,
  StoragePermissionRead_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StoragePermissionRead_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StoragePermissionRead_IsValid(int value);
const StoragePermissionRead StoragePermissionRead_MIN = NO_READ;
const StoragePermissionRead StoragePermissionRead_MAX = PUBLIC_READ;
const int StoragePermissionRead_ARRAYSIZE = StoragePermissionRead_MAX + 1;

const ::google::protobuf::EnumDescriptor* StoragePermissionRead_descriptor();
inline const ::std::string& StoragePermissionRead_Name(StoragePermissionRead value) {
  return ::google::protobuf::internal::NameOfEnum(
    StoragePermissionRead_descriptor(), value);
}
inline bool StoragePermissionRead_Parse(
    const ::std::string& name, StoragePermissionRead* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StoragePermissionRead>(
    StoragePermissionRead_descriptor(), name, value);
}
enum StoragePermissionWrite {
  NO_WRITE = 0,
  OWNER_WRITE = 1,
  StoragePermissionWrite_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StoragePermissionWrite_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StoragePermissionWrite_IsValid(int value);
const StoragePermissionWrite StoragePermissionWrite_MIN = NO_WRITE;
const StoragePermissionWrite StoragePermissionWrite_MAX = OWNER_WRITE;
const int StoragePermissionWrite_ARRAYSIZE = StoragePermissionWrite_MAX + 1;

const ::google::protobuf::EnumDescriptor* StoragePermissionWrite_descriptor();
inline const ::std::string& StoragePermissionWrite_Name(StoragePermissionWrite value) {
  return ::google::protobuf::internal::NameOfEnum(
    StoragePermissionWrite_descriptor(), value);
}
inline bool StoragePermissionWrite_Parse(
    const ::std::string& name, StoragePermissionWrite* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StoragePermissionWrite>(
    StoragePermissionWrite_descriptor(), name, value);
}
// ===================================================================

class Heartbeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.Heartbeat) */ {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Heartbeat& default_instance();

  static const Heartbeat* internal_default_instance();

  void Swap(Heartbeat* other);

  // implements Message ----------------------------------------------

  inline Heartbeat* New() const { return New(NULL); }

  Heartbeat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Heartbeat* other);
  void UnsafeMergeFrom(const Heartbeat& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:server.Heartbeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Heartbeat> Heartbeat_default_instance_;

// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static const Error* internal_default_instance();

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  inline Error* New() const { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Error* other);
  void UnsafeMergeFrom(const Error& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Error_Code Code;
  static const Code RUNTIME_EXCEPTION =
    Error_Code_RUNTIME_EXCEPTION;
  static const Code UNRECOGNIZED_PAYLOAD =
    Error_Code_UNRECOGNIZED_PAYLOAD;
  static const Code MISSING_PAYLOAD =
    Error_Code_MISSING_PAYLOAD;
  static const Code BAD_INPUT =
    Error_Code_BAD_INPUT;
  static const Code AUTH_ERROR =
    Error_Code_AUTH_ERROR;
  static const Code USER_LINK_INUSE =
    Error_Code_USER_LINK_INUSE;
  static const Code USER_LINK_PROVIDER_UNAVAILABLE =
    Error_Code_USER_LINK_PROVIDER_UNAVAILABLE;
  static const Code USER_UNLINK_DISALLOWED =
    Error_Code_USER_UNLINK_DISALLOWED;
  static const Code USER_HANDLE_INUSE =
    Error_Code_USER_HANDLE_INUSE;
  static const Code GROUP_NAME_INUSE =
    Error_Code_GROUP_NAME_INUSE;
  static const Code STORAGE_REJECTED =
    Error_Code_STORAGE_REJECTED;
  static const Code MATCH_NOT_FOUND =
    Error_Code_MATCH_NOT_FOUND;
  static const Code RUNTIME_FUNCTION_NOT_FOUND =
    Error_Code_RUNTIME_FUNCTION_NOT_FOUND;
  static const Code RUNTIME_FUNCTION_EXCEPTION =
    Error_Code_RUNTIME_FUNCTION_EXCEPTION;
  static inline bool Code_IsValid(int value) {
    return Error_Code_IsValid(value);
  }
  static const Code Code_MIN =
    Error_Code_Code_MIN;
  static const Code Code_MAX =
    Error_Code_Code_MAX;
  static const int Code_ARRAYSIZE =
    Error_Code_Code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Code_descriptor() {
    return Error_Code_descriptor();
  }
  static inline const ::std::string& Code_Name(Code value) {
    return Error_Code_Name(value);
  }
  static inline bool Code_Parse(const ::std::string& name,
      Code* value) {
    return Error_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // optional string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:server.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Error> Error_default_instance_;

// -------------------------------------------------------------------

class AuthenticateRequest_Email : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.AuthenticateRequest.Email) */ {
 public:
  AuthenticateRequest_Email();
  virtual ~AuthenticateRequest_Email();

  AuthenticateRequest_Email(const AuthenticateRequest_Email& from);

  inline AuthenticateRequest_Email& operator=(const AuthenticateRequest_Email& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateRequest_Email& default_instance();

  static const AuthenticateRequest_Email* internal_default_instance();

  void Swap(AuthenticateRequest_Email* other);

  // implements Message ----------------------------------------------

  inline AuthenticateRequest_Email* New() const { return New(NULL); }

  AuthenticateRequest_Email* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateRequest_Email& from);
  void MergeFrom(const AuthenticateRequest_Email& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateRequest_Email* other);
  void UnsafeMergeFrom(const AuthenticateRequest_Email& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string email = 1;
  void clear_email();
  static const int kEmailFieldNumber = 1;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // optional string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:server.AuthenticateRequest.Email)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AuthenticateRequest_Email> AuthenticateRequest_Email_default_instance_;

// -------------------------------------------------------------------

class AuthenticateRequest_GameCenter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.AuthenticateRequest.GameCenter) */ {
 public:
  AuthenticateRequest_GameCenter();
  virtual ~AuthenticateRequest_GameCenter();

  AuthenticateRequest_GameCenter(const AuthenticateRequest_GameCenter& from);

  inline AuthenticateRequest_GameCenter& operator=(const AuthenticateRequest_GameCenter& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateRequest_GameCenter& default_instance();

  static const AuthenticateRequest_GameCenter* internal_default_instance();

  void Swap(AuthenticateRequest_GameCenter* other);

  // implements Message ----------------------------------------------

  inline AuthenticateRequest_GameCenter* New() const { return New(NULL); }

  AuthenticateRequest_GameCenter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateRequest_GameCenter& from);
  void MergeFrom(const AuthenticateRequest_GameCenter& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateRequest_GameCenter* other);
  void UnsafeMergeFrom(const AuthenticateRequest_GameCenter& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string player_id = 1;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  const ::std::string& player_id() const;
  void set_player_id(const ::std::string& value);
  void set_player_id(const char* value);
  void set_player_id(const char* value, size_t size);
  ::std::string* mutable_player_id();
  ::std::string* release_player_id();
  void set_allocated_player_id(::std::string* player_id);

  // optional string bundle_id = 2;
  void clear_bundle_id();
  static const int kBundleIdFieldNumber = 2;
  const ::std::string& bundle_id() const;
  void set_bundle_id(const ::std::string& value);
  void set_bundle_id(const char* value);
  void set_bundle_id(const char* value, size_t size);
  ::std::string* mutable_bundle_id();
  ::std::string* release_bundle_id();
  void set_allocated_bundle_id(::std::string* bundle_id);

  // optional int64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional string salt = 4;
  void clear_salt();
  static const int kSaltFieldNumber = 4;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  void set_salt(const char* value);
  void set_salt(const char* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // optional string signature = 5;
  void clear_signature();
  static const int kSignatureFieldNumber = 5;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional string public_key_url = 6;
  void clear_public_key_url();
  static const int kPublicKeyUrlFieldNumber = 6;
  const ::std::string& public_key_url() const;
  void set_public_key_url(const ::std::string& value);
  void set_public_key_url(const char* value);
  void set_public_key_url(const char* value, size_t size);
  ::std::string* mutable_public_key_url();
  ::std::string* release_public_key_url();
  void set_allocated_public_key_url(::std::string* public_key_url);

  // @@protoc_insertion_point(class_scope:server.AuthenticateRequest.GameCenter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr player_id_;
  ::google::protobuf::internal::ArenaStringPtr bundle_id_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr public_key_url_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AuthenticateRequest_GameCenter> AuthenticateRequest_GameCenter_default_instance_;

// -------------------------------------------------------------------

class AuthenticateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.AuthenticateRequest) */ {
 public:
  AuthenticateRequest();
  virtual ~AuthenticateRequest();

  AuthenticateRequest(const AuthenticateRequest& from);

  inline AuthenticateRequest& operator=(const AuthenticateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateRequest& default_instance();

  enum PayloadCase {
    kEmail = 2,
    kFacebook = 3,
    kGoogle = 4,
    kGameCenter = 5,
    kSteam = 6,
    kDevice = 7,
    kCustom = 8,
    PAYLOAD_NOT_SET = 0,
  };

  static const AuthenticateRequest* internal_default_instance();

  void Swap(AuthenticateRequest* other);

  // implements Message ----------------------------------------------

  inline AuthenticateRequest* New() const { return New(NULL); }

  AuthenticateRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateRequest& from);
  void MergeFrom(const AuthenticateRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateRequest* other);
  void UnsafeMergeFrom(const AuthenticateRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AuthenticateRequest_Email Email;
  typedef AuthenticateRequest_GameCenter GameCenter;

  // accessors -------------------------------------------------------

  // optional string collationId = 1;
  void clear_collationid();
  static const int kCollationIdFieldNumber = 1;
  const ::std::string& collationid() const;
  void set_collationid(const ::std::string& value);
  void set_collationid(const char* value);
  void set_collationid(const char* value, size_t size);
  ::std::string* mutable_collationid();
  ::std::string* release_collationid();
  void set_allocated_collationid(::std::string* collationid);

  // optional .server.AuthenticateRequest.Email email = 2;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 2;
  const ::server::AuthenticateRequest_Email& email() const;
  ::server::AuthenticateRequest_Email* mutable_email();
  ::server::AuthenticateRequest_Email* release_email();
  void set_allocated_email(::server::AuthenticateRequest_Email* email);

  // optional string facebook = 3;
  private:
  bool has_facebook() const;
  public:
  void clear_facebook();
  static const int kFacebookFieldNumber = 3;
  const ::std::string& facebook() const;
  void set_facebook(const ::std::string& value);
  void set_facebook(const char* value);
  void set_facebook(const char* value, size_t size);
  ::std::string* mutable_facebook();
  ::std::string* release_facebook();
  void set_allocated_facebook(::std::string* facebook);

  // optional string google = 4;
  private:
  bool has_google() const;
  public:
  void clear_google();
  static const int kGoogleFieldNumber = 4;
  const ::std::string& google() const;
  void set_google(const ::std::string& value);
  void set_google(const char* value);
  void set_google(const char* value, size_t size);
  ::std::string* mutable_google();
  ::std::string* release_google();
  void set_allocated_google(::std::string* google);

  // optional .server.AuthenticateRequest.GameCenter game_center = 5;
  bool has_game_center() const;
  void clear_game_center();
  static const int kGameCenterFieldNumber = 5;
  const ::server::AuthenticateRequest_GameCenter& game_center() const;
  ::server::AuthenticateRequest_GameCenter* mutable_game_center();
  ::server::AuthenticateRequest_GameCenter* release_game_center();
  void set_allocated_game_center(::server::AuthenticateRequest_GameCenter* game_center);

  // optional string steam = 6;
  private:
  bool has_steam() const;
  public:
  void clear_steam();
  static const int kSteamFieldNumber = 6;
  const ::std::string& steam() const;
  void set_steam(const ::std::string& value);
  void set_steam(const char* value);
  void set_steam(const char* value, size_t size);
  ::std::string* mutable_steam();
  ::std::string* release_steam();
  void set_allocated_steam(::std::string* steam);

  // optional string device = 7;
  private:
  bool has_device() const;
  public:
  void clear_device();
  static const int kDeviceFieldNumber = 7;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // optional string custom = 8;
  private:
  bool has_custom() const;
  public:
  void clear_custom();
  static const int kCustomFieldNumber = 8;
  const ::std::string& custom() const;
  void set_custom(const ::std::string& value);
  void set_custom(const char* value);
  void set_custom(const char* value, size_t size);
  ::std::string* mutable_custom();
  ::std::string* release_custom();
  void set_allocated_custom(::std::string* custom);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:server.AuthenticateRequest)
 private:
  inline void set_has_email();
  inline void set_has_facebook();
  inline void set_has_google();
  inline void set_has_game_center();
  inline void set_has_steam();
  inline void set_has_device();
  inline void set_has_custom();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collationid_;
  union PayloadUnion {
    PayloadUnion() {}
    ::server::AuthenticateRequest_Email* email_;
    ::google::protobuf::internal::ArenaStringPtr facebook_;
    ::google::protobuf::internal::ArenaStringPtr google_;
    ::server::AuthenticateRequest_GameCenter* game_center_;
    ::google::protobuf::internal::ArenaStringPtr steam_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr custom_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AuthenticateRequest> AuthenticateRequest_default_instance_;

// -------------------------------------------------------------------

class AuthenticateResponse_Session : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.AuthenticateResponse.Session) */ {
 public:
  AuthenticateResponse_Session();
  virtual ~AuthenticateResponse_Session();

  AuthenticateResponse_Session(const AuthenticateResponse_Session& from);

  inline AuthenticateResponse_Session& operator=(const AuthenticateResponse_Session& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateResponse_Session& default_instance();

  static const AuthenticateResponse_Session* internal_default_instance();

  void Swap(AuthenticateResponse_Session* other);

  // implements Message ----------------------------------------------

  inline AuthenticateResponse_Session* New() const { return New(NULL); }

  AuthenticateResponse_Session* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateResponse_Session& from);
  void MergeFrom(const AuthenticateResponse_Session& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateResponse_Session* other);
  void UnsafeMergeFrom(const AuthenticateResponse_Session& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:server.AuthenticateResponse.Session)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AuthenticateResponse_Session> AuthenticateResponse_Session_default_instance_;

// -------------------------------------------------------------------

class AuthenticateResponse_Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.AuthenticateResponse.Error) */ {
 public:
  AuthenticateResponse_Error();
  virtual ~AuthenticateResponse_Error();

  AuthenticateResponse_Error(const AuthenticateResponse_Error& from);

  inline AuthenticateResponse_Error& operator=(const AuthenticateResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateResponse_Error& default_instance();

  static const AuthenticateResponse_Error* internal_default_instance();

  void Swap(AuthenticateResponse_Error* other);

  // implements Message ----------------------------------------------

  inline AuthenticateResponse_Error* New() const { return New(NULL); }

  AuthenticateResponse_Error* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateResponse_Error& from);
  void MergeFrom(const AuthenticateResponse_Error& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateResponse_Error* other);
  void UnsafeMergeFrom(const AuthenticateResponse_Error& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // optional string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .server.AuthenticateRequest request = 3;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 3;
  const ::server::AuthenticateRequest& request() const;
  ::server::AuthenticateRequest* mutable_request();
  ::server::AuthenticateRequest* release_request();
  void set_allocated_request(::server::AuthenticateRequest* request);

  // @@protoc_insertion_point(class_scope:server.AuthenticateResponse.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::server::AuthenticateRequest* request_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AuthenticateResponse_Error> AuthenticateResponse_Error_default_instance_;

// -------------------------------------------------------------------

class AuthenticateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.AuthenticateResponse) */ {
 public:
  AuthenticateResponse();
  virtual ~AuthenticateResponse();

  AuthenticateResponse(const AuthenticateResponse& from);

  inline AuthenticateResponse& operator=(const AuthenticateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateResponse& default_instance();

  enum PayloadCase {
    kSession = 2,
    kError = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static const AuthenticateResponse* internal_default_instance();

  void Swap(AuthenticateResponse* other);

  // implements Message ----------------------------------------------

  inline AuthenticateResponse* New() const { return New(NULL); }

  AuthenticateResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateResponse& from);
  void MergeFrom(const AuthenticateResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateResponse* other);
  void UnsafeMergeFrom(const AuthenticateResponse& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AuthenticateResponse_Session Session;
  typedef AuthenticateResponse_Error Error;

  // accessors -------------------------------------------------------

  // optional string collation_id = 1;
  void clear_collation_id();
  static const int kCollationIdFieldNumber = 1;
  const ::std::string& collation_id() const;
  void set_collation_id(const ::std::string& value);
  void set_collation_id(const char* value);
  void set_collation_id(const char* value, size_t size);
  ::std::string* mutable_collation_id();
  ::std::string* release_collation_id();
  void set_allocated_collation_id(::std::string* collation_id);

  // optional .server.AuthenticateResponse.Session session = 2;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 2;
  const ::server::AuthenticateResponse_Session& session() const;
  ::server::AuthenticateResponse_Session* mutable_session();
  ::server::AuthenticateResponse_Session* release_session();
  void set_allocated_session(::server::AuthenticateResponse_Session* session);

  // optional .server.AuthenticateResponse.Error error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::server::AuthenticateResponse_Error& error() const;
  ::server::AuthenticateResponse_Error* mutable_error();
  ::server::AuthenticateResponse_Error* release_error();
  void set_allocated_error(::server::AuthenticateResponse_Error* error);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:server.AuthenticateResponse)
 private:
  inline void set_has_session();
  inline void set_has_error();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collation_id_;
  union PayloadUnion {
    PayloadUnion() {}
    ::server::AuthenticateResponse_Session* session_;
    ::server::AuthenticateResponse_Error* error_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AuthenticateResponse> AuthenticateResponse_default_instance_;

// -------------------------------------------------------------------

class Envelope : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.Envelope) */ {
 public:
  Envelope();
  virtual ~Envelope();

  Envelope(const Envelope& from);

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();

  enum PayloadCase {
    kError = 2,
    kHeartbeat = 3,
    kLogout = 4,
    kLink = 5,
    kUnlink = 6,
    kSelfFetch = 7,
    kSelfUpdate = 8,
    kUsersFetch = 9,
    kSelf = 10,
    kUsers = 11,
    kFriendAdd = 12,
    kFriendRemove = 13,
    kFriendBlock = 14,
    kFriendsList = 15,
    kFriends = 16,
    kGroupCreate = 17,
    kGroupUpdate = 18,
    kGroupRemove = 19,
    kGroupsFetch = 20,
    kGroupsList = 21,
    kGroupsSelfList = 22,
    kGroupUsersList = 23,
    kGroupJoin = 24,
    kGroupLeave = 25,
    kGroupUserAdd = 26,
    kGroupUserKick = 27,
    kGroupUserPromote = 28,
    kGroup = 29,
    kGroups = 30,
    kGroupUsers = 31,
    kTopicJoin = 32,
    kTopicLeave = 33,
    kTopicMessageSend = 34,
    kTopicMessagesList = 35,
    kTopic = 36,
    kTopicMessageAck = 37,
    kTopicMessage = 38,
    kTopicMessages = 39,
    kTopicPresence = 40,
    kMatchCreate = 41,
    kMatchJoin = 42,
    kMatchLeave = 43,
    kMatchDataSend = 44,
    kMatch = 45,
    kMatchData = 46,
    kMatchPresence = 47,
    kStorageFetch = 48,
    kStorageWrite = 49,
    kStorageRemove = 50,
    kStorageData = 51,
    kStorageKey = 52,
    kLeaderboardsList = 53,
    kLeaderboardRecordWrite = 54,
    kLeaderboardRecordsFetch = 55,
    kLeaderboardRecordsList = 56,
    kLeaderboards = 57,
    kLeaderboardRecord = 58,
    kLeaderboardRecords = 59,
    kMatchmakeAdd = 60,
    kMatchmakeRemove = 61,
    kMatchmakeTicket = 62,
    kMatchmakeMatched = 63,
    kRpc = 64,
    PAYLOAD_NOT_SET = 0,
  };

  static const Envelope* internal_default_instance();

  void Swap(Envelope* other);

  // implements Message ----------------------------------------------

  inline Envelope* New() const { return New(NULL); }

  Envelope* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Envelope* other);
  void UnsafeMergeFrom(const Envelope& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string collation_id = 1;
  void clear_collation_id();
  static const int kCollationIdFieldNumber = 1;
  const ::std::string& collation_id() const;
  void set_collation_id(const ::std::string& value);
  void set_collation_id(const char* value);
  void set_collation_id(const char* value, size_t size);
  ::std::string* mutable_collation_id();
  ::std::string* release_collation_id();
  void set_allocated_collation_id(::std::string* collation_id);

  // optional .server.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::server::Error& error() const;
  ::server::Error* mutable_error();
  ::server::Error* release_error();
  void set_allocated_error(::server::Error* error);

  // optional .server.Heartbeat heartbeat = 3;
  bool has_heartbeat() const;
  void clear_heartbeat();
  static const int kHeartbeatFieldNumber = 3;
  const ::server::Heartbeat& heartbeat() const;
  ::server::Heartbeat* mutable_heartbeat();
  ::server::Heartbeat* release_heartbeat();
  void set_allocated_heartbeat(::server::Heartbeat* heartbeat);

  // optional .server.Logout logout = 4;
  bool has_logout() const;
  void clear_logout();
  static const int kLogoutFieldNumber = 4;
  const ::server::Logout& logout() const;
  ::server::Logout* mutable_logout();
  ::server::Logout* release_logout();
  void set_allocated_logout(::server::Logout* logout);

  // optional .server.TLink link = 5;
  bool has_link() const;
  void clear_link();
  static const int kLinkFieldNumber = 5;
  const ::server::TLink& link() const;
  ::server::TLink* mutable_link();
  ::server::TLink* release_link();
  void set_allocated_link(::server::TLink* link);

  // optional .server.TUnlink unlink = 6;
  bool has_unlink() const;
  void clear_unlink();
  static const int kUnlinkFieldNumber = 6;
  const ::server::TUnlink& unlink() const;
  ::server::TUnlink* mutable_unlink();
  ::server::TUnlink* release_unlink();
  void set_allocated_unlink(::server::TUnlink* unlink);

  // optional .server.TSelfFetch self_fetch = 7;
  bool has_self_fetch() const;
  void clear_self_fetch();
  static const int kSelfFetchFieldNumber = 7;
  const ::server::TSelfFetch& self_fetch() const;
  ::server::TSelfFetch* mutable_self_fetch();
  ::server::TSelfFetch* release_self_fetch();
  void set_allocated_self_fetch(::server::TSelfFetch* self_fetch);

  // optional .server.TSelfUpdate self_update = 8;
  bool has_self_update() const;
  void clear_self_update();
  static const int kSelfUpdateFieldNumber = 8;
  const ::server::TSelfUpdate& self_update() const;
  ::server::TSelfUpdate* mutable_self_update();
  ::server::TSelfUpdate* release_self_update();
  void set_allocated_self_update(::server::TSelfUpdate* self_update);

  // optional .server.TUsersFetch users_fetch = 9;
  bool has_users_fetch() const;
  void clear_users_fetch();
  static const int kUsersFetchFieldNumber = 9;
  const ::server::TUsersFetch& users_fetch() const;
  ::server::TUsersFetch* mutable_users_fetch();
  ::server::TUsersFetch* release_users_fetch();
  void set_allocated_users_fetch(::server::TUsersFetch* users_fetch);

  // optional .server.TSelf self = 10;
  bool has_self() const;
  void clear_self();
  static const int kSelfFieldNumber = 10;
  const ::server::TSelf& self() const;
  ::server::TSelf* mutable_self();
  ::server::TSelf* release_self();
  void set_allocated_self(::server::TSelf* self);

  // optional .server.TUsers users = 11;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 11;
  const ::server::TUsers& users() const;
  ::server::TUsers* mutable_users();
  ::server::TUsers* release_users();
  void set_allocated_users(::server::TUsers* users);

  // optional .server.TFriendAdd friend_add = 12;
  bool has_friend_add() const;
  void clear_friend_add();
  static const int kFriendAddFieldNumber = 12;
  const ::server::TFriendAdd& friend_add() const;
  ::server::TFriendAdd* mutable_friend_add();
  ::server::TFriendAdd* release_friend_add();
  void set_allocated_friend_add(::server::TFriendAdd* friend_add);

  // optional .server.TFriendRemove friend_remove = 13;
  bool has_friend_remove() const;
  void clear_friend_remove();
  static const int kFriendRemoveFieldNumber = 13;
  const ::server::TFriendRemove& friend_remove() const;
  ::server::TFriendRemove* mutable_friend_remove();
  ::server::TFriendRemove* release_friend_remove();
  void set_allocated_friend_remove(::server::TFriendRemove* friend_remove);

  // optional .server.TFriendBlock friend_block = 14;
  bool has_friend_block() const;
  void clear_friend_block();
  static const int kFriendBlockFieldNumber = 14;
  const ::server::TFriendBlock& friend_block() const;
  ::server::TFriendBlock* mutable_friend_block();
  ::server::TFriendBlock* release_friend_block();
  void set_allocated_friend_block(::server::TFriendBlock* friend_block);

  // optional .server.TFriendsList friends_list = 15;
  bool has_friends_list() const;
  void clear_friends_list();
  static const int kFriendsListFieldNumber = 15;
  const ::server::TFriendsList& friends_list() const;
  ::server::TFriendsList* mutable_friends_list();
  ::server::TFriendsList* release_friends_list();
  void set_allocated_friends_list(::server::TFriendsList* friends_list);

  // optional .server.TFriends friends = 16;
  bool has_friends() const;
  void clear_friends();
  static const int kFriendsFieldNumber = 16;
  const ::server::TFriends& friends() const;
  ::server::TFriends* mutable_friends();
  ::server::TFriends* release_friends();
  void set_allocated_friends(::server::TFriends* friends);

  // optional .server.TGroupCreate group_create = 17;
  bool has_group_create() const;
  void clear_group_create();
  static const int kGroupCreateFieldNumber = 17;
  const ::server::TGroupCreate& group_create() const;
  ::server::TGroupCreate* mutable_group_create();
  ::server::TGroupCreate* release_group_create();
  void set_allocated_group_create(::server::TGroupCreate* group_create);

  // optional .server.TGroupUpdate group_update = 18;
  bool has_group_update() const;
  void clear_group_update();
  static const int kGroupUpdateFieldNumber = 18;
  const ::server::TGroupUpdate& group_update() const;
  ::server::TGroupUpdate* mutable_group_update();
  ::server::TGroupUpdate* release_group_update();
  void set_allocated_group_update(::server::TGroupUpdate* group_update);

  // optional .server.TGroupRemove group_remove = 19;
  bool has_group_remove() const;
  void clear_group_remove();
  static const int kGroupRemoveFieldNumber = 19;
  const ::server::TGroupRemove& group_remove() const;
  ::server::TGroupRemove* mutable_group_remove();
  ::server::TGroupRemove* release_group_remove();
  void set_allocated_group_remove(::server::TGroupRemove* group_remove);

  // optional .server.TGroupsFetch groups_fetch = 20;
  bool has_groups_fetch() const;
  void clear_groups_fetch();
  static const int kGroupsFetchFieldNumber = 20;
  const ::server::TGroupsFetch& groups_fetch() const;
  ::server::TGroupsFetch* mutable_groups_fetch();
  ::server::TGroupsFetch* release_groups_fetch();
  void set_allocated_groups_fetch(::server::TGroupsFetch* groups_fetch);

  // optional .server.TGroupsList groups_list = 21;
  bool has_groups_list() const;
  void clear_groups_list();
  static const int kGroupsListFieldNumber = 21;
  const ::server::TGroupsList& groups_list() const;
  ::server::TGroupsList* mutable_groups_list();
  ::server::TGroupsList* release_groups_list();
  void set_allocated_groups_list(::server::TGroupsList* groups_list);

  // optional .server.TGroupsSelfList groups_self_list = 22;
  bool has_groups_self_list() const;
  void clear_groups_self_list();
  static const int kGroupsSelfListFieldNumber = 22;
  const ::server::TGroupsSelfList& groups_self_list() const;
  ::server::TGroupsSelfList* mutable_groups_self_list();
  ::server::TGroupsSelfList* release_groups_self_list();
  void set_allocated_groups_self_list(::server::TGroupsSelfList* groups_self_list);

  // optional .server.TGroupUsersList group_users_list = 23;
  bool has_group_users_list() const;
  void clear_group_users_list();
  static const int kGroupUsersListFieldNumber = 23;
  const ::server::TGroupUsersList& group_users_list() const;
  ::server::TGroupUsersList* mutable_group_users_list();
  ::server::TGroupUsersList* release_group_users_list();
  void set_allocated_group_users_list(::server::TGroupUsersList* group_users_list);

  // optional .server.TGroupJoin group_join = 24;
  bool has_group_join() const;
  void clear_group_join();
  static const int kGroupJoinFieldNumber = 24;
  const ::server::TGroupJoin& group_join() const;
  ::server::TGroupJoin* mutable_group_join();
  ::server::TGroupJoin* release_group_join();
  void set_allocated_group_join(::server::TGroupJoin* group_join);

  // optional .server.TGroupLeave group_leave = 25;
  bool has_group_leave() const;
  void clear_group_leave();
  static const int kGroupLeaveFieldNumber = 25;
  const ::server::TGroupLeave& group_leave() const;
  ::server::TGroupLeave* mutable_group_leave();
  ::server::TGroupLeave* release_group_leave();
  void set_allocated_group_leave(::server::TGroupLeave* group_leave);

  // optional .server.TGroupUserAdd group_user_add = 26;
  bool has_group_user_add() const;
  void clear_group_user_add();
  static const int kGroupUserAddFieldNumber = 26;
  const ::server::TGroupUserAdd& group_user_add() const;
  ::server::TGroupUserAdd* mutable_group_user_add();
  ::server::TGroupUserAdd* release_group_user_add();
  void set_allocated_group_user_add(::server::TGroupUserAdd* group_user_add);

  // optional .server.TGroupUserKick group_user_kick = 27;
  bool has_group_user_kick() const;
  void clear_group_user_kick();
  static const int kGroupUserKickFieldNumber = 27;
  const ::server::TGroupUserKick& group_user_kick() const;
  ::server::TGroupUserKick* mutable_group_user_kick();
  ::server::TGroupUserKick* release_group_user_kick();
  void set_allocated_group_user_kick(::server::TGroupUserKick* group_user_kick);

  // optional .server.TGroupUserPromote group_user_promote = 28;
  bool has_group_user_promote() const;
  void clear_group_user_promote();
  static const int kGroupUserPromoteFieldNumber = 28;
  const ::server::TGroupUserPromote& group_user_promote() const;
  ::server::TGroupUserPromote* mutable_group_user_promote();
  ::server::TGroupUserPromote* release_group_user_promote();
  void set_allocated_group_user_promote(::server::TGroupUserPromote* group_user_promote);

  // optional .server.TGroup group = 29;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 29;
  const ::server::TGroup& group() const;
  ::server::TGroup* mutable_group();
  ::server::TGroup* release_group();
  void set_allocated_group(::server::TGroup* group);

  // optional .server.TGroups groups = 30;
  bool has_groups() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 30;
  const ::server::TGroups& groups() const;
  ::server::TGroups* mutable_groups();
  ::server::TGroups* release_groups();
  void set_allocated_groups(::server::TGroups* groups);

  // optional .server.TGroupUsers group_users = 31;
  bool has_group_users() const;
  void clear_group_users();
  static const int kGroupUsersFieldNumber = 31;
  const ::server::TGroupUsers& group_users() const;
  ::server::TGroupUsers* mutable_group_users();
  ::server::TGroupUsers* release_group_users();
  void set_allocated_group_users(::server::TGroupUsers* group_users);

  // optional .server.TTopicJoin topic_join = 32;
  bool has_topic_join() const;
  void clear_topic_join();
  static const int kTopicJoinFieldNumber = 32;
  const ::server::TTopicJoin& topic_join() const;
  ::server::TTopicJoin* mutable_topic_join();
  ::server::TTopicJoin* release_topic_join();
  void set_allocated_topic_join(::server::TTopicJoin* topic_join);

  // optional .server.TTopicLeave topic_leave = 33;
  bool has_topic_leave() const;
  void clear_topic_leave();
  static const int kTopicLeaveFieldNumber = 33;
  const ::server::TTopicLeave& topic_leave() const;
  ::server::TTopicLeave* mutable_topic_leave();
  ::server::TTopicLeave* release_topic_leave();
  void set_allocated_topic_leave(::server::TTopicLeave* topic_leave);

  // optional .server.TTopicMessageSend topic_message_send = 34;
  bool has_topic_message_send() const;
  void clear_topic_message_send();
  static const int kTopicMessageSendFieldNumber = 34;
  const ::server::TTopicMessageSend& topic_message_send() const;
  ::server::TTopicMessageSend* mutable_topic_message_send();
  ::server::TTopicMessageSend* release_topic_message_send();
  void set_allocated_topic_message_send(::server::TTopicMessageSend* topic_message_send);

  // optional .server.TTopicMessagesList topic_messages_list = 35;
  bool has_topic_messages_list() const;
  void clear_topic_messages_list();
  static const int kTopicMessagesListFieldNumber = 35;
  const ::server::TTopicMessagesList& topic_messages_list() const;
  ::server::TTopicMessagesList* mutable_topic_messages_list();
  ::server::TTopicMessagesList* release_topic_messages_list();
  void set_allocated_topic_messages_list(::server::TTopicMessagesList* topic_messages_list);

  // optional .server.TTopic topic = 36;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 36;
  const ::server::TTopic& topic() const;
  ::server::TTopic* mutable_topic();
  ::server::TTopic* release_topic();
  void set_allocated_topic(::server::TTopic* topic);

  // optional .server.TTopicMessageAck topic_message_ack = 37;
  bool has_topic_message_ack() const;
  void clear_topic_message_ack();
  static const int kTopicMessageAckFieldNumber = 37;
  const ::server::TTopicMessageAck& topic_message_ack() const;
  ::server::TTopicMessageAck* mutable_topic_message_ack();
  ::server::TTopicMessageAck* release_topic_message_ack();
  void set_allocated_topic_message_ack(::server::TTopicMessageAck* topic_message_ack);

  // optional .server.TopicMessage topic_message = 38;
  bool has_topic_message() const;
  void clear_topic_message();
  static const int kTopicMessageFieldNumber = 38;
  const ::server::TopicMessage& topic_message() const;
  ::server::TopicMessage* mutable_topic_message();
  ::server::TopicMessage* release_topic_message();
  void set_allocated_topic_message(::server::TopicMessage* topic_message);

  // optional .server.TTopicMessages topic_messages = 39;
  bool has_topic_messages() const;
  void clear_topic_messages();
  static const int kTopicMessagesFieldNumber = 39;
  const ::server::TTopicMessages& topic_messages() const;
  ::server::TTopicMessages* mutable_topic_messages();
  ::server::TTopicMessages* release_topic_messages();
  void set_allocated_topic_messages(::server::TTopicMessages* topic_messages);

  // optional .server.TopicPresence topic_presence = 40;
  bool has_topic_presence() const;
  void clear_topic_presence();
  static const int kTopicPresenceFieldNumber = 40;
  const ::server::TopicPresence& topic_presence() const;
  ::server::TopicPresence* mutable_topic_presence();
  ::server::TopicPresence* release_topic_presence();
  void set_allocated_topic_presence(::server::TopicPresence* topic_presence);

  // optional .server.TMatchCreate match_create = 41;
  bool has_match_create() const;
  void clear_match_create();
  static const int kMatchCreateFieldNumber = 41;
  const ::server::TMatchCreate& match_create() const;
  ::server::TMatchCreate* mutable_match_create();
  ::server::TMatchCreate* release_match_create();
  void set_allocated_match_create(::server::TMatchCreate* match_create);

  // optional .server.TMatchJoin match_join = 42;
  bool has_match_join() const;
  void clear_match_join();
  static const int kMatchJoinFieldNumber = 42;
  const ::server::TMatchJoin& match_join() const;
  ::server::TMatchJoin* mutable_match_join();
  ::server::TMatchJoin* release_match_join();
  void set_allocated_match_join(::server::TMatchJoin* match_join);

  // optional .server.TMatchLeave match_leave = 43;
  bool has_match_leave() const;
  void clear_match_leave();
  static const int kMatchLeaveFieldNumber = 43;
  const ::server::TMatchLeave& match_leave() const;
  ::server::TMatchLeave* mutable_match_leave();
  ::server::TMatchLeave* release_match_leave();
  void set_allocated_match_leave(::server::TMatchLeave* match_leave);

  // optional .server.MatchDataSend match_data_send = 44;
  bool has_match_data_send() const;
  void clear_match_data_send();
  static const int kMatchDataSendFieldNumber = 44;
  const ::server::MatchDataSend& match_data_send() const;
  ::server::MatchDataSend* mutable_match_data_send();
  ::server::MatchDataSend* release_match_data_send();
  void set_allocated_match_data_send(::server::MatchDataSend* match_data_send);

  // optional .server.TMatch match = 45;
  bool has_match() const;
  void clear_match();
  static const int kMatchFieldNumber = 45;
  const ::server::TMatch& match() const;
  ::server::TMatch* mutable_match();
  ::server::TMatch* release_match();
  void set_allocated_match(::server::TMatch* match);

  // optional .server.MatchData match_data = 46;
  bool has_match_data() const;
  void clear_match_data();
  static const int kMatchDataFieldNumber = 46;
  const ::server::MatchData& match_data() const;
  ::server::MatchData* mutable_match_data();
  ::server::MatchData* release_match_data();
  void set_allocated_match_data(::server::MatchData* match_data);

  // optional .server.MatchPresence match_presence = 47;
  bool has_match_presence() const;
  void clear_match_presence();
  static const int kMatchPresenceFieldNumber = 47;
  const ::server::MatchPresence& match_presence() const;
  ::server::MatchPresence* mutable_match_presence();
  ::server::MatchPresence* release_match_presence();
  void set_allocated_match_presence(::server::MatchPresence* match_presence);

  // optional .server.TStorageFetch storage_fetch = 48;
  bool has_storage_fetch() const;
  void clear_storage_fetch();
  static const int kStorageFetchFieldNumber = 48;
  const ::server::TStorageFetch& storage_fetch() const;
  ::server::TStorageFetch* mutable_storage_fetch();
  ::server::TStorageFetch* release_storage_fetch();
  void set_allocated_storage_fetch(::server::TStorageFetch* storage_fetch);

  // optional .server.TStorageWrite storage_write = 49;
  bool has_storage_write() const;
  void clear_storage_write();
  static const int kStorageWriteFieldNumber = 49;
  const ::server::TStorageWrite& storage_write() const;
  ::server::TStorageWrite* mutable_storage_write();
  ::server::TStorageWrite* release_storage_write();
  void set_allocated_storage_write(::server::TStorageWrite* storage_write);

  // optional .server.TStorageRemove storage_remove = 50;
  bool has_storage_remove() const;
  void clear_storage_remove();
  static const int kStorageRemoveFieldNumber = 50;
  const ::server::TStorageRemove& storage_remove() const;
  ::server::TStorageRemove* mutable_storage_remove();
  ::server::TStorageRemove* release_storage_remove();
  void set_allocated_storage_remove(::server::TStorageRemove* storage_remove);

  // optional .server.TStorageData storage_data = 51;
  bool has_storage_data() const;
  void clear_storage_data();
  static const int kStorageDataFieldNumber = 51;
  const ::server::TStorageData& storage_data() const;
  ::server::TStorageData* mutable_storage_data();
  ::server::TStorageData* release_storage_data();
  void set_allocated_storage_data(::server::TStorageData* storage_data);

  // optional .server.TStorageKey storage_key = 52;
  bool has_storage_key() const;
  void clear_storage_key();
  static const int kStorageKeyFieldNumber = 52;
  const ::server::TStorageKey& storage_key() const;
  ::server::TStorageKey* mutable_storage_key();
  ::server::TStorageKey* release_storage_key();
  void set_allocated_storage_key(::server::TStorageKey* storage_key);

  // optional .server.TLeaderboardsList leaderboards_list = 53;
  bool has_leaderboards_list() const;
  void clear_leaderboards_list();
  static const int kLeaderboardsListFieldNumber = 53;
  const ::server::TLeaderboardsList& leaderboards_list() const;
  ::server::TLeaderboardsList* mutable_leaderboards_list();
  ::server::TLeaderboardsList* release_leaderboards_list();
  void set_allocated_leaderboards_list(::server::TLeaderboardsList* leaderboards_list);

  // optional .server.TLeaderboardRecordWrite leaderboard_record_write = 54;
  bool has_leaderboard_record_write() const;
  void clear_leaderboard_record_write();
  static const int kLeaderboardRecordWriteFieldNumber = 54;
  const ::server::TLeaderboardRecordWrite& leaderboard_record_write() const;
  ::server::TLeaderboardRecordWrite* mutable_leaderboard_record_write();
  ::server::TLeaderboardRecordWrite* release_leaderboard_record_write();
  void set_allocated_leaderboard_record_write(::server::TLeaderboardRecordWrite* leaderboard_record_write);

  // optional .server.TLeaderboardRecordsFetch leaderboard_records_fetch = 55;
  bool has_leaderboard_records_fetch() const;
  void clear_leaderboard_records_fetch();
  static const int kLeaderboardRecordsFetchFieldNumber = 55;
  const ::server::TLeaderboardRecordsFetch& leaderboard_records_fetch() const;
  ::server::TLeaderboardRecordsFetch* mutable_leaderboard_records_fetch();
  ::server::TLeaderboardRecordsFetch* release_leaderboard_records_fetch();
  void set_allocated_leaderboard_records_fetch(::server::TLeaderboardRecordsFetch* leaderboard_records_fetch);

  // optional .server.TLeaderboardRecordsList leaderboard_records_list = 56;
  bool has_leaderboard_records_list() const;
  void clear_leaderboard_records_list();
  static const int kLeaderboardRecordsListFieldNumber = 56;
  const ::server::TLeaderboardRecordsList& leaderboard_records_list() const;
  ::server::TLeaderboardRecordsList* mutable_leaderboard_records_list();
  ::server::TLeaderboardRecordsList* release_leaderboard_records_list();
  void set_allocated_leaderboard_records_list(::server::TLeaderboardRecordsList* leaderboard_records_list);

  // optional .server.TLeaderboards leaderboards = 57;
  bool has_leaderboards() const;
  void clear_leaderboards();
  static const int kLeaderboardsFieldNumber = 57;
  const ::server::TLeaderboards& leaderboards() const;
  ::server::TLeaderboards* mutable_leaderboards();
  ::server::TLeaderboards* release_leaderboards();
  void set_allocated_leaderboards(::server::TLeaderboards* leaderboards);

  // optional .server.TLeaderboardRecord leaderboard_record = 58;
  bool has_leaderboard_record() const;
  void clear_leaderboard_record();
  static const int kLeaderboardRecordFieldNumber = 58;
  const ::server::TLeaderboardRecord& leaderboard_record() const;
  ::server::TLeaderboardRecord* mutable_leaderboard_record();
  ::server::TLeaderboardRecord* release_leaderboard_record();
  void set_allocated_leaderboard_record(::server::TLeaderboardRecord* leaderboard_record);

  // optional .server.TLeaderboardRecords leaderboard_records = 59;
  bool has_leaderboard_records() const;
  void clear_leaderboard_records();
  static const int kLeaderboardRecordsFieldNumber = 59;
  const ::server::TLeaderboardRecords& leaderboard_records() const;
  ::server::TLeaderboardRecords* mutable_leaderboard_records();
  ::server::TLeaderboardRecords* release_leaderboard_records();
  void set_allocated_leaderboard_records(::server::TLeaderboardRecords* leaderboard_records);

  // optional .server.TMatchmakeAdd matchmake_add = 60;
  bool has_matchmake_add() const;
  void clear_matchmake_add();
  static const int kMatchmakeAddFieldNumber = 60;
  const ::server::TMatchmakeAdd& matchmake_add() const;
  ::server::TMatchmakeAdd* mutable_matchmake_add();
  ::server::TMatchmakeAdd* release_matchmake_add();
  void set_allocated_matchmake_add(::server::TMatchmakeAdd* matchmake_add);

  // optional .server.TMatchmakeRemove matchmake_remove = 61;
  bool has_matchmake_remove() const;
  void clear_matchmake_remove();
  static const int kMatchmakeRemoveFieldNumber = 61;
  const ::server::TMatchmakeRemove& matchmake_remove() const;
  ::server::TMatchmakeRemove* mutable_matchmake_remove();
  ::server::TMatchmakeRemove* release_matchmake_remove();
  void set_allocated_matchmake_remove(::server::TMatchmakeRemove* matchmake_remove);

  // optional .server.TMatchmakeTicket matchmake_ticket = 62;
  bool has_matchmake_ticket() const;
  void clear_matchmake_ticket();
  static const int kMatchmakeTicketFieldNumber = 62;
  const ::server::TMatchmakeTicket& matchmake_ticket() const;
  ::server::TMatchmakeTicket* mutable_matchmake_ticket();
  ::server::TMatchmakeTicket* release_matchmake_ticket();
  void set_allocated_matchmake_ticket(::server::TMatchmakeTicket* matchmake_ticket);

  // optional .server.MatchmakeMatched matchmake_matched = 63;
  bool has_matchmake_matched() const;
  void clear_matchmake_matched();
  static const int kMatchmakeMatchedFieldNumber = 63;
  const ::server::MatchmakeMatched& matchmake_matched() const;
  ::server::MatchmakeMatched* mutable_matchmake_matched();
  ::server::MatchmakeMatched* release_matchmake_matched();
  void set_allocated_matchmake_matched(::server::MatchmakeMatched* matchmake_matched);

  // optional .server.TRpc rpc = 64;
  bool has_rpc() const;
  void clear_rpc();
  static const int kRpcFieldNumber = 64;
  const ::server::TRpc& rpc() const;
  ::server::TRpc* mutable_rpc();
  ::server::TRpc* release_rpc();
  void set_allocated_rpc(::server::TRpc* rpc);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:server.Envelope)
 private:
  inline void set_has_error();
  inline void set_has_heartbeat();
  inline void set_has_logout();
  inline void set_has_link();
  inline void set_has_unlink();
  inline void set_has_self_fetch();
  inline void set_has_self_update();
  inline void set_has_users_fetch();
  inline void set_has_self();
  inline void set_has_users();
  inline void set_has_friend_add();
  inline void set_has_friend_remove();
  inline void set_has_friend_block();
  inline void set_has_friends_list();
  inline void set_has_friends();
  inline void set_has_group_create();
  inline void set_has_group_update();
  inline void set_has_group_remove();
  inline void set_has_groups_fetch();
  inline void set_has_groups_list();
  inline void set_has_groups_self_list();
  inline void set_has_group_users_list();
  inline void set_has_group_join();
  inline void set_has_group_leave();
  inline void set_has_group_user_add();
  inline void set_has_group_user_kick();
  inline void set_has_group_user_promote();
  inline void set_has_group();
  inline void set_has_groups();
  inline void set_has_group_users();
  inline void set_has_topic_join();
  inline void set_has_topic_leave();
  inline void set_has_topic_message_send();
  inline void set_has_topic_messages_list();
  inline void set_has_topic();
  inline void set_has_topic_message_ack();
  inline void set_has_topic_message();
  inline void set_has_topic_messages();
  inline void set_has_topic_presence();
  inline void set_has_match_create();
  inline void set_has_match_join();
  inline void set_has_match_leave();
  inline void set_has_match_data_send();
  inline void set_has_match();
  inline void set_has_match_data();
  inline void set_has_match_presence();
  inline void set_has_storage_fetch();
  inline void set_has_storage_write();
  inline void set_has_storage_remove();
  inline void set_has_storage_data();
  inline void set_has_storage_key();
  inline void set_has_leaderboards_list();
  inline void set_has_leaderboard_record_write();
  inline void set_has_leaderboard_records_fetch();
  inline void set_has_leaderboard_records_list();
  inline void set_has_leaderboards();
  inline void set_has_leaderboard_record();
  inline void set_has_leaderboard_records();
  inline void set_has_matchmake_add();
  inline void set_has_matchmake_remove();
  inline void set_has_matchmake_ticket();
  inline void set_has_matchmake_matched();
  inline void set_has_rpc();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collation_id_;
  union PayloadUnion {
    PayloadUnion() {}
    ::server::Error* error_;
    ::server::Heartbeat* heartbeat_;
    ::server::Logout* logout_;
    ::server::TLink* link_;
    ::server::TUnlink* unlink_;
    ::server::TSelfFetch* self_fetch_;
    ::server::TSelfUpdate* self_update_;
    ::server::TUsersFetch* users_fetch_;
    ::server::TSelf* self_;
    ::server::TUsers* users_;
    ::server::TFriendAdd* friend_add_;
    ::server::TFriendRemove* friend_remove_;
    ::server::TFriendBlock* friend_block_;
    ::server::TFriendsList* friends_list_;
    ::server::TFriends* friends_;
    ::server::TGroupCreate* group_create_;
    ::server::TGroupUpdate* group_update_;
    ::server::TGroupRemove* group_remove_;
    ::server::TGroupsFetch* groups_fetch_;
    ::server::TGroupsList* groups_list_;
    ::server::TGroupsSelfList* groups_self_list_;
    ::server::TGroupUsersList* group_users_list_;
    ::server::TGroupJoin* group_join_;
    ::server::TGroupLeave* group_leave_;
    ::server::TGroupUserAdd* group_user_add_;
    ::server::TGroupUserKick* group_user_kick_;
    ::server::TGroupUserPromote* group_user_promote_;
    ::server::TGroup* group_;
    ::server::TGroups* groups_;
    ::server::TGroupUsers* group_users_;
    ::server::TTopicJoin* topic_join_;
    ::server::TTopicLeave* topic_leave_;
    ::server::TTopicMessageSend* topic_message_send_;
    ::server::TTopicMessagesList* topic_messages_list_;
    ::server::TTopic* topic_;
    ::server::TTopicMessageAck* topic_message_ack_;
    ::server::TopicMessage* topic_message_;
    ::server::TTopicMessages* topic_messages_;
    ::server::TopicPresence* topic_presence_;
    ::server::TMatchCreate* match_create_;
    ::server::TMatchJoin* match_join_;
    ::server::TMatchLeave* match_leave_;
    ::server::MatchDataSend* match_data_send_;
    ::server::TMatch* match_;
    ::server::MatchData* match_data_;
    ::server::MatchPresence* match_presence_;
    ::server::TStorageFetch* storage_fetch_;
    ::server::TStorageWrite* storage_write_;
    ::server::TStorageRemove* storage_remove_;
    ::server::TStorageData* storage_data_;
    ::server::TStorageKey* storage_key_;
    ::server::TLeaderboardsList* leaderboards_list_;
    ::server::TLeaderboardRecordWrite* leaderboard_record_write_;
    ::server::TLeaderboardRecordsFetch* leaderboard_records_fetch_;
    ::server::TLeaderboardRecordsList* leaderboard_records_list_;
    ::server::TLeaderboards* leaderboards_;
    ::server::TLeaderboardRecord* leaderboard_record_;
    ::server::TLeaderboardRecords* leaderboard_records_;
    ::server::TMatchmakeAdd* matchmake_add_;
    ::server::TMatchmakeRemove* matchmake_remove_;
    ::server::TMatchmakeTicket* matchmake_ticket_;
    ::server::MatchmakeMatched* matchmake_matched_;
    ::server::TRpc* rpc_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Envelope> Envelope_default_instance_;

// -------------------------------------------------------------------

class Logout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.Logout) */ {
 public:
  Logout();
  virtual ~Logout();

  Logout(const Logout& from);

  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logout& default_instance();

  static const Logout* internal_default_instance();

  void Swap(Logout* other);

  // implements Message ----------------------------------------------

  inline Logout* New() const { return New(NULL); }

  Logout* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Logout* other);
  void UnsafeMergeFrom(const Logout& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:server.Logout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Logout> Logout_default_instance_;

// -------------------------------------------------------------------

class TLink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TLink) */ {
 public:
  TLink();
  virtual ~TLink();

  TLink(const TLink& from);

  inline TLink& operator=(const TLink& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLink& default_instance();

  enum PayloadCase {
    kEmail = 1,
    kFacebook = 2,
    kGoogle = 3,
    kGameCenter = 4,
    kSteam = 5,
    kDevice = 6,
    kCustom = 7,
    PAYLOAD_NOT_SET = 0,
  };

  static const TLink* internal_default_instance();

  void Swap(TLink* other);

  // implements Message ----------------------------------------------

  inline TLink* New() const { return New(NULL); }

  TLink* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLink& from);
  void MergeFrom(const TLink& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLink* other);
  void UnsafeMergeFrom(const TLink& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.AuthenticateRequest.Email email = 1;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 1;
  const ::server::AuthenticateRequest_Email& email() const;
  ::server::AuthenticateRequest_Email* mutable_email();
  ::server::AuthenticateRequest_Email* release_email();
  void set_allocated_email(::server::AuthenticateRequest_Email* email);

  // optional string facebook = 2;
  private:
  bool has_facebook() const;
  public:
  void clear_facebook();
  static const int kFacebookFieldNumber = 2;
  const ::std::string& facebook() const;
  void set_facebook(const ::std::string& value);
  void set_facebook(const char* value);
  void set_facebook(const char* value, size_t size);
  ::std::string* mutable_facebook();
  ::std::string* release_facebook();
  void set_allocated_facebook(::std::string* facebook);

  // optional string google = 3;
  private:
  bool has_google() const;
  public:
  void clear_google();
  static const int kGoogleFieldNumber = 3;
  const ::std::string& google() const;
  void set_google(const ::std::string& value);
  void set_google(const char* value);
  void set_google(const char* value, size_t size);
  ::std::string* mutable_google();
  ::std::string* release_google();
  void set_allocated_google(::std::string* google);

  // optional .server.AuthenticateRequest.GameCenter game_center = 4;
  bool has_game_center() const;
  void clear_game_center();
  static const int kGameCenterFieldNumber = 4;
  const ::server::AuthenticateRequest_GameCenter& game_center() const;
  ::server::AuthenticateRequest_GameCenter* mutable_game_center();
  ::server::AuthenticateRequest_GameCenter* release_game_center();
  void set_allocated_game_center(::server::AuthenticateRequest_GameCenter* game_center);

  // optional string steam = 5;
  private:
  bool has_steam() const;
  public:
  void clear_steam();
  static const int kSteamFieldNumber = 5;
  const ::std::string& steam() const;
  void set_steam(const ::std::string& value);
  void set_steam(const char* value);
  void set_steam(const char* value, size_t size);
  ::std::string* mutable_steam();
  ::std::string* release_steam();
  void set_allocated_steam(::std::string* steam);

  // optional string device = 6;
  private:
  bool has_device() const;
  public:
  void clear_device();
  static const int kDeviceFieldNumber = 6;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // optional string custom = 7;
  private:
  bool has_custom() const;
  public:
  void clear_custom();
  static const int kCustomFieldNumber = 7;
  const ::std::string& custom() const;
  void set_custom(const ::std::string& value);
  void set_custom(const char* value);
  void set_custom(const char* value, size_t size);
  ::std::string* mutable_custom();
  ::std::string* release_custom();
  void set_allocated_custom(::std::string* custom);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:server.TLink)
 private:
  inline void set_has_email();
  inline void set_has_facebook();
  inline void set_has_google();
  inline void set_has_game_center();
  inline void set_has_steam();
  inline void set_has_device();
  inline void set_has_custom();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::server::AuthenticateRequest_Email* email_;
    ::google::protobuf::internal::ArenaStringPtr facebook_;
    ::google::protobuf::internal::ArenaStringPtr google_;
    ::server::AuthenticateRequest_GameCenter* game_center_;
    ::google::protobuf::internal::ArenaStringPtr steam_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr custom_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TLink> TLink_default_instance_;

// -------------------------------------------------------------------

class TUnlink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TUnlink) */ {
 public:
  TUnlink();
  virtual ~TUnlink();

  TUnlink(const TUnlink& from);

  inline TUnlink& operator=(const TUnlink& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TUnlink& default_instance();

  enum PayloadCase {
    kEmail = 1,
    kFacebook = 2,
    kGoogle = 3,
    kGameCenter = 4,
    kSteam = 5,
    kDevice = 6,
    kCustom = 7,
    PAYLOAD_NOT_SET = 0,
  };

  static const TUnlink* internal_default_instance();

  void Swap(TUnlink* other);

  // implements Message ----------------------------------------------

  inline TUnlink* New() const { return New(NULL); }

  TUnlink* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TUnlink& from);
  void MergeFrom(const TUnlink& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TUnlink* other);
  void UnsafeMergeFrom(const TUnlink& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string email = 1;
  private:
  bool has_email() const;
  public:
  void clear_email();
  static const int kEmailFieldNumber = 1;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // optional string facebook = 2;
  private:
  bool has_facebook() const;
  public:
  void clear_facebook();
  static const int kFacebookFieldNumber = 2;
  const ::std::string& facebook() const;
  void set_facebook(const ::std::string& value);
  void set_facebook(const char* value);
  void set_facebook(const char* value, size_t size);
  ::std::string* mutable_facebook();
  ::std::string* release_facebook();
  void set_allocated_facebook(::std::string* facebook);

  // optional string google = 3;
  private:
  bool has_google() const;
  public:
  void clear_google();
  static const int kGoogleFieldNumber = 3;
  const ::std::string& google() const;
  void set_google(const ::std::string& value);
  void set_google(const char* value);
  void set_google(const char* value, size_t size);
  ::std::string* mutable_google();
  ::std::string* release_google();
  void set_allocated_google(::std::string* google);

  // optional string game_center = 4;
  private:
  bool has_game_center() const;
  public:
  void clear_game_center();
  static const int kGameCenterFieldNumber = 4;
  const ::std::string& game_center() const;
  void set_game_center(const ::std::string& value);
  void set_game_center(const char* value);
  void set_game_center(const char* value, size_t size);
  ::std::string* mutable_game_center();
  ::std::string* release_game_center();
  void set_allocated_game_center(::std::string* game_center);

  // optional string steam = 5;
  private:
  bool has_steam() const;
  public:
  void clear_steam();
  static const int kSteamFieldNumber = 5;
  const ::std::string& steam() const;
  void set_steam(const ::std::string& value);
  void set_steam(const char* value);
  void set_steam(const char* value, size_t size);
  ::std::string* mutable_steam();
  ::std::string* release_steam();
  void set_allocated_steam(::std::string* steam);

  // optional string device = 6;
  private:
  bool has_device() const;
  public:
  void clear_device();
  static const int kDeviceFieldNumber = 6;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // optional string custom = 7;
  private:
  bool has_custom() const;
  public:
  void clear_custom();
  static const int kCustomFieldNumber = 7;
  const ::std::string& custom() const;
  void set_custom(const ::std::string& value);
  void set_custom(const char* value);
  void set_custom(const char* value, size_t size);
  ::std::string* mutable_custom();
  ::std::string* release_custom();
  void set_allocated_custom(::std::string* custom);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:server.TUnlink)
 private:
  inline void set_has_email();
  inline void set_has_facebook();
  inline void set_has_google();
  inline void set_has_game_center();
  inline void set_has_steam();
  inline void set_has_device();
  inline void set_has_custom();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr facebook_;
    ::google::protobuf::internal::ArenaStringPtr google_;
    ::google::protobuf::internal::ArenaStringPtr game_center_;
    ::google::protobuf::internal::ArenaStringPtr steam_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr custom_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TUnlink> TUnlink_default_instance_;

// -------------------------------------------------------------------

class User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  static const User* internal_default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  inline User* New() const { return New(NULL); }

  User* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(User* other);
  void UnsafeMergeFrom(const User& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string handle = 2;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // optional string fullname = 3;
  void clear_fullname();
  static const int kFullnameFieldNumber = 3;
  const ::std::string& fullname() const;
  void set_fullname(const ::std::string& value);
  void set_fullname(const char* value);
  void set_fullname(const char* value, size_t size);
  ::std::string* mutable_fullname();
  ::std::string* release_fullname();
  void set_allocated_fullname(::std::string* fullname);

  // optional string avatar_url = 4;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 4;
  const ::std::string& avatar_url() const;
  void set_avatar_url(const ::std::string& value);
  void set_avatar_url(const char* value);
  void set_avatar_url(const char* value, size_t size);
  ::std::string* mutable_avatar_url();
  ::std::string* release_avatar_url();
  void set_allocated_avatar_url(::std::string* avatar_url);

  // optional string lang = 5;
  void clear_lang();
  static const int kLangFieldNumber = 5;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional string location = 6;
  void clear_location();
  static const int kLocationFieldNumber = 6;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // optional string timezone = 7;
  void clear_timezone();
  static const int kTimezoneFieldNumber = 7;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional bytes metadata = 8;
  void clear_metadata();
  static const int kMetadataFieldNumber = 8;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // optional int64 created_at = 9;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 9;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // optional int64 updated_at = 10;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 10;
  ::google::protobuf::int64 updated_at() const;
  void set_updated_at(::google::protobuf::int64 value);

  // optional int64 last_online_at = 11;
  void clear_last_online_at();
  static const int kLastOnlineAtFieldNumber = 11;
  ::google::protobuf::int64 last_online_at() const;
  void set_last_online_at(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:server.User)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::google::protobuf::internal::ArenaStringPtr fullname_;
  ::google::protobuf::internal::ArenaStringPtr avatar_url_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::int64 created_at_;
  ::google::protobuf::int64 updated_at_;
  ::google::protobuf::int64 last_online_at_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<User> User_default_instance_;

// -------------------------------------------------------------------

class Self : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.Self) */ {
 public:
  Self();
  virtual ~Self();

  Self(const Self& from);

  inline Self& operator=(const Self& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Self& default_instance();

  static const Self* internal_default_instance();

  void Swap(Self* other);

  // implements Message ----------------------------------------------

  inline Self* New() const { return New(NULL); }

  Self* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Self& from);
  void MergeFrom(const Self& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Self* other);
  void UnsafeMergeFrom(const Self& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.User user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::server::User& user() const;
  ::server::User* mutable_user();
  ::server::User* release_user();
  void set_allocated_user(::server::User* user);

  // optional bool verified = 2;
  void clear_verified();
  static const int kVerifiedFieldNumber = 2;
  bool verified() const;
  void set_verified(bool value);

  // optional string email = 3;
  void clear_email();
  static const int kEmailFieldNumber = 3;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // repeated string device_id = 4;
  int device_id_size() const;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 4;
  const ::std::string& device_id(int index) const;
  ::std::string* mutable_device_id(int index);
  void set_device_id(int index, const ::std::string& value);
  void set_device_id(int index, const char* value);
  void set_device_id(int index, const char* value, size_t size);
  ::std::string* add_device_id();
  void add_device_id(const ::std::string& value);
  void add_device_id(const char* value);
  void add_device_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& device_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_device_id();

  // optional string facebook_id = 5;
  void clear_facebook_id();
  static const int kFacebookIdFieldNumber = 5;
  const ::std::string& facebook_id() const;
  void set_facebook_id(const ::std::string& value);
  void set_facebook_id(const char* value);
  void set_facebook_id(const char* value, size_t size);
  ::std::string* mutable_facebook_id();
  ::std::string* release_facebook_id();
  void set_allocated_facebook_id(::std::string* facebook_id);

  // optional string google_id = 6;
  void clear_google_id();
  static const int kGoogleIdFieldNumber = 6;
  const ::std::string& google_id() const;
  void set_google_id(const ::std::string& value);
  void set_google_id(const char* value);
  void set_google_id(const char* value, size_t size);
  ::std::string* mutable_google_id();
  ::std::string* release_google_id();
  void set_allocated_google_id(::std::string* google_id);

  // optional string gamecenter_id = 7;
  void clear_gamecenter_id();
  static const int kGamecenterIdFieldNumber = 7;
  const ::std::string& gamecenter_id() const;
  void set_gamecenter_id(const ::std::string& value);
  void set_gamecenter_id(const char* value);
  void set_gamecenter_id(const char* value, size_t size);
  ::std::string* mutable_gamecenter_id();
  ::std::string* release_gamecenter_id();
  void set_allocated_gamecenter_id(::std::string* gamecenter_id);

  // optional string steam_id = 8;
  void clear_steam_id();
  static const int kSteamIdFieldNumber = 8;
  const ::std::string& steam_id() const;
  void set_steam_id(const ::std::string& value);
  void set_steam_id(const char* value);
  void set_steam_id(const char* value, size_t size);
  ::std::string* mutable_steam_id();
  ::std::string* release_steam_id();
  void set_allocated_steam_id(::std::string* steam_id);

  // optional string custom_id = 9;
  void clear_custom_id();
  static const int kCustomIdFieldNumber = 9;
  const ::std::string& custom_id() const;
  void set_custom_id(const ::std::string& value);
  void set_custom_id(const char* value);
  void set_custom_id(const char* value, size_t size);
  ::std::string* mutable_custom_id();
  ::std::string* release_custom_id();
  void set_allocated_custom_id(::std::string* custom_id);

  // @@protoc_insertion_point(class_scope:server.Self)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> device_id_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr facebook_id_;
  ::google::protobuf::internal::ArenaStringPtr google_id_;
  ::google::protobuf::internal::ArenaStringPtr gamecenter_id_;
  ::google::protobuf::internal::ArenaStringPtr steam_id_;
  ::google::protobuf::internal::ArenaStringPtr custom_id_;
  ::server::User* user_;
  bool verified_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Self> Self_default_instance_;

// -------------------------------------------------------------------

class TSelfFetch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TSelfFetch) */ {
 public:
  TSelfFetch();
  virtual ~TSelfFetch();

  TSelfFetch(const TSelfFetch& from);

  inline TSelfFetch& operator=(const TSelfFetch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSelfFetch& default_instance();

  static const TSelfFetch* internal_default_instance();

  void Swap(TSelfFetch* other);

  // implements Message ----------------------------------------------

  inline TSelfFetch* New() const { return New(NULL); }

  TSelfFetch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSelfFetch& from);
  void MergeFrom(const TSelfFetch& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TSelfFetch* other);
  void UnsafeMergeFrom(const TSelfFetch& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:server.TSelfFetch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TSelfFetch> TSelfFetch_default_instance_;

// -------------------------------------------------------------------

class TSelf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TSelf) */ {
 public:
  TSelf();
  virtual ~TSelf();

  TSelf(const TSelf& from);

  inline TSelf& operator=(const TSelf& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSelf& default_instance();

  static const TSelf* internal_default_instance();

  void Swap(TSelf* other);

  // implements Message ----------------------------------------------

  inline TSelf* New() const { return New(NULL); }

  TSelf* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSelf& from);
  void MergeFrom(const TSelf& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TSelf* other);
  void UnsafeMergeFrom(const TSelf& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.Self self = 1;
  bool has_self() const;
  void clear_self();
  static const int kSelfFieldNumber = 1;
  const ::server::Self& self() const;
  ::server::Self* mutable_self();
  ::server::Self* release_self();
  void set_allocated_self(::server::Self* self);

  // @@protoc_insertion_point(class_scope:server.TSelf)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::server::Self* self_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TSelf> TSelf_default_instance_;

// -------------------------------------------------------------------

class TSelfUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TSelfUpdate) */ {
 public:
  TSelfUpdate();
  virtual ~TSelfUpdate();

  TSelfUpdate(const TSelfUpdate& from);

  inline TSelfUpdate& operator=(const TSelfUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TSelfUpdate& default_instance();

  static const TSelfUpdate* internal_default_instance();

  void Swap(TSelfUpdate* other);

  // implements Message ----------------------------------------------

  inline TSelfUpdate* New() const { return New(NULL); }

  TSelfUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TSelfUpdate& from);
  void MergeFrom(const TSelfUpdate& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TSelfUpdate* other);
  void UnsafeMergeFrom(const TSelfUpdate& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string handle = 1;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // optional string fullname = 2;
  void clear_fullname();
  static const int kFullnameFieldNumber = 2;
  const ::std::string& fullname() const;
  void set_fullname(const ::std::string& value);
  void set_fullname(const char* value);
  void set_fullname(const char* value, size_t size);
  ::std::string* mutable_fullname();
  ::std::string* release_fullname();
  void set_allocated_fullname(::std::string* fullname);

  // optional string timezone = 3;
  void clear_timezone();
  static const int kTimezoneFieldNumber = 3;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional string location = 4;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // optional string lang = 5;
  void clear_lang();
  static const int kLangFieldNumber = 5;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional bytes metadata = 6;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // optional string avatar_url = 7;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 7;
  const ::std::string& avatar_url() const;
  void set_avatar_url(const ::std::string& value);
  void set_avatar_url(const char* value);
  void set_avatar_url(const char* value, size_t size);
  ::std::string* mutable_avatar_url();
  ::std::string* release_avatar_url();
  void set_allocated_avatar_url(::std::string* avatar_url);

  // @@protoc_insertion_point(class_scope:server.TSelfUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::google::protobuf::internal::ArenaStringPtr fullname_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::internal::ArenaStringPtr avatar_url_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TSelfUpdate> TSelfUpdate_default_instance_;

// -------------------------------------------------------------------

class TUsersFetch_UserIds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TUsersFetch.UserIds) */ {
 public:
  TUsersFetch_UserIds();
  virtual ~TUsersFetch_UserIds();

  TUsersFetch_UserIds(const TUsersFetch_UserIds& from);

  inline TUsersFetch_UserIds& operator=(const TUsersFetch_UserIds& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TUsersFetch_UserIds& default_instance();

  static const TUsersFetch_UserIds* internal_default_instance();

  void Swap(TUsersFetch_UserIds* other);

  // implements Message ----------------------------------------------

  inline TUsersFetch_UserIds* New() const { return New(NULL); }

  TUsersFetch_UserIds* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TUsersFetch_UserIds& from);
  void MergeFrom(const TUsersFetch_UserIds& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TUsersFetch_UserIds* other);
  void UnsafeMergeFrom(const TUsersFetch_UserIds& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes user_ids = 1;
  int user_ids_size() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 1;
  const ::std::string& user_ids(int index) const;
  ::std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const ::std::string& value);
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const void* value, size_t size);
  ::std::string* add_user_ids();
  void add_user_ids(const ::std::string& value);
  void add_user_ids(const char* value);
  void add_user_ids(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& user_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_ids();

  // @@protoc_insertion_point(class_scope:server.TUsersFetch.UserIds)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_ids_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TUsersFetch_UserIds> TUsersFetch_UserIds_default_instance_;

// -------------------------------------------------------------------

class TUsersFetch_Handles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TUsersFetch.Handles) */ {
 public:
  TUsersFetch_Handles();
  virtual ~TUsersFetch_Handles();

  TUsersFetch_Handles(const TUsersFetch_Handles& from);

  inline TUsersFetch_Handles& operator=(const TUsersFetch_Handles& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TUsersFetch_Handles& default_instance();

  static const TUsersFetch_Handles* internal_default_instance();

  void Swap(TUsersFetch_Handles* other);

  // implements Message ----------------------------------------------

  inline TUsersFetch_Handles* New() const { return New(NULL); }

  TUsersFetch_Handles* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TUsersFetch_Handles& from);
  void MergeFrom(const TUsersFetch_Handles& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TUsersFetch_Handles* other);
  void UnsafeMergeFrom(const TUsersFetch_Handles& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string handles = 1;
  int handles_size() const;
  void clear_handles();
  static const int kHandlesFieldNumber = 1;
  const ::std::string& handles(int index) const;
  ::std::string* mutable_handles(int index);
  void set_handles(int index, const ::std::string& value);
  void set_handles(int index, const char* value);
  void set_handles(int index, const char* value, size_t size);
  ::std::string* add_handles();
  void add_handles(const ::std::string& value);
  void add_handles(const char* value);
  void add_handles(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& handles() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_handles();

  // @@protoc_insertion_point(class_scope:server.TUsersFetch.Handles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> handles_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TUsersFetch_Handles> TUsersFetch_Handles_default_instance_;

// -------------------------------------------------------------------

class TUsersFetch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TUsersFetch) */ {
 public:
  TUsersFetch();
  virtual ~TUsersFetch();

  TUsersFetch(const TUsersFetch& from);

  inline TUsersFetch& operator=(const TUsersFetch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TUsersFetch& default_instance();

  enum SetCase {
    kUserIds = 1,
    kHandles = 2,
    SET_NOT_SET = 0,
  };

  static const TUsersFetch* internal_default_instance();

  void Swap(TUsersFetch* other);

  // implements Message ----------------------------------------------

  inline TUsersFetch* New() const { return New(NULL); }

  TUsersFetch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TUsersFetch& from);
  void MergeFrom(const TUsersFetch& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TUsersFetch* other);
  void UnsafeMergeFrom(const TUsersFetch& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TUsersFetch_UserIds UserIds;
  typedef TUsersFetch_Handles Handles;

  // accessors -------------------------------------------------------

  // optional .server.TUsersFetch.UserIds user_ids = 1;
  bool has_user_ids() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 1;
  const ::server::TUsersFetch_UserIds& user_ids() const;
  ::server::TUsersFetch_UserIds* mutable_user_ids();
  ::server::TUsersFetch_UserIds* release_user_ids();
  void set_allocated_user_ids(::server::TUsersFetch_UserIds* user_ids);

  // optional .server.TUsersFetch.Handles handles = 2;
  bool has_handles() const;
  void clear_handles();
  static const int kHandlesFieldNumber = 2;
  const ::server::TUsersFetch_Handles& handles() const;
  ::server::TUsersFetch_Handles* mutable_handles();
  ::server::TUsersFetch_Handles* release_handles();
  void set_allocated_handles(::server::TUsersFetch_Handles* handles);

  SetCase set_case() const;
  // @@protoc_insertion_point(class_scope:server.TUsersFetch)
 private:
  inline void set_has_user_ids();
  inline void set_has_handles();

  inline bool has_set() const;
  void clear_set();
  inline void clear_has_set();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union SetUnion {
    SetUnion() {}
    ::server::TUsersFetch_UserIds* user_ids_;
    ::server::TUsersFetch_Handles* handles_;
  } set_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TUsersFetch> TUsersFetch_default_instance_;

// -------------------------------------------------------------------

class TUsers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TUsers) */ {
 public:
  TUsers();
  virtual ~TUsers();

  TUsers(const TUsers& from);

  inline TUsers& operator=(const TUsers& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TUsers& default_instance();

  static const TUsers* internal_default_instance();

  void Swap(TUsers* other);

  // implements Message ----------------------------------------------

  inline TUsers* New() const { return New(NULL); }

  TUsers* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TUsers& from);
  void MergeFrom(const TUsers& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TUsers* other);
  void UnsafeMergeFrom(const TUsers& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.User users = 1;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 1;
  const ::server::User& users(int index) const;
  ::server::User* mutable_users(int index);
  ::server::User* add_users();
  ::google::protobuf::RepeatedPtrField< ::server::User >*
      mutable_users();
  const ::google::protobuf::RepeatedPtrField< ::server::User >&
      users() const;

  // @@protoc_insertion_point(class_scope:server.TUsers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::User > users_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TUsers> TUsers_default_instance_;

// -------------------------------------------------------------------

class Friend : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.Friend) */ {
 public:
  Friend();
  virtual ~Friend();

  Friend(const Friend& from);

  inline Friend& operator=(const Friend& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Friend& default_instance();

  static const Friend* internal_default_instance();

  void Swap(Friend* other);

  // implements Message ----------------------------------------------

  inline Friend* New() const { return New(NULL); }

  Friend* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Friend& from);
  void MergeFrom(const Friend& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Friend* other);
  void UnsafeMergeFrom(const Friend& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.User user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::server::User& user() const;
  ::server::User* mutable_user();
  ::server::User* release_user();
  void set_allocated_user(::server::User* user);

  // optional int64 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int64 type() const;
  void set_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:server.Friend)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::server::User* user_;
  ::google::protobuf::int64 type_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Friend> Friend_default_instance_;

// -------------------------------------------------------------------

class TFriendAdd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TFriendAdd) */ {
 public:
  TFriendAdd();
  virtual ~TFriendAdd();

  TFriendAdd(const TFriendAdd& from);

  inline TFriendAdd& operator=(const TFriendAdd& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFriendAdd& default_instance();

  enum SetCase {
    kUserId = 1,
    kHandle = 2,
    SET_NOT_SET = 0,
  };

  static const TFriendAdd* internal_default_instance();

  void Swap(TFriendAdd* other);

  // implements Message ----------------------------------------------

  inline TFriendAdd* New() const { return New(NULL); }

  TFriendAdd* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFriendAdd& from);
  void MergeFrom(const TFriendAdd& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TFriendAdd* other);
  void UnsafeMergeFrom(const TFriendAdd& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_id = 1;
  private:
  bool has_user_id() const;
  public:
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional string handle = 2;
  private:
  bool has_handle() const;
  public:
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  SetCase set_case() const;
  // @@protoc_insertion_point(class_scope:server.TFriendAdd)
 private:
  inline void set_has_user_id();
  inline void set_has_handle();

  inline bool has_set() const;
  void clear_set();
  inline void clear_has_set();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union SetUnion {
    SetUnion() {}
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr handle_;
  } set_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TFriendAdd> TFriendAdd_default_instance_;

// -------------------------------------------------------------------

class TFriendRemove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TFriendRemove) */ {
 public:
  TFriendRemove();
  virtual ~TFriendRemove();

  TFriendRemove(const TFriendRemove& from);

  inline TFriendRemove& operator=(const TFriendRemove& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFriendRemove& default_instance();

  static const TFriendRemove* internal_default_instance();

  void Swap(TFriendRemove* other);

  // implements Message ----------------------------------------------

  inline TFriendRemove* New() const { return New(NULL); }

  TFriendRemove* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFriendRemove& from);
  void MergeFrom(const TFriendRemove& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TFriendRemove* other);
  void UnsafeMergeFrom(const TFriendRemove& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:server.TFriendRemove)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TFriendRemove> TFriendRemove_default_instance_;

// -------------------------------------------------------------------

class TFriendBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TFriendBlock) */ {
 public:
  TFriendBlock();
  virtual ~TFriendBlock();

  TFriendBlock(const TFriendBlock& from);

  inline TFriendBlock& operator=(const TFriendBlock& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFriendBlock& default_instance();

  static const TFriendBlock* internal_default_instance();

  void Swap(TFriendBlock* other);

  // implements Message ----------------------------------------------

  inline TFriendBlock* New() const { return New(NULL); }

  TFriendBlock* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFriendBlock& from);
  void MergeFrom(const TFriendBlock& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TFriendBlock* other);
  void UnsafeMergeFrom(const TFriendBlock& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:server.TFriendBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TFriendBlock> TFriendBlock_default_instance_;

// -------------------------------------------------------------------

class TFriendsList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TFriendsList) */ {
 public:
  TFriendsList();
  virtual ~TFriendsList();

  TFriendsList(const TFriendsList& from);

  inline TFriendsList& operator=(const TFriendsList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFriendsList& default_instance();

  static const TFriendsList* internal_default_instance();

  void Swap(TFriendsList* other);

  // implements Message ----------------------------------------------

  inline TFriendsList* New() const { return New(NULL); }

  TFriendsList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFriendsList& from);
  void MergeFrom(const TFriendsList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TFriendsList* other);
  void UnsafeMergeFrom(const TFriendsList& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:server.TFriendsList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TFriendsList> TFriendsList_default_instance_;

// -------------------------------------------------------------------

class TFriends : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TFriends) */ {
 public:
  TFriends();
  virtual ~TFriends();

  TFriends(const TFriends& from);

  inline TFriends& operator=(const TFriends& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFriends& default_instance();

  static const TFriends* internal_default_instance();

  void Swap(TFriends* other);

  // implements Message ----------------------------------------------

  inline TFriends* New() const { return New(NULL); }

  TFriends* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TFriends& from);
  void MergeFrom(const TFriends& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TFriends* other);
  void UnsafeMergeFrom(const TFriends& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.Friend friends = 1;
  int friends_size() const;
  void clear_friends();
  static const int kFriendsFieldNumber = 1;
  const ::server::Friend& friends(int index) const;
  ::server::Friend* mutable_friends(int index);
  ::server::Friend* add_friends();
  ::google::protobuf::RepeatedPtrField< ::server::Friend >*
      mutable_friends();
  const ::google::protobuf::RepeatedPtrField< ::server::Friend >&
      friends() const;

  // @@protoc_insertion_point(class_scope:server.TFriends)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::Friend > friends_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TFriends> TFriends_default_instance_;

// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.Group) */ {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  static const Group* internal_default_instance();

  void Swap(Group* other);

  // implements Message ----------------------------------------------

  inline Group* New() const { return New(NULL); }

  Group* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Group* other);
  void UnsafeMergeFrom(const Group& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional bool private = 2;
  void clear_private_();
  static const int kPrivateFieldNumber = 2;
  bool private_() const;
  void set_private_(bool value);

  // optional bytes creator_id = 3;
  void clear_creator_id();
  static const int kCreatorIdFieldNumber = 3;
  const ::std::string& creator_id() const;
  void set_creator_id(const ::std::string& value);
  void set_creator_id(const char* value);
  void set_creator_id(const void* value, size_t size);
  ::std::string* mutable_creator_id();
  ::std::string* release_creator_id();
  void set_allocated_creator_id(::std::string* creator_id);

  // optional string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 5;
  void clear_description();
  static const int kDescriptionFieldNumber = 5;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string avatar_url = 6;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 6;
  const ::std::string& avatar_url() const;
  void set_avatar_url(const ::std::string& value);
  void set_avatar_url(const char* value);
  void set_avatar_url(const char* value, size_t size);
  ::std::string* mutable_avatar_url();
  ::std::string* release_avatar_url();
  void set_allocated_avatar_url(::std::string* avatar_url);

  // optional string lang = 7;
  void clear_lang();
  static const int kLangFieldNumber = 7;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional int64 utc_offset_ms = 8;
  void clear_utc_offset_ms();
  static const int kUtcOffsetMsFieldNumber = 8;
  ::google::protobuf::int64 utc_offset_ms() const;
  void set_utc_offset_ms(::google::protobuf::int64 value);

  // optional bytes metadata = 9;
  void clear_metadata();
  static const int kMetadataFieldNumber = 9;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // optional int64 count = 10;
  void clear_count();
  static const int kCountFieldNumber = 10;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // optional int64 created_at = 11;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 11;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // optional int64 updated_at = 12;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 12;
  ::google::protobuf::int64 updated_at() const;
  void set_updated_at(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:server.Group)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr creator_id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr avatar_url_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::int64 utc_offset_ms_;
  ::google::protobuf::int64 count_;
  ::google::protobuf::int64 created_at_;
  ::google::protobuf::int64 updated_at_;
  bool private__;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Group> Group_default_instance_;

// -------------------------------------------------------------------

class TGroupCreate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupCreate) */ {
 public:
  TGroupCreate();
  virtual ~TGroupCreate();

  TGroupCreate(const TGroupCreate& from);

  inline TGroupCreate& operator=(const TGroupCreate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupCreate& default_instance();

  static const TGroupCreate* internal_default_instance();

  void Swap(TGroupCreate* other);

  // implements Message ----------------------------------------------

  inline TGroupCreate* New() const { return New(NULL); }

  TGroupCreate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupCreate& from);
  void MergeFrom(const TGroupCreate& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupCreate* other);
  void UnsafeMergeFrom(const TGroupCreate& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 2;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string avatar_url = 3;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 3;
  const ::std::string& avatar_url() const;
  void set_avatar_url(const ::std::string& value);
  void set_avatar_url(const char* value);
  void set_avatar_url(const char* value, size_t size);
  ::std::string* mutable_avatar_url();
  ::std::string* release_avatar_url();
  void set_allocated_avatar_url(::std::string* avatar_url);

  // optional string lang = 4;
  void clear_lang();
  static const int kLangFieldNumber = 4;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional bytes metadata = 5;
  void clear_metadata();
  static const int kMetadataFieldNumber = 5;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // optional bool private = 6;
  void clear_private_();
  static const int kPrivateFieldNumber = 6;
  bool private_() const;
  void set_private_(bool value);

  // @@protoc_insertion_point(class_scope:server.TGroupCreate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr avatar_url_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  bool private__;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupCreate> TGroupCreate_default_instance_;

// -------------------------------------------------------------------

class TGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroup) */ {
 public:
  TGroup();
  virtual ~TGroup();

  TGroup(const TGroup& from);

  inline TGroup& operator=(const TGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroup& default_instance();

  static const TGroup* internal_default_instance();

  void Swap(TGroup* other);

  // implements Message ----------------------------------------------

  inline TGroup* New() const { return New(NULL); }

  TGroup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroup& from);
  void MergeFrom(const TGroup& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroup* other);
  void UnsafeMergeFrom(const TGroup& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.Group group = 1;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 1;
  const ::server::Group& group() const;
  ::server::Group* mutable_group();
  ::server::Group* release_group();
  void set_allocated_group(::server::Group* group);

  // @@protoc_insertion_point(class_scope:server.TGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::server::Group* group_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroup> TGroup_default_instance_;

// -------------------------------------------------------------------

class TGroupUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupUpdate) */ {
 public:
  TGroupUpdate();
  virtual ~TGroupUpdate();

  TGroupUpdate(const TGroupUpdate& from);

  inline TGroupUpdate& operator=(const TGroupUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupUpdate& default_instance();

  static const TGroupUpdate* internal_default_instance();

  void Swap(TGroupUpdate* other);

  // implements Message ----------------------------------------------

  inline TGroupUpdate* New() const { return New(NULL); }

  TGroupUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupUpdate& from);
  void MergeFrom(const TGroupUpdate& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupUpdate* other);
  void UnsafeMergeFrom(const TGroupUpdate& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // optional bool private = 2;
  void clear_private_();
  static const int kPrivateFieldNumber = 2;
  bool private_() const;
  void set_private_(bool value);

  // optional string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 4;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string avatar_url = 5;
  void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 5;
  const ::std::string& avatar_url() const;
  void set_avatar_url(const ::std::string& value);
  void set_avatar_url(const char* value);
  void set_avatar_url(const char* value, size_t size);
  ::std::string* mutable_avatar_url();
  ::std::string* release_avatar_url();
  void set_allocated_avatar_url(::std::string* avatar_url);

  // optional string lang = 6;
  void clear_lang();
  static const int kLangFieldNumber = 6;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional bytes metadata = 7;
  void clear_metadata();
  static const int kMetadataFieldNumber = 7;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // @@protoc_insertion_point(class_scope:server.TGroupUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr avatar_url_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  bool private__;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupUpdate> TGroupUpdate_default_instance_;

// -------------------------------------------------------------------

class TGroupRemove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupRemove) */ {
 public:
  TGroupRemove();
  virtual ~TGroupRemove();

  TGroupRemove(const TGroupRemove& from);

  inline TGroupRemove& operator=(const TGroupRemove& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupRemove& default_instance();

  static const TGroupRemove* internal_default_instance();

  void Swap(TGroupRemove* other);

  // implements Message ----------------------------------------------

  inline TGroupRemove* New() const { return New(NULL); }

  TGroupRemove* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupRemove& from);
  void MergeFrom(const TGroupRemove& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupRemove* other);
  void UnsafeMergeFrom(const TGroupRemove& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:server.TGroupRemove)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupRemove> TGroupRemove_default_instance_;

// -------------------------------------------------------------------

class TGroupsSelfList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupsSelfList) */ {
 public:
  TGroupsSelfList();
  virtual ~TGroupsSelfList();

  TGroupsSelfList(const TGroupsSelfList& from);

  inline TGroupsSelfList& operator=(const TGroupsSelfList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupsSelfList& default_instance();

  static const TGroupsSelfList* internal_default_instance();

  void Swap(TGroupsSelfList* other);

  // implements Message ----------------------------------------------

  inline TGroupsSelfList* New() const { return New(NULL); }

  TGroupsSelfList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupsSelfList& from);
  void MergeFrom(const TGroupsSelfList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupsSelfList* other);
  void UnsafeMergeFrom(const TGroupsSelfList& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:server.TGroupsSelfList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupsSelfList> TGroupsSelfList_default_instance_;

// -------------------------------------------------------------------

class TGroupsFetch_GroupIds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupsFetch.GroupIds) */ {
 public:
  TGroupsFetch_GroupIds();
  virtual ~TGroupsFetch_GroupIds();

  TGroupsFetch_GroupIds(const TGroupsFetch_GroupIds& from);

  inline TGroupsFetch_GroupIds& operator=(const TGroupsFetch_GroupIds& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupsFetch_GroupIds& default_instance();

  static const TGroupsFetch_GroupIds* internal_default_instance();

  void Swap(TGroupsFetch_GroupIds* other);

  // implements Message ----------------------------------------------

  inline TGroupsFetch_GroupIds* New() const { return New(NULL); }

  TGroupsFetch_GroupIds* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupsFetch_GroupIds& from);
  void MergeFrom(const TGroupsFetch_GroupIds& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupsFetch_GroupIds* other);
  void UnsafeMergeFrom(const TGroupsFetch_GroupIds& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes group_ids = 1;
  int group_ids_size() const;
  void clear_group_ids();
  static const int kGroupIdsFieldNumber = 1;
  const ::std::string& group_ids(int index) const;
  ::std::string* mutable_group_ids(int index);
  void set_group_ids(int index, const ::std::string& value);
  void set_group_ids(int index, const char* value);
  void set_group_ids(int index, const void* value, size_t size);
  ::std::string* add_group_ids();
  void add_group_ids(const ::std::string& value);
  void add_group_ids(const char* value);
  void add_group_ids(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& group_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_group_ids();

  // @@protoc_insertion_point(class_scope:server.TGroupsFetch.GroupIds)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> group_ids_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupsFetch_GroupIds> TGroupsFetch_GroupIds_default_instance_;

// -------------------------------------------------------------------

class TGroupsFetch_Names : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupsFetch.Names) */ {
 public:
  TGroupsFetch_Names();
  virtual ~TGroupsFetch_Names();

  TGroupsFetch_Names(const TGroupsFetch_Names& from);

  inline TGroupsFetch_Names& operator=(const TGroupsFetch_Names& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupsFetch_Names& default_instance();

  static const TGroupsFetch_Names* internal_default_instance();

  void Swap(TGroupsFetch_Names* other);

  // implements Message ----------------------------------------------

  inline TGroupsFetch_Names* New() const { return New(NULL); }

  TGroupsFetch_Names* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupsFetch_Names& from);
  void MergeFrom(const TGroupsFetch_Names& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupsFetch_Names* other);
  void UnsafeMergeFrom(const TGroupsFetch_Names& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 1;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // @@protoc_insertion_point(class_scope:server.TGroupsFetch.Names)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupsFetch_Names> TGroupsFetch_Names_default_instance_;

// -------------------------------------------------------------------

class TGroupsFetch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupsFetch) */ {
 public:
  TGroupsFetch();
  virtual ~TGroupsFetch();

  TGroupsFetch(const TGroupsFetch& from);

  inline TGroupsFetch& operator=(const TGroupsFetch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupsFetch& default_instance();

  enum SetCase {
    kGroupIds = 1,
    kNames = 2,
    SET_NOT_SET = 0,
  };

  static const TGroupsFetch* internal_default_instance();

  void Swap(TGroupsFetch* other);

  // implements Message ----------------------------------------------

  inline TGroupsFetch* New() const { return New(NULL); }

  TGroupsFetch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupsFetch& from);
  void MergeFrom(const TGroupsFetch& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupsFetch* other);
  void UnsafeMergeFrom(const TGroupsFetch& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TGroupsFetch_GroupIds GroupIds;
  typedef TGroupsFetch_Names Names;

  // accessors -------------------------------------------------------

  // optional .server.TGroupsFetch.GroupIds group_ids = 1;
  bool has_group_ids() const;
  void clear_group_ids();
  static const int kGroupIdsFieldNumber = 1;
  const ::server::TGroupsFetch_GroupIds& group_ids() const;
  ::server::TGroupsFetch_GroupIds* mutable_group_ids();
  ::server::TGroupsFetch_GroupIds* release_group_ids();
  void set_allocated_group_ids(::server::TGroupsFetch_GroupIds* group_ids);

  // optional .server.TGroupsFetch.Names names = 2;
  bool has_names() const;
  void clear_names();
  static const int kNamesFieldNumber = 2;
  const ::server::TGroupsFetch_Names& names() const;
  ::server::TGroupsFetch_Names* mutable_names();
  ::server::TGroupsFetch_Names* release_names();
  void set_allocated_names(::server::TGroupsFetch_Names* names);

  SetCase set_case() const;
  // @@protoc_insertion_point(class_scope:server.TGroupsFetch)
 private:
  inline void set_has_group_ids();
  inline void set_has_names();

  inline bool has_set() const;
  void clear_set();
  inline void clear_has_set();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union SetUnion {
    SetUnion() {}
    ::server::TGroupsFetch_GroupIds* group_ids_;
    ::server::TGroupsFetch_Names* names_;
  } set_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupsFetch> TGroupsFetch_default_instance_;

// -------------------------------------------------------------------

class TGroupsList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupsList) */ {
 public:
  TGroupsList();
  virtual ~TGroupsList();

  TGroupsList(const TGroupsList& from);

  inline TGroupsList& operator=(const TGroupsList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupsList& default_instance();

  enum FilterCase {
    kLang = 3,
    kCreatedAt = 4,
    kCount = 5,
    FILTER_NOT_SET = 0,
  };

  static const TGroupsList* internal_default_instance();

  void Swap(TGroupsList* other);

  // implements Message ----------------------------------------------

  inline TGroupsList* New() const { return New(NULL); }

  TGroupsList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupsList& from);
  void MergeFrom(const TGroupsList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupsList* other);
  void UnsafeMergeFrom(const TGroupsList& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 page_limit = 1;
  void clear_page_limit();
  static const int kPageLimitFieldNumber = 1;
  ::google::protobuf::int64 page_limit() const;
  void set_page_limit(::google::protobuf::int64 value);

  // optional bool order_by_asc = 2;
  void clear_order_by_asc();
  static const int kOrderByAscFieldNumber = 2;
  bool order_by_asc() const;
  void set_order_by_asc(bool value);

  // optional string lang = 3;
  private:
  bool has_lang() const;
  public:
  void clear_lang();
  static const int kLangFieldNumber = 3;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional int64 created_at = 4;
  private:
  bool has_created_at() const;
  public:
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 4;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // optional int64 count = 5;
  private:
  bool has_count() const;
  public:
  void clear_count();
  static const int kCountFieldNumber = 5;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // optional bytes cursor = 7;
  void clear_cursor();
  static const int kCursorFieldNumber = 7;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  void set_cursor(const char* value);
  void set_cursor(const void* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  FilterCase filter_case() const;
  // @@protoc_insertion_point(class_scope:server.TGroupsList)
 private:
  inline void set_has_lang();
  inline void set_has_created_at();
  inline void set_has_count();

  inline bool has_filter() const;
  void clear_filter();
  inline void clear_has_filter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::int64 page_limit_;
  bool order_by_asc_;
  union FilterUnion {
    FilterUnion() {}
    ::google::protobuf::internal::ArenaStringPtr lang_;
    ::google::protobuf::int64 created_at_;
    ::google::protobuf::int64 count_;
  } filter_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupsList> TGroupsList_default_instance_;

// -------------------------------------------------------------------

class TGroups : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroups) */ {
 public:
  TGroups();
  virtual ~TGroups();

  TGroups(const TGroups& from);

  inline TGroups& operator=(const TGroups& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroups& default_instance();

  static const TGroups* internal_default_instance();

  void Swap(TGroups* other);

  // implements Message ----------------------------------------------

  inline TGroups* New() const { return New(NULL); }

  TGroups* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroups& from);
  void MergeFrom(const TGroups& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroups* other);
  void UnsafeMergeFrom(const TGroups& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.Group groups = 1;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 1;
  const ::server::Group& groups(int index) const;
  ::server::Group* mutable_groups(int index);
  ::server::Group* add_groups();
  ::google::protobuf::RepeatedPtrField< ::server::Group >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::server::Group >&
      groups() const;

  // optional bytes cursor = 2;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  void set_cursor(const char* value);
  void set_cursor(const void* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // @@protoc_insertion_point(class_scope:server.TGroups)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::Group > groups_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroups> TGroups_default_instance_;

// -------------------------------------------------------------------

class GroupUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.GroupUser) */ {
 public:
  GroupUser();
  virtual ~GroupUser();

  GroupUser(const GroupUser& from);

  inline GroupUser& operator=(const GroupUser& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupUser& default_instance();

  static const GroupUser* internal_default_instance();

  void Swap(GroupUser* other);

  // implements Message ----------------------------------------------

  inline GroupUser* New() const { return New(NULL); }

  GroupUser* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupUser& from);
  void MergeFrom(const GroupUser& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupUser* other);
  void UnsafeMergeFrom(const GroupUser& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.User user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::server::User& user() const;
  ::server::User* mutable_user();
  ::server::User* release_user();
  void set_allocated_user(::server::User* user);

  // optional int64 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int64 type() const;
  void set_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:server.GroupUser)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::server::User* user_;
  ::google::protobuf::int64 type_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<GroupUser> GroupUser_default_instance_;

// -------------------------------------------------------------------

class TGroupUsersList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupUsersList) */ {
 public:
  TGroupUsersList();
  virtual ~TGroupUsersList();

  TGroupUsersList(const TGroupUsersList& from);

  inline TGroupUsersList& operator=(const TGroupUsersList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupUsersList& default_instance();

  static const TGroupUsersList* internal_default_instance();

  void Swap(TGroupUsersList* other);

  // implements Message ----------------------------------------------

  inline TGroupUsersList* New() const { return New(NULL); }

  TGroupUsersList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupUsersList& from);
  void MergeFrom(const TGroupUsersList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupUsersList* other);
  void UnsafeMergeFrom(const TGroupUsersList& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:server.TGroupUsersList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupUsersList> TGroupUsersList_default_instance_;

// -------------------------------------------------------------------

class TGroupUsers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupUsers) */ {
 public:
  TGroupUsers();
  virtual ~TGroupUsers();

  TGroupUsers(const TGroupUsers& from);

  inline TGroupUsers& operator=(const TGroupUsers& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupUsers& default_instance();

  static const TGroupUsers* internal_default_instance();

  void Swap(TGroupUsers* other);

  // implements Message ----------------------------------------------

  inline TGroupUsers* New() const { return New(NULL); }

  TGroupUsers* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupUsers& from);
  void MergeFrom(const TGroupUsers& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupUsers* other);
  void UnsafeMergeFrom(const TGroupUsers& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.GroupUser users = 1;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 1;
  const ::server::GroupUser& users(int index) const;
  ::server::GroupUser* mutable_users(int index);
  ::server::GroupUser* add_users();
  ::google::protobuf::RepeatedPtrField< ::server::GroupUser >*
      mutable_users();
  const ::google::protobuf::RepeatedPtrField< ::server::GroupUser >&
      users() const;

  // @@protoc_insertion_point(class_scope:server.TGroupUsers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::GroupUser > users_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupUsers> TGroupUsers_default_instance_;

// -------------------------------------------------------------------

class TGroupJoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupJoin) */ {
 public:
  TGroupJoin();
  virtual ~TGroupJoin();

  TGroupJoin(const TGroupJoin& from);

  inline TGroupJoin& operator=(const TGroupJoin& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupJoin& default_instance();

  static const TGroupJoin* internal_default_instance();

  void Swap(TGroupJoin* other);

  // implements Message ----------------------------------------------

  inline TGroupJoin* New() const { return New(NULL); }

  TGroupJoin* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupJoin& from);
  void MergeFrom(const TGroupJoin& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupJoin* other);
  void UnsafeMergeFrom(const TGroupJoin& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:server.TGroupJoin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupJoin> TGroupJoin_default_instance_;

// -------------------------------------------------------------------

class TGroupLeave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupLeave) */ {
 public:
  TGroupLeave();
  virtual ~TGroupLeave();

  TGroupLeave(const TGroupLeave& from);

  inline TGroupLeave& operator=(const TGroupLeave& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupLeave& default_instance();

  static const TGroupLeave* internal_default_instance();

  void Swap(TGroupLeave* other);

  // implements Message ----------------------------------------------

  inline TGroupLeave* New() const { return New(NULL); }

  TGroupLeave* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupLeave& from);
  void MergeFrom(const TGroupLeave& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupLeave* other);
  void UnsafeMergeFrom(const TGroupLeave& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:server.TGroupLeave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupLeave> TGroupLeave_default_instance_;

// -------------------------------------------------------------------

class TGroupUserAdd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupUserAdd) */ {
 public:
  TGroupUserAdd();
  virtual ~TGroupUserAdd();

  TGroupUserAdd(const TGroupUserAdd& from);

  inline TGroupUserAdd& operator=(const TGroupUserAdd& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupUserAdd& default_instance();

  static const TGroupUserAdd* internal_default_instance();

  void Swap(TGroupUserAdd* other);

  // implements Message ----------------------------------------------

  inline TGroupUserAdd* New() const { return New(NULL); }

  TGroupUserAdd* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupUserAdd& from);
  void MergeFrom(const TGroupUserAdd& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupUserAdd* other);
  void UnsafeMergeFrom(const TGroupUserAdd& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // optional bytes user_id = 2;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:server.TGroupUserAdd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupUserAdd> TGroupUserAdd_default_instance_;

// -------------------------------------------------------------------

class TGroupUserKick : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupUserKick) */ {
 public:
  TGroupUserKick();
  virtual ~TGroupUserKick();

  TGroupUserKick(const TGroupUserKick& from);

  inline TGroupUserKick& operator=(const TGroupUserKick& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupUserKick& default_instance();

  static const TGroupUserKick* internal_default_instance();

  void Swap(TGroupUserKick* other);

  // implements Message ----------------------------------------------

  inline TGroupUserKick* New() const { return New(NULL); }

  TGroupUserKick* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupUserKick& from);
  void MergeFrom(const TGroupUserKick& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupUserKick* other);
  void UnsafeMergeFrom(const TGroupUserKick& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // optional bytes user_id = 2;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:server.TGroupUserKick)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupUserKick> TGroupUserKick_default_instance_;

// -------------------------------------------------------------------

class TGroupUserPromote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TGroupUserPromote) */ {
 public:
  TGroupUserPromote();
  virtual ~TGroupUserPromote();

  TGroupUserPromote(const TGroupUserPromote& from);

  inline TGroupUserPromote& operator=(const TGroupUserPromote& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGroupUserPromote& default_instance();

  static const TGroupUserPromote* internal_default_instance();

  void Swap(TGroupUserPromote* other);

  // implements Message ----------------------------------------------

  inline TGroupUserPromote* New() const { return New(NULL); }

  TGroupUserPromote* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGroupUserPromote& from);
  void MergeFrom(const TGroupUserPromote& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TGroupUserPromote* other);
  void UnsafeMergeFrom(const TGroupUserPromote& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes group_id = 1;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // optional bytes user_id = 2;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:server.TGroupUserPromote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TGroupUserPromote> TGroupUserPromote_default_instance_;

// -------------------------------------------------------------------

class TopicId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TopicId) */ {
 public:
  TopicId();
  virtual ~TopicId();

  TopicId(const TopicId& from);

  inline TopicId& operator=(const TopicId& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicId& default_instance();

  enum IdCase {
    kDm = 1,
    kRoom = 2,
    kGroupId = 3,
    ID_NOT_SET = 0,
  };

  static const TopicId* internal_default_instance();

  void Swap(TopicId* other);

  // implements Message ----------------------------------------------

  inline TopicId* New() const { return New(NULL); }

  TopicId* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicId& from);
  void MergeFrom(const TopicId& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TopicId* other);
  void UnsafeMergeFrom(const TopicId& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes dm = 1;
  private:
  bool has_dm() const;
  public:
  void clear_dm();
  static const int kDmFieldNumber = 1;
  const ::std::string& dm() const;
  void set_dm(const ::std::string& value);
  void set_dm(const char* value);
  void set_dm(const void* value, size_t size);
  ::std::string* mutable_dm();
  ::std::string* release_dm();
  void set_allocated_dm(::std::string* dm);

  // optional bytes room = 2;
  private:
  bool has_room() const;
  public:
  void clear_room();
  static const int kRoomFieldNumber = 2;
  const ::std::string& room() const;
  void set_room(const ::std::string& value);
  void set_room(const char* value);
  void set_room(const void* value, size_t size);
  ::std::string* mutable_room();
  ::std::string* release_room();
  void set_allocated_room(::std::string* room);

  // optional bytes group_id = 3;
  private:
  bool has_group_id() const;
  public:
  void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:server.TopicId)
 private:
  inline void set_has_dm();
  inline void set_has_room();
  inline void set_has_group_id();

  inline bool has_id() const;
  void clear_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr dm_;
    ::google::protobuf::internal::ArenaStringPtr room_;
    ::google::protobuf::internal::ArenaStringPtr group_id_;
  } id_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TopicId> TopicId_default_instance_;

// -------------------------------------------------------------------

class UserPresence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.UserPresence) */ {
 public:
  UserPresence();
  virtual ~UserPresence();

  UserPresence(const UserPresence& from);

  inline UserPresence& operator=(const UserPresence& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPresence& default_instance();

  static const UserPresence* internal_default_instance();

  void Swap(UserPresence* other);

  // implements Message ----------------------------------------------

  inline UserPresence* New() const { return New(NULL); }

  UserPresence* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserPresence& from);
  void MergeFrom(const UserPresence& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserPresence* other);
  void UnsafeMergeFrom(const UserPresence& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional bytes session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  void set_session_id(const char* value);
  void set_session_id(const void* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional string handle = 3;
  void clear_handle();
  static const int kHandleFieldNumber = 3;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // @@protoc_insertion_point(class_scope:server.UserPresence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<UserPresence> UserPresence_default_instance_;

// -------------------------------------------------------------------

class TTopicJoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TTopicJoin) */ {
 public:
  TTopicJoin();
  virtual ~TTopicJoin();

  TTopicJoin(const TTopicJoin& from);

  inline TTopicJoin& operator=(const TTopicJoin& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTopicJoin& default_instance();

  enum IdCase {
    kUserId = 1,
    kRoom = 2,
    kGroupId = 3,
    ID_NOT_SET = 0,
  };

  static const TTopicJoin* internal_default_instance();

  void Swap(TTopicJoin* other);

  // implements Message ----------------------------------------------

  inline TTopicJoin* New() const { return New(NULL); }

  TTopicJoin* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTopicJoin& from);
  void MergeFrom(const TTopicJoin& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TTopicJoin* other);
  void UnsafeMergeFrom(const TTopicJoin& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_id = 1;
  private:
  bool has_user_id() const;
  public:
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional bytes room = 2;
  private:
  bool has_room() const;
  public:
  void clear_room();
  static const int kRoomFieldNumber = 2;
  const ::std::string& room() const;
  void set_room(const ::std::string& value);
  void set_room(const char* value);
  void set_room(const void* value, size_t size);
  ::std::string* mutable_room();
  ::std::string* release_room();
  void set_allocated_room(::std::string* room);

  // optional bytes group_id = 3;
  private:
  bool has_group_id() const;
  public:
  void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:server.TTopicJoin)
 private:
  inline void set_has_user_id();
  inline void set_has_room();
  inline void set_has_group_id();

  inline bool has_id() const;
  void clear_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr room_;
    ::google::protobuf::internal::ArenaStringPtr group_id_;
  } id_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TTopicJoin> TTopicJoin_default_instance_;

// -------------------------------------------------------------------

class TTopic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TTopic) */ {
 public:
  TTopic();
  virtual ~TTopic();

  TTopic(const TTopic& from);

  inline TTopic& operator=(const TTopic& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTopic& default_instance();

  static const TTopic* internal_default_instance();

  void Swap(TTopic* other);

  // implements Message ----------------------------------------------

  inline TTopic* New() const { return New(NULL); }

  TTopic* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTopic& from);
  void MergeFrom(const TTopic& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TTopic* other);
  void UnsafeMergeFrom(const TTopic& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.TopicId topic = 1;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::server::TopicId& topic() const;
  ::server::TopicId* mutable_topic();
  ::server::TopicId* release_topic();
  void set_allocated_topic(::server::TopicId* topic);

  // repeated .server.UserPresence presences = 2;
  int presences_size() const;
  void clear_presences();
  static const int kPresencesFieldNumber = 2;
  const ::server::UserPresence& presences(int index) const;
  ::server::UserPresence* mutable_presences(int index);
  ::server::UserPresence* add_presences();
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
      mutable_presences();
  const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
      presences() const;

  // optional .server.UserPresence self = 3;
  bool has_self() const;
  void clear_self();
  static const int kSelfFieldNumber = 3;
  const ::server::UserPresence& self() const;
  ::server::UserPresence* mutable_self();
  ::server::UserPresence* release_self();
  void set_allocated_self(::server::UserPresence* self);

  // @@protoc_insertion_point(class_scope:server.TTopic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence > presences_;
  ::server::TopicId* topic_;
  ::server::UserPresence* self_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TTopic> TTopic_default_instance_;

// -------------------------------------------------------------------

class TTopicLeave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TTopicLeave) */ {
 public:
  TTopicLeave();
  virtual ~TTopicLeave();

  TTopicLeave(const TTopicLeave& from);

  inline TTopicLeave& operator=(const TTopicLeave& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTopicLeave& default_instance();

  static const TTopicLeave* internal_default_instance();

  void Swap(TTopicLeave* other);

  // implements Message ----------------------------------------------

  inline TTopicLeave* New() const { return New(NULL); }

  TTopicLeave* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTopicLeave& from);
  void MergeFrom(const TTopicLeave& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TTopicLeave* other);
  void UnsafeMergeFrom(const TTopicLeave& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.TopicId topic = 1;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::server::TopicId& topic() const;
  ::server::TopicId* mutable_topic();
  ::server::TopicId* release_topic();
  void set_allocated_topic(::server::TopicId* topic);

  // @@protoc_insertion_point(class_scope:server.TTopicLeave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::server::TopicId* topic_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TTopicLeave> TTopicLeave_default_instance_;

// -------------------------------------------------------------------

class TTopicMessageSend : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TTopicMessageSend) */ {
 public:
  TTopicMessageSend();
  virtual ~TTopicMessageSend();

  TTopicMessageSend(const TTopicMessageSend& from);

  inline TTopicMessageSend& operator=(const TTopicMessageSend& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTopicMessageSend& default_instance();

  static const TTopicMessageSend* internal_default_instance();

  void Swap(TTopicMessageSend* other);

  // implements Message ----------------------------------------------

  inline TTopicMessageSend* New() const { return New(NULL); }

  TTopicMessageSend* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTopicMessageSend& from);
  void MergeFrom(const TTopicMessageSend& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TTopicMessageSend* other);
  void UnsafeMergeFrom(const TTopicMessageSend& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.TopicId topic = 1;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::server::TopicId& topic() const;
  ::server::TopicId* mutable_topic();
  ::server::TopicId* release_topic();
  void set_allocated_topic(::server::TopicId* topic);

  // optional bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:server.TTopicMessageSend)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::server::TopicId* topic_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TTopicMessageSend> TTopicMessageSend_default_instance_;

// -------------------------------------------------------------------

class TTopicMessageAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TTopicMessageAck) */ {
 public:
  TTopicMessageAck();
  virtual ~TTopicMessageAck();

  TTopicMessageAck(const TTopicMessageAck& from);

  inline TTopicMessageAck& operator=(const TTopicMessageAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTopicMessageAck& default_instance();

  static const TTopicMessageAck* internal_default_instance();

  void Swap(TTopicMessageAck* other);

  // implements Message ----------------------------------------------

  inline TTopicMessageAck* New() const { return New(NULL); }

  TTopicMessageAck* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTopicMessageAck& from);
  void MergeFrom(const TTopicMessageAck& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TTopicMessageAck* other);
  void UnsafeMergeFrom(const TTopicMessageAck& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message_id = 1;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  void set_message_id(const char* value);
  void set_message_id(const void* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // optional int64 created_at = 2;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 2;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // optional int64 expires_at = 3;
  void clear_expires_at();
  static const int kExpiresAtFieldNumber = 3;
  ::google::protobuf::int64 expires_at() const;
  void set_expires_at(::google::protobuf::int64 value);

  // optional string handle = 4;
  void clear_handle();
  static const int kHandleFieldNumber = 4;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // @@protoc_insertion_point(class_scope:server.TTopicMessageAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::google::protobuf::int64 created_at_;
  ::google::protobuf::int64 expires_at_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TTopicMessageAck> TTopicMessageAck_default_instance_;

// -------------------------------------------------------------------

class TopicMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TopicMessage) */ {
 public:
  TopicMessage();
  virtual ~TopicMessage();

  TopicMessage(const TopicMessage& from);

  inline TopicMessage& operator=(const TopicMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicMessage& default_instance();

  static const TopicMessage* internal_default_instance();

  void Swap(TopicMessage* other);

  // implements Message ----------------------------------------------

  inline TopicMessage* New() const { return New(NULL); }

  TopicMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicMessage& from);
  void MergeFrom(const TopicMessage& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TopicMessage* other);
  void UnsafeMergeFrom(const TopicMessage& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.TopicId topic = 1;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::server::TopicId& topic() const;
  ::server::TopicId* mutable_topic();
  ::server::TopicId* release_topic();
  void set_allocated_topic(::server::TopicId* topic);

  // optional bytes user_id = 2;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional bytes message_id = 3;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  void set_message_id(const char* value);
  void set_message_id(const void* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // optional int64 created_at = 4;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 4;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // optional int64 expires_at = 5;
  void clear_expires_at();
  static const int kExpiresAtFieldNumber = 5;
  ::google::protobuf::int64 expires_at() const;
  void set_expires_at(::google::protobuf::int64 value);

  // optional string handle = 6;
  void clear_handle();
  static const int kHandleFieldNumber = 6;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // optional int64 type = 7;
  void clear_type();
  static const int kTypeFieldNumber = 7;
  ::google::protobuf::int64 type() const;
  void set_type(::google::protobuf::int64 value);

  // optional bytes data = 8;
  void clear_data();
  static const int kDataFieldNumber = 8;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:server.TopicMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::server::TopicId* topic_;
  ::google::protobuf::int64 created_at_;
  ::google::protobuf::int64 expires_at_;
  ::google::protobuf::int64 type_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TopicMessage> TopicMessage_default_instance_;

// -------------------------------------------------------------------

class TTopicMessagesList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TTopicMessagesList) */ {
 public:
  TTopicMessagesList();
  virtual ~TTopicMessagesList();

  TTopicMessagesList(const TTopicMessagesList& from);

  inline TTopicMessagesList& operator=(const TTopicMessagesList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTopicMessagesList& default_instance();

  enum IdCase {
    kUserId = 1,
    kRoom = 2,
    kGroupId = 3,
    ID_NOT_SET = 0,
  };

  static const TTopicMessagesList* internal_default_instance();

  void Swap(TTopicMessagesList* other);

  // implements Message ----------------------------------------------

  inline TTopicMessagesList* New() const { return New(NULL); }

  TTopicMessagesList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTopicMessagesList& from);
  void MergeFrom(const TTopicMessagesList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TTopicMessagesList* other);
  void UnsafeMergeFrom(const TTopicMessagesList& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_id = 1;
  private:
  bool has_user_id() const;
  public:
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional bytes room = 2;
  private:
  bool has_room() const;
  public:
  void clear_room();
  static const int kRoomFieldNumber = 2;
  const ::std::string& room() const;
  void set_room(const ::std::string& value);
  void set_room(const char* value);
  void set_room(const void* value, size_t size);
  ::std::string* mutable_room();
  ::std::string* release_room();
  void set_allocated_room(::std::string* room);

  // optional bytes group_id = 3;
  private:
  bool has_group_id() const;
  public:
  void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // optional bytes cursor = 4;
  void clear_cursor();
  static const int kCursorFieldNumber = 4;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  void set_cursor(const char* value);
  void set_cursor(const void* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // optional bool forward = 5;
  void clear_forward();
  static const int kForwardFieldNumber = 5;
  bool forward() const;
  void set_forward(bool value);

  // optional int64 limit = 6;
  void clear_limit();
  static const int kLimitFieldNumber = 6;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:server.TTopicMessagesList)
 private:
  inline void set_has_user_id();
  inline void set_has_room();
  inline void set_has_group_id();

  inline bool has_id() const;
  void clear_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::int64 limit_;
  bool forward_;
  union IdUnion {
    IdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr room_;
    ::google::protobuf::internal::ArenaStringPtr group_id_;
  } id_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TTopicMessagesList> TTopicMessagesList_default_instance_;

// -------------------------------------------------------------------

class TTopicMessages : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TTopicMessages) */ {
 public:
  TTopicMessages();
  virtual ~TTopicMessages();

  TTopicMessages(const TTopicMessages& from);

  inline TTopicMessages& operator=(const TTopicMessages& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTopicMessages& default_instance();

  static const TTopicMessages* internal_default_instance();

  void Swap(TTopicMessages* other);

  // implements Message ----------------------------------------------

  inline TTopicMessages* New() const { return New(NULL); }

  TTopicMessages* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTopicMessages& from);
  void MergeFrom(const TTopicMessages& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TTopicMessages* other);
  void UnsafeMergeFrom(const TTopicMessages& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.TopicMessage messages = 1;
  int messages_size() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 1;
  const ::server::TopicMessage& messages(int index) const;
  ::server::TopicMessage* mutable_messages(int index);
  ::server::TopicMessage* add_messages();
  ::google::protobuf::RepeatedPtrField< ::server::TopicMessage >*
      mutable_messages();
  const ::google::protobuf::RepeatedPtrField< ::server::TopicMessage >&
      messages() const;

  // optional bytes cursor = 2;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  void set_cursor(const char* value);
  void set_cursor(const void* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // @@protoc_insertion_point(class_scope:server.TTopicMessages)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::TopicMessage > messages_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TTopicMessages> TTopicMessages_default_instance_;

// -------------------------------------------------------------------

class TopicPresence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TopicPresence) */ {
 public:
  TopicPresence();
  virtual ~TopicPresence();

  TopicPresence(const TopicPresence& from);

  inline TopicPresence& operator=(const TopicPresence& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicPresence& default_instance();

  static const TopicPresence* internal_default_instance();

  void Swap(TopicPresence* other);

  // implements Message ----------------------------------------------

  inline TopicPresence* New() const { return New(NULL); }

  TopicPresence* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicPresence& from);
  void MergeFrom(const TopicPresence& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TopicPresence* other);
  void UnsafeMergeFrom(const TopicPresence& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.TopicId topic = 1;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::server::TopicId& topic() const;
  ::server::TopicId* mutable_topic();
  ::server::TopicId* release_topic();
  void set_allocated_topic(::server::TopicId* topic);

  // repeated .server.UserPresence joins = 2;
  int joins_size() const;
  void clear_joins();
  static const int kJoinsFieldNumber = 2;
  const ::server::UserPresence& joins(int index) const;
  ::server::UserPresence* mutable_joins(int index);
  ::server::UserPresence* add_joins();
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
      mutable_joins();
  const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
      joins() const;

  // repeated .server.UserPresence leaves = 3;
  int leaves_size() const;
  void clear_leaves();
  static const int kLeavesFieldNumber = 3;
  const ::server::UserPresence& leaves(int index) const;
  ::server::UserPresence* mutable_leaves(int index);
  ::server::UserPresence* add_leaves();
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
      mutable_leaves();
  const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
      leaves() const;

  // @@protoc_insertion_point(class_scope:server.TopicPresence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence > joins_;
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence > leaves_;
  ::server::TopicId* topic_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TopicPresence> TopicPresence_default_instance_;

// -------------------------------------------------------------------

class TMatchmakeAdd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TMatchmakeAdd) */ {
 public:
  TMatchmakeAdd();
  virtual ~TMatchmakeAdd();

  TMatchmakeAdd(const TMatchmakeAdd& from);

  inline TMatchmakeAdd& operator=(const TMatchmakeAdd& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMatchmakeAdd& default_instance();

  static const TMatchmakeAdd* internal_default_instance();

  void Swap(TMatchmakeAdd* other);

  // implements Message ----------------------------------------------

  inline TMatchmakeAdd* New() const { return New(NULL); }

  TMatchmakeAdd* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMatchmakeAdd& from);
  void MergeFrom(const TMatchmakeAdd& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TMatchmakeAdd* other);
  void UnsafeMergeFrom(const TMatchmakeAdd& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 requiredCount = 1;
  void clear_requiredcount();
  static const int kRequiredCountFieldNumber = 1;
  ::google::protobuf::int64 requiredcount() const;
  void set_requiredcount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:server.TMatchmakeAdd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 requiredcount_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TMatchmakeAdd> TMatchmakeAdd_default_instance_;

// -------------------------------------------------------------------

class TMatchmakeTicket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TMatchmakeTicket) */ {
 public:
  TMatchmakeTicket();
  virtual ~TMatchmakeTicket();

  TMatchmakeTicket(const TMatchmakeTicket& from);

  inline TMatchmakeTicket& operator=(const TMatchmakeTicket& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMatchmakeTicket& default_instance();

  static const TMatchmakeTicket* internal_default_instance();

  void Swap(TMatchmakeTicket* other);

  // implements Message ----------------------------------------------

  inline TMatchmakeTicket* New() const { return New(NULL); }

  TMatchmakeTicket* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMatchmakeTicket& from);
  void MergeFrom(const TMatchmakeTicket& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TMatchmakeTicket* other);
  void UnsafeMergeFrom(const TMatchmakeTicket& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ticket = 1;
  void clear_ticket();
  static const int kTicketFieldNumber = 1;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  void set_ticket(const char* value);
  void set_ticket(const void* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // @@protoc_insertion_point(class_scope:server.TMatchmakeTicket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TMatchmakeTicket> TMatchmakeTicket_default_instance_;

// -------------------------------------------------------------------

class TMatchmakeRemove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TMatchmakeRemove) */ {
 public:
  TMatchmakeRemove();
  virtual ~TMatchmakeRemove();

  TMatchmakeRemove(const TMatchmakeRemove& from);

  inline TMatchmakeRemove& operator=(const TMatchmakeRemove& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMatchmakeRemove& default_instance();

  static const TMatchmakeRemove* internal_default_instance();

  void Swap(TMatchmakeRemove* other);

  // implements Message ----------------------------------------------

  inline TMatchmakeRemove* New() const { return New(NULL); }

  TMatchmakeRemove* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMatchmakeRemove& from);
  void MergeFrom(const TMatchmakeRemove& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TMatchmakeRemove* other);
  void UnsafeMergeFrom(const TMatchmakeRemove& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ticket = 1;
  void clear_ticket();
  static const int kTicketFieldNumber = 1;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  void set_ticket(const char* value);
  void set_ticket(const void* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // @@protoc_insertion_point(class_scope:server.TMatchmakeRemove)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TMatchmakeRemove> TMatchmakeRemove_default_instance_;

// -------------------------------------------------------------------

class MatchmakeMatched : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.MatchmakeMatched) */ {
 public:
  MatchmakeMatched();
  virtual ~MatchmakeMatched();

  MatchmakeMatched(const MatchmakeMatched& from);

  inline MatchmakeMatched& operator=(const MatchmakeMatched& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakeMatched& default_instance();

  static const MatchmakeMatched* internal_default_instance();

  void Swap(MatchmakeMatched* other);

  // implements Message ----------------------------------------------

  inline MatchmakeMatched* New() const { return New(NULL); }

  MatchmakeMatched* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchmakeMatched& from);
  void MergeFrom(const MatchmakeMatched& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MatchmakeMatched* other);
  void UnsafeMergeFrom(const MatchmakeMatched& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ticket = 1;
  void clear_ticket();
  static const int kTicketFieldNumber = 1;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  void set_ticket(const char* value);
  void set_ticket(const void* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // optional bytes token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // repeated .server.UserPresence presences = 3;
  int presences_size() const;
  void clear_presences();
  static const int kPresencesFieldNumber = 3;
  const ::server::UserPresence& presences(int index) const;
  ::server::UserPresence* mutable_presences(int index);
  ::server::UserPresence* add_presences();
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
      mutable_presences();
  const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
      presences() const;

  // optional .server.UserPresence self = 4;
  bool has_self() const;
  void clear_self();
  static const int kSelfFieldNumber = 4;
  const ::server::UserPresence& self() const;
  ::server::UserPresence* mutable_self();
  ::server::UserPresence* release_self();
  void set_allocated_self(::server::UserPresence* self);

  // @@protoc_insertion_point(class_scope:server.MatchmakeMatched)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence > presences_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::server::UserPresence* self_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MatchmakeMatched> MatchmakeMatched_default_instance_;

// -------------------------------------------------------------------

class TMatchCreate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TMatchCreate) */ {
 public:
  TMatchCreate();
  virtual ~TMatchCreate();

  TMatchCreate(const TMatchCreate& from);

  inline TMatchCreate& operator=(const TMatchCreate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMatchCreate& default_instance();

  static const TMatchCreate* internal_default_instance();

  void Swap(TMatchCreate* other);

  // implements Message ----------------------------------------------

  inline TMatchCreate* New() const { return New(NULL); }

  TMatchCreate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMatchCreate& from);
  void MergeFrom(const TMatchCreate& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TMatchCreate* other);
  void UnsafeMergeFrom(const TMatchCreate& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:server.TMatchCreate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TMatchCreate> TMatchCreate_default_instance_;

// -------------------------------------------------------------------

class TMatchJoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TMatchJoin) */ {
 public:
  TMatchJoin();
  virtual ~TMatchJoin();

  TMatchJoin(const TMatchJoin& from);

  inline TMatchJoin& operator=(const TMatchJoin& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMatchJoin& default_instance();

  enum IdCase {
    kMatchId = 1,
    kToken = 2,
    ID_NOT_SET = 0,
  };

  static const TMatchJoin* internal_default_instance();

  void Swap(TMatchJoin* other);

  // implements Message ----------------------------------------------

  inline TMatchJoin* New() const { return New(NULL); }

  TMatchJoin* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMatchJoin& from);
  void MergeFrom(const TMatchJoin& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TMatchJoin* other);
  void UnsafeMergeFrom(const TMatchJoin& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes match_id = 1;
  private:
  bool has_match_id() const;
  public:
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  void set_match_id(const char* value);
  void set_match_id(const void* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // optional bytes token = 2;
  private:
  bool has_token() const;
  public:
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:server.TMatchJoin)
 private:
  inline void set_has_match_id();
  inline void set_has_token();

  inline bool has_id() const;
  void clear_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr match_id_;
    ::google::protobuf::internal::ArenaStringPtr token_;
  } id_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TMatchJoin> TMatchJoin_default_instance_;

// -------------------------------------------------------------------

class TMatch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TMatch) */ {
 public:
  TMatch();
  virtual ~TMatch();

  TMatch(const TMatch& from);

  inline TMatch& operator=(const TMatch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMatch& default_instance();

  static const TMatch* internal_default_instance();

  void Swap(TMatch* other);

  // implements Message ----------------------------------------------

  inline TMatch* New() const { return New(NULL); }

  TMatch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMatch& from);
  void MergeFrom(const TMatch& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TMatch* other);
  void UnsafeMergeFrom(const TMatch& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  void set_match_id(const char* value);
  void set_match_id(const void* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // repeated .server.UserPresence presences = 2;
  int presences_size() const;
  void clear_presences();
  static const int kPresencesFieldNumber = 2;
  const ::server::UserPresence& presences(int index) const;
  ::server::UserPresence* mutable_presences(int index);
  ::server::UserPresence* add_presences();
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
      mutable_presences();
  const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
      presences() const;

  // optional .server.UserPresence self = 3;
  bool has_self() const;
  void clear_self();
  static const int kSelfFieldNumber = 3;
  const ::server::UserPresence& self() const;
  ::server::UserPresence* mutable_self();
  ::server::UserPresence* release_self();
  void set_allocated_self(::server::UserPresence* self);

  // @@protoc_insertion_point(class_scope:server.TMatch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence > presences_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  ::server::UserPresence* self_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TMatch> TMatch_default_instance_;

// -------------------------------------------------------------------

class MatchDataSend : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.MatchDataSend) */ {
 public:
  MatchDataSend();
  virtual ~MatchDataSend();

  MatchDataSend(const MatchDataSend& from);

  inline MatchDataSend& operator=(const MatchDataSend& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchDataSend& default_instance();

  static const MatchDataSend* internal_default_instance();

  void Swap(MatchDataSend* other);

  // implements Message ----------------------------------------------

  inline MatchDataSend* New() const { return New(NULL); }

  MatchDataSend* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchDataSend& from);
  void MergeFrom(const MatchDataSend& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MatchDataSend* other);
  void UnsafeMergeFrom(const MatchDataSend& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  void set_match_id(const char* value);
  void set_match_id(const void* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // optional int64 op_code = 2;
  void clear_op_code();
  static const int kOpCodeFieldNumber = 2;
  ::google::protobuf::int64 op_code() const;
  void set_op_code(::google::protobuf::int64 value);

  // optional bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // repeated .server.UserPresence presences = 4;
  int presences_size() const;
  void clear_presences();
  static const int kPresencesFieldNumber = 4;
  const ::server::UserPresence& presences(int index) const;
  ::server::UserPresence* mutable_presences(int index);
  ::server::UserPresence* add_presences();
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
      mutable_presences();
  const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
      presences() const;

  // @@protoc_insertion_point(class_scope:server.MatchDataSend)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence > presences_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 op_code_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MatchDataSend> MatchDataSend_default_instance_;

// -------------------------------------------------------------------

class MatchData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.MatchData) */ {
 public:
  MatchData();
  virtual ~MatchData();

  MatchData(const MatchData& from);

  inline MatchData& operator=(const MatchData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchData& default_instance();

  static const MatchData* internal_default_instance();

  void Swap(MatchData* other);

  // implements Message ----------------------------------------------

  inline MatchData* New() const { return New(NULL); }

  MatchData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchData& from);
  void MergeFrom(const MatchData& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MatchData* other);
  void UnsafeMergeFrom(const MatchData& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  void set_match_id(const char* value);
  void set_match_id(const void* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // optional .server.UserPresence presence = 2;
  bool has_presence() const;
  void clear_presence();
  static const int kPresenceFieldNumber = 2;
  const ::server::UserPresence& presence() const;
  ::server::UserPresence* mutable_presence();
  ::server::UserPresence* release_presence();
  void set_allocated_presence(::server::UserPresence* presence);

  // optional int64 op_code = 3;
  void clear_op_code();
  static const int kOpCodeFieldNumber = 3;
  ::google::protobuf::int64 op_code() const;
  void set_op_code(::google::protobuf::int64 value);

  // optional bytes data = 4;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:server.MatchData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::server::UserPresence* presence_;
  ::google::protobuf::int64 op_code_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MatchData> MatchData_default_instance_;

// -------------------------------------------------------------------

class TMatchLeave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TMatchLeave) */ {
 public:
  TMatchLeave();
  virtual ~TMatchLeave();

  TMatchLeave(const TMatchLeave& from);

  inline TMatchLeave& operator=(const TMatchLeave& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMatchLeave& default_instance();

  static const TMatchLeave* internal_default_instance();

  void Swap(TMatchLeave* other);

  // implements Message ----------------------------------------------

  inline TMatchLeave* New() const { return New(NULL); }

  TMatchLeave* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMatchLeave& from);
  void MergeFrom(const TMatchLeave& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TMatchLeave* other);
  void UnsafeMergeFrom(const TMatchLeave& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  void set_match_id(const char* value);
  void set_match_id(const void* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // @@protoc_insertion_point(class_scope:server.TMatchLeave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TMatchLeave> TMatchLeave_default_instance_;

// -------------------------------------------------------------------

class MatchPresence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.MatchPresence) */ {
 public:
  MatchPresence();
  virtual ~MatchPresence();

  MatchPresence(const MatchPresence& from);

  inline MatchPresence& operator=(const MatchPresence& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchPresence& default_instance();

  static const MatchPresence* internal_default_instance();

  void Swap(MatchPresence* other);

  // implements Message ----------------------------------------------

  inline MatchPresence* New() const { return New(NULL); }

  MatchPresence* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchPresence& from);
  void MergeFrom(const MatchPresence& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MatchPresence* other);
  void UnsafeMergeFrom(const MatchPresence& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes match_id = 1;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  const ::std::string& match_id() const;
  void set_match_id(const ::std::string& value);
  void set_match_id(const char* value);
  void set_match_id(const void* value, size_t size);
  ::std::string* mutable_match_id();
  ::std::string* release_match_id();
  void set_allocated_match_id(::std::string* match_id);

  // repeated .server.UserPresence joins = 2;
  int joins_size() const;
  void clear_joins();
  static const int kJoinsFieldNumber = 2;
  const ::server::UserPresence& joins(int index) const;
  ::server::UserPresence* mutable_joins(int index);
  ::server::UserPresence* add_joins();
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
      mutable_joins();
  const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
      joins() const;

  // repeated .server.UserPresence leaves = 3;
  int leaves_size() const;
  void clear_leaves();
  static const int kLeavesFieldNumber = 3;
  const ::server::UserPresence& leaves(int index) const;
  ::server::UserPresence* mutable_leaves(int index);
  ::server::UserPresence* add_leaves();
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
      mutable_leaves();
  const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
      leaves() const;

  // @@protoc_insertion_point(class_scope:server.MatchPresence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence > joins_;
  ::google::protobuf::RepeatedPtrField< ::server::UserPresence > leaves_;
  ::google::protobuf::internal::ArenaStringPtr match_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MatchPresence> MatchPresence_default_instance_;

// -------------------------------------------------------------------

class TStorageFetch_StorageKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageFetch.StorageKey) */ {
 public:
  TStorageFetch_StorageKey();
  virtual ~TStorageFetch_StorageKey();

  TStorageFetch_StorageKey(const TStorageFetch_StorageKey& from);

  inline TStorageFetch_StorageKey& operator=(const TStorageFetch_StorageKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageFetch_StorageKey& default_instance();

  static const TStorageFetch_StorageKey* internal_default_instance();

  void Swap(TStorageFetch_StorageKey* other);

  // implements Message ----------------------------------------------

  inline TStorageFetch_StorageKey* New() const { return New(NULL); }

  TStorageFetch_StorageKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageFetch_StorageKey& from);
  void MergeFrom(const TStorageFetch_StorageKey& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageFetch_StorageKey* other);
  void UnsafeMergeFrom(const TStorageFetch_StorageKey& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // optional string collection = 2;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // optional string record = 3;
  void clear_record();
  static const int kRecordFieldNumber = 3;
  const ::std::string& record() const;
  void set_record(const ::std::string& value);
  void set_record(const char* value);
  void set_record(const char* value, size_t size);
  ::std::string* mutable_record();
  ::std::string* release_record();
  void set_allocated_record(::std::string* record);

  // optional bytes user_id = 4;
  void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:server.TStorageFetch.StorageKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr record_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageFetch_StorageKey> TStorageFetch_StorageKey_default_instance_;

// -------------------------------------------------------------------

class TStorageFetch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageFetch) */ {
 public:
  TStorageFetch();
  virtual ~TStorageFetch();

  TStorageFetch(const TStorageFetch& from);

  inline TStorageFetch& operator=(const TStorageFetch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageFetch& default_instance();

  static const TStorageFetch* internal_default_instance();

  void Swap(TStorageFetch* other);

  // implements Message ----------------------------------------------

  inline TStorageFetch* New() const { return New(NULL); }

  TStorageFetch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageFetch& from);
  void MergeFrom(const TStorageFetch& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageFetch* other);
  void UnsafeMergeFrom(const TStorageFetch& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TStorageFetch_StorageKey StorageKey;

  // accessors -------------------------------------------------------

  // repeated .server.TStorageFetch.StorageKey keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::server::TStorageFetch_StorageKey& keys(int index) const;
  ::server::TStorageFetch_StorageKey* mutable_keys(int index);
  ::server::TStorageFetch_StorageKey* add_keys();
  ::google::protobuf::RepeatedPtrField< ::server::TStorageFetch_StorageKey >*
      mutable_keys();
  const ::google::protobuf::RepeatedPtrField< ::server::TStorageFetch_StorageKey >&
      keys() const;

  // @@protoc_insertion_point(class_scope:server.TStorageFetch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::TStorageFetch_StorageKey > keys_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageFetch> TStorageFetch_default_instance_;

// -------------------------------------------------------------------

class TStorageData_StorageData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageData.StorageData) */ {
 public:
  TStorageData_StorageData();
  virtual ~TStorageData_StorageData();

  TStorageData_StorageData(const TStorageData_StorageData& from);

  inline TStorageData_StorageData& operator=(const TStorageData_StorageData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageData_StorageData& default_instance();

  static const TStorageData_StorageData* internal_default_instance();

  void Swap(TStorageData_StorageData* other);

  // implements Message ----------------------------------------------

  inline TStorageData_StorageData* New() const { return New(NULL); }

  TStorageData_StorageData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageData_StorageData& from);
  void MergeFrom(const TStorageData_StorageData& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageData_StorageData* other);
  void UnsafeMergeFrom(const TStorageData_StorageData& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // optional string collection = 2;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // optional string record = 3;
  void clear_record();
  static const int kRecordFieldNumber = 3;
  const ::std::string& record() const;
  void set_record(const ::std::string& value);
  void set_record(const char* value);
  void set_record(const char* value, size_t size);
  ::std::string* mutable_record();
  ::std::string* release_record();
  void set_allocated_record(::std::string* record);

  // optional bytes user_id = 4;
  void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const void* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional bytes value = 5;
  void clear_value();
  static const int kValueFieldNumber = 5;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes version = 6;
  void clear_version();
  static const int kVersionFieldNumber = 6;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional int32 permission_read = 7;
  void clear_permission_read();
  static const int kPermissionReadFieldNumber = 7;
  ::google::protobuf::int32 permission_read() const;
  void set_permission_read(::google::protobuf::int32 value);

  // optional int32 permission_write = 8;
  void clear_permission_write();
  static const int kPermissionWriteFieldNumber = 8;
  ::google::protobuf::int32 permission_write() const;
  void set_permission_write(::google::protobuf::int32 value);

  // optional int64 created_at = 9;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 9;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // optional int64 updated_at = 10;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 10;
  ::google::protobuf::int64 updated_at() const;
  void set_updated_at(::google::protobuf::int64 value);

  // optional int64 expires_at = 11;
  void clear_expires_at();
  static const int kExpiresAtFieldNumber = 11;
  ::google::protobuf::int64 expires_at() const;
  void set_expires_at(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:server.TStorageData.StorageData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr record_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::int32 permission_read_;
  ::google::protobuf::int32 permission_write_;
  ::google::protobuf::int64 created_at_;
  ::google::protobuf::int64 updated_at_;
  ::google::protobuf::int64 expires_at_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageData_StorageData> TStorageData_StorageData_default_instance_;

// -------------------------------------------------------------------

class TStorageData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageData) */ {
 public:
  TStorageData();
  virtual ~TStorageData();

  TStorageData(const TStorageData& from);

  inline TStorageData& operator=(const TStorageData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageData& default_instance();

  static const TStorageData* internal_default_instance();

  void Swap(TStorageData* other);

  // implements Message ----------------------------------------------

  inline TStorageData* New() const { return New(NULL); }

  TStorageData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageData& from);
  void MergeFrom(const TStorageData& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageData* other);
  void UnsafeMergeFrom(const TStorageData& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TStorageData_StorageData StorageData;

  // accessors -------------------------------------------------------

  // repeated .server.TStorageData.StorageData data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::server::TStorageData_StorageData& data(int index) const;
  ::server::TStorageData_StorageData* mutable_data(int index);
  ::server::TStorageData_StorageData* add_data();
  ::google::protobuf::RepeatedPtrField< ::server::TStorageData_StorageData >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::server::TStorageData_StorageData >&
      data() const;

  // @@protoc_insertion_point(class_scope:server.TStorageData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::TStorageData_StorageData > data_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageData> TStorageData_default_instance_;

// -------------------------------------------------------------------

class TStorageWrite_StorageData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageWrite.StorageData) */ {
 public:
  TStorageWrite_StorageData();
  virtual ~TStorageWrite_StorageData();

  TStorageWrite_StorageData(const TStorageWrite_StorageData& from);

  inline TStorageWrite_StorageData& operator=(const TStorageWrite_StorageData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageWrite_StorageData& default_instance();

  static const TStorageWrite_StorageData* internal_default_instance();

  void Swap(TStorageWrite_StorageData* other);

  // implements Message ----------------------------------------------

  inline TStorageWrite_StorageData* New() const { return New(NULL); }

  TStorageWrite_StorageData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageWrite_StorageData& from);
  void MergeFrom(const TStorageWrite_StorageData& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageWrite_StorageData* other);
  void UnsafeMergeFrom(const TStorageWrite_StorageData& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // optional string collection = 2;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // optional string record = 3;
  void clear_record();
  static const int kRecordFieldNumber = 3;
  const ::std::string& record() const;
  void set_record(const ::std::string& value);
  void set_record(const char* value);
  void set_record(const char* value, size_t size);
  ::std::string* mutable_record();
  ::std::string* release_record();
  void set_allocated_record(::std::string* record);

  // optional bytes value = 4;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes version = 5;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional int32 permission_read = 6;
  void clear_permission_read();
  static const int kPermissionReadFieldNumber = 6;
  ::google::protobuf::int32 permission_read() const;
  void set_permission_read(::google::protobuf::int32 value);

  // optional int32 permission_write = 7;
  void clear_permission_write();
  static const int kPermissionWriteFieldNumber = 7;
  ::google::protobuf::int32 permission_write() const;
  void set_permission_write(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:server.TStorageWrite.StorageData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr record_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::int32 permission_read_;
  ::google::protobuf::int32 permission_write_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageWrite_StorageData> TStorageWrite_StorageData_default_instance_;

// -------------------------------------------------------------------

class TStorageWrite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageWrite) */ {
 public:
  TStorageWrite();
  virtual ~TStorageWrite();

  TStorageWrite(const TStorageWrite& from);

  inline TStorageWrite& operator=(const TStorageWrite& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageWrite& default_instance();

  static const TStorageWrite* internal_default_instance();

  void Swap(TStorageWrite* other);

  // implements Message ----------------------------------------------

  inline TStorageWrite* New() const { return New(NULL); }

  TStorageWrite* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageWrite& from);
  void MergeFrom(const TStorageWrite& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageWrite* other);
  void UnsafeMergeFrom(const TStorageWrite& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TStorageWrite_StorageData StorageData;

  // accessors -------------------------------------------------------

  // repeated .server.TStorageWrite.StorageData data = 3;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::server::TStorageWrite_StorageData& data(int index) const;
  ::server::TStorageWrite_StorageData* mutable_data(int index);
  ::server::TStorageWrite_StorageData* add_data();
  ::google::protobuf::RepeatedPtrField< ::server::TStorageWrite_StorageData >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::server::TStorageWrite_StorageData >&
      data() const;

  // @@protoc_insertion_point(class_scope:server.TStorageWrite)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::TStorageWrite_StorageData > data_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageWrite> TStorageWrite_default_instance_;

// -------------------------------------------------------------------

class TStorageKey_StorageKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageKey.StorageKey) */ {
 public:
  TStorageKey_StorageKey();
  virtual ~TStorageKey_StorageKey();

  TStorageKey_StorageKey(const TStorageKey_StorageKey& from);

  inline TStorageKey_StorageKey& operator=(const TStorageKey_StorageKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageKey_StorageKey& default_instance();

  static const TStorageKey_StorageKey* internal_default_instance();

  void Swap(TStorageKey_StorageKey* other);

  // implements Message ----------------------------------------------

  inline TStorageKey_StorageKey* New() const { return New(NULL); }

  TStorageKey_StorageKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageKey_StorageKey& from);
  void MergeFrom(const TStorageKey_StorageKey& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageKey_StorageKey* other);
  void UnsafeMergeFrom(const TStorageKey_StorageKey& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // optional string collection = 2;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // optional string record = 3;
  void clear_record();
  static const int kRecordFieldNumber = 3;
  const ::std::string& record() const;
  void set_record(const ::std::string& value);
  void set_record(const char* value);
  void set_record(const char* value, size_t size);
  ::std::string* mutable_record();
  ::std::string* release_record();
  void set_allocated_record(::std::string* record);

  // optional bytes version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:server.TStorageKey.StorageKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr record_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageKey_StorageKey> TStorageKey_StorageKey_default_instance_;

// -------------------------------------------------------------------

class TStorageKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageKey) */ {
 public:
  TStorageKey();
  virtual ~TStorageKey();

  TStorageKey(const TStorageKey& from);

  inline TStorageKey& operator=(const TStorageKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageKey& default_instance();

  static const TStorageKey* internal_default_instance();

  void Swap(TStorageKey* other);

  // implements Message ----------------------------------------------

  inline TStorageKey* New() const { return New(NULL); }

  TStorageKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageKey& from);
  void MergeFrom(const TStorageKey& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageKey* other);
  void UnsafeMergeFrom(const TStorageKey& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TStorageKey_StorageKey StorageKey;

  // accessors -------------------------------------------------------

  // repeated .server.TStorageKey.StorageKey keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::server::TStorageKey_StorageKey& keys(int index) const;
  ::server::TStorageKey_StorageKey* mutable_keys(int index);
  ::server::TStorageKey_StorageKey* add_keys();
  ::google::protobuf::RepeatedPtrField< ::server::TStorageKey_StorageKey >*
      mutable_keys();
  const ::google::protobuf::RepeatedPtrField< ::server::TStorageKey_StorageKey >&
      keys() const;

  // @@protoc_insertion_point(class_scope:server.TStorageKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::TStorageKey_StorageKey > keys_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageKey> TStorageKey_default_instance_;

// -------------------------------------------------------------------

class TStorageRemove_StorageKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageRemove.StorageKey) */ {
 public:
  TStorageRemove_StorageKey();
  virtual ~TStorageRemove_StorageKey();

  TStorageRemove_StorageKey(const TStorageRemove_StorageKey& from);

  inline TStorageRemove_StorageKey& operator=(const TStorageRemove_StorageKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageRemove_StorageKey& default_instance();

  static const TStorageRemove_StorageKey* internal_default_instance();

  void Swap(TStorageRemove_StorageKey* other);

  // implements Message ----------------------------------------------

  inline TStorageRemove_StorageKey* New() const { return New(NULL); }

  TStorageRemove_StorageKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageRemove_StorageKey& from);
  void MergeFrom(const TStorageRemove_StorageKey& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageRemove_StorageKey* other);
  void UnsafeMergeFrom(const TStorageRemove_StorageKey& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // optional string collection = 2;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // optional string record = 3;
  void clear_record();
  static const int kRecordFieldNumber = 3;
  const ::std::string& record() const;
  void set_record(const ::std::string& value);
  void set_record(const char* value);
  void set_record(const char* value, size_t size);
  ::std::string* mutable_record();
  ::std::string* release_record();
  void set_allocated_record(::std::string* record);

  // optional bytes version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:server.TStorageRemove.StorageKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::google::protobuf::internal::ArenaStringPtr record_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageRemove_StorageKey> TStorageRemove_StorageKey_default_instance_;

// -------------------------------------------------------------------

class TStorageRemove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TStorageRemove) */ {
 public:
  TStorageRemove();
  virtual ~TStorageRemove();

  TStorageRemove(const TStorageRemove& from);

  inline TStorageRemove& operator=(const TStorageRemove& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStorageRemove& default_instance();

  static const TStorageRemove* internal_default_instance();

  void Swap(TStorageRemove* other);

  // implements Message ----------------------------------------------

  inline TStorageRemove* New() const { return New(NULL); }

  TStorageRemove* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStorageRemove& from);
  void MergeFrom(const TStorageRemove& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStorageRemove* other);
  void UnsafeMergeFrom(const TStorageRemove& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TStorageRemove_StorageKey StorageKey;

  // accessors -------------------------------------------------------

  // repeated .server.TStorageRemove.StorageKey keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::server::TStorageRemove_StorageKey& keys(int index) const;
  ::server::TStorageRemove_StorageKey* mutable_keys(int index);
  ::server::TStorageRemove_StorageKey* add_keys();
  ::google::protobuf::RepeatedPtrField< ::server::TStorageRemove_StorageKey >*
      mutable_keys();
  const ::google::protobuf::RepeatedPtrField< ::server::TStorageRemove_StorageKey >&
      keys() const;

  // @@protoc_insertion_point(class_scope:server.TStorageRemove)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::TStorageRemove_StorageKey > keys_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TStorageRemove> TStorageRemove_default_instance_;

// -------------------------------------------------------------------

class Leaderboard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.Leaderboard) */ {
 public:
  Leaderboard();
  virtual ~Leaderboard();

  Leaderboard(const Leaderboard& from);

  inline Leaderboard& operator=(const Leaderboard& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Leaderboard& default_instance();

  static const Leaderboard* internal_default_instance();

  void Swap(Leaderboard* other);

  // implements Message ----------------------------------------------

  inline Leaderboard* New() const { return New(NULL); }

  Leaderboard* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Leaderboard& from);
  void MergeFrom(const Leaderboard& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Leaderboard* other);
  void UnsafeMergeFrom(const Leaderboard& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional bool authoritative = 2;
  void clear_authoritative();
  static const int kAuthoritativeFieldNumber = 2;
  bool authoritative() const;
  void set_authoritative(bool value);

  // optional int64 sort = 3;
  void clear_sort();
  static const int kSortFieldNumber = 3;
  ::google::protobuf::int64 sort() const;
  void set_sort(::google::protobuf::int64 value);

  // optional int64 count = 4;
  void clear_count();
  static const int kCountFieldNumber = 4;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // optional string reset_schedule = 5;
  void clear_reset_schedule();
  static const int kResetScheduleFieldNumber = 5;
  const ::std::string& reset_schedule() const;
  void set_reset_schedule(const ::std::string& value);
  void set_reset_schedule(const char* value);
  void set_reset_schedule(const char* value, size_t size);
  ::std::string* mutable_reset_schedule();
  ::std::string* release_reset_schedule();
  void set_allocated_reset_schedule(::std::string* reset_schedule);

  // optional bytes metadata = 6;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // optional bytes next_id = 7;
  void clear_next_id();
  static const int kNextIdFieldNumber = 7;
  const ::std::string& next_id() const;
  void set_next_id(const ::std::string& value);
  void set_next_id(const char* value);
  void set_next_id(const void* value, size_t size);
  ::std::string* mutable_next_id();
  ::std::string* release_next_id();
  void set_allocated_next_id(::std::string* next_id);

  // optional bytes prev_id = 8;
  void clear_prev_id();
  static const int kPrevIdFieldNumber = 8;
  const ::std::string& prev_id() const;
  void set_prev_id(const ::std::string& value);
  void set_prev_id(const char* value);
  void set_prev_id(const void* value, size_t size);
  ::std::string* mutable_prev_id();
  ::std::string* release_prev_id();
  void set_allocated_prev_id(::std::string* prev_id);

  // @@protoc_insertion_point(class_scope:server.Leaderboard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr reset_schedule_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::internal::ArenaStringPtr next_id_;
  ::google::protobuf::internal::ArenaStringPtr prev_id_;
  ::google::protobuf::int64 sort_;
  ::google::protobuf::int64 count_;
  bool authoritative_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Leaderboard> Leaderboard_default_instance_;

// -------------------------------------------------------------------

class LeaderboardRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.LeaderboardRecord) */ {
 public:
  LeaderboardRecord();
  virtual ~LeaderboardRecord();

  LeaderboardRecord(const LeaderboardRecord& from);

  inline LeaderboardRecord& operator=(const LeaderboardRecord& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderboardRecord& default_instance();

  static const LeaderboardRecord* internal_default_instance();

  void Swap(LeaderboardRecord* other);

  // implements Message ----------------------------------------------

  inline LeaderboardRecord* New() const { return New(NULL); }

  LeaderboardRecord* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderboardRecord& from);
  void MergeFrom(const LeaderboardRecord& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaderboardRecord* other);
  void UnsafeMergeFrom(const LeaderboardRecord& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes leaderboard_id = 1;
  void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 1;
  const ::std::string& leaderboard_id() const;
  void set_leaderboard_id(const ::std::string& value);
  void set_leaderboard_id(const char* value);
  void set_leaderboard_id(const void* value, size_t size);
  ::std::string* mutable_leaderboard_id();
  ::std::string* release_leaderboard_id();
  void set_allocated_leaderboard_id(::std::string* leaderboard_id);

  // optional bytes owner_id = 2;
  void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  const ::std::string& owner_id() const;
  void set_owner_id(const ::std::string& value);
  void set_owner_id(const char* value);
  void set_owner_id(const void* value, size_t size);
  ::std::string* mutable_owner_id();
  ::std::string* release_owner_id();
  void set_allocated_owner_id(::std::string* owner_id);

  // optional string handle = 3;
  void clear_handle();
  static const int kHandleFieldNumber = 3;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // optional string lang = 4;
  void clear_lang();
  static const int kLangFieldNumber = 4;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional string location = 5;
  void clear_location();
  static const int kLocationFieldNumber = 5;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // optional string timezone = 6;
  void clear_timezone();
  static const int kTimezoneFieldNumber = 6;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional int64 rank = 7;
  void clear_rank();
  static const int kRankFieldNumber = 7;
  ::google::protobuf::int64 rank() const;
  void set_rank(::google::protobuf::int64 value);

  // optional int64 score = 8;
  void clear_score();
  static const int kScoreFieldNumber = 8;
  ::google::protobuf::int64 score() const;
  void set_score(::google::protobuf::int64 value);

  // optional int64 num_score = 9;
  void clear_num_score();
  static const int kNumScoreFieldNumber = 9;
  ::google::protobuf::int64 num_score() const;
  void set_num_score(::google::protobuf::int64 value);

  // optional bytes metadata = 10;
  void clear_metadata();
  static const int kMetadataFieldNumber = 10;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // optional int64 ranked_at = 11;
  void clear_ranked_at();
  static const int kRankedAtFieldNumber = 11;
  ::google::protobuf::int64 ranked_at() const;
  void set_ranked_at(::google::protobuf::int64 value);

  // optional int64 updated_at = 12;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 12;
  ::google::protobuf::int64 updated_at() const;
  void set_updated_at(::google::protobuf::int64 value);

  // optional int64 expires_at = 13;
  void clear_expires_at();
  static const int kExpiresAtFieldNumber = 13;
  ::google::protobuf::int64 expires_at() const;
  void set_expires_at(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:server.LeaderboardRecord)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr leaderboard_id_;
  ::google::protobuf::internal::ArenaStringPtr owner_id_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::int64 rank_;
  ::google::protobuf::int64 score_;
  ::google::protobuf::int64 num_score_;
  ::google::protobuf::int64 ranked_at_;
  ::google::protobuf::int64 updated_at_;
  ::google::protobuf::int64 expires_at_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LeaderboardRecord> LeaderboardRecord_default_instance_;

// -------------------------------------------------------------------

class TLeaderboardsList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TLeaderboardsList) */ {
 public:
  TLeaderboardsList();
  virtual ~TLeaderboardsList();

  TLeaderboardsList(const TLeaderboardsList& from);

  inline TLeaderboardsList& operator=(const TLeaderboardsList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLeaderboardsList& default_instance();

  static const TLeaderboardsList* internal_default_instance();

  void Swap(TLeaderboardsList* other);

  // implements Message ----------------------------------------------

  inline TLeaderboardsList* New() const { return New(NULL); }

  TLeaderboardsList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLeaderboardsList& from);
  void MergeFrom(const TLeaderboardsList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLeaderboardsList* other);
  void UnsafeMergeFrom(const TLeaderboardsList& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 limit = 1;
  void clear_limit();
  static const int kLimitFieldNumber = 1;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // optional bytes cursor = 2;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  void set_cursor(const char* value);
  void set_cursor(const void* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // repeated bytes filter_leaderboard_id = 3;
  int filter_leaderboard_id_size() const;
  void clear_filter_leaderboard_id();
  static const int kFilterLeaderboardIdFieldNumber = 3;
  const ::std::string& filter_leaderboard_id(int index) const;
  ::std::string* mutable_filter_leaderboard_id(int index);
  void set_filter_leaderboard_id(int index, const ::std::string& value);
  void set_filter_leaderboard_id(int index, const char* value);
  void set_filter_leaderboard_id(int index, const void* value, size_t size);
  ::std::string* add_filter_leaderboard_id();
  void add_filter_leaderboard_id(const ::std::string& value);
  void add_filter_leaderboard_id(const char* value);
  void add_filter_leaderboard_id(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_leaderboard_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_leaderboard_id();

  // @@protoc_insertion_point(class_scope:server.TLeaderboardsList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_leaderboard_id_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::int64 limit_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TLeaderboardsList> TLeaderboardsList_default_instance_;

// -------------------------------------------------------------------

class TLeaderboards : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TLeaderboards) */ {
 public:
  TLeaderboards();
  virtual ~TLeaderboards();

  TLeaderboards(const TLeaderboards& from);

  inline TLeaderboards& operator=(const TLeaderboards& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLeaderboards& default_instance();

  static const TLeaderboards* internal_default_instance();

  void Swap(TLeaderboards* other);

  // implements Message ----------------------------------------------

  inline TLeaderboards* New() const { return New(NULL); }

  TLeaderboards* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLeaderboards& from);
  void MergeFrom(const TLeaderboards& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLeaderboards* other);
  void UnsafeMergeFrom(const TLeaderboards& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.Leaderboard leaderboards = 1;
  int leaderboards_size() const;
  void clear_leaderboards();
  static const int kLeaderboardsFieldNumber = 1;
  const ::server::Leaderboard& leaderboards(int index) const;
  ::server::Leaderboard* mutable_leaderboards(int index);
  ::server::Leaderboard* add_leaderboards();
  ::google::protobuf::RepeatedPtrField< ::server::Leaderboard >*
      mutable_leaderboards();
  const ::google::protobuf::RepeatedPtrField< ::server::Leaderboard >&
      leaderboards() const;

  // optional bytes cursor = 2;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  void set_cursor(const char* value);
  void set_cursor(const void* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // @@protoc_insertion_point(class_scope:server.TLeaderboards)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::Leaderboard > leaderboards_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TLeaderboards> TLeaderboards_default_instance_;

// -------------------------------------------------------------------

class TLeaderboardRecordWrite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TLeaderboardRecordWrite) */ {
 public:
  TLeaderboardRecordWrite();
  virtual ~TLeaderboardRecordWrite();

  TLeaderboardRecordWrite(const TLeaderboardRecordWrite& from);

  inline TLeaderboardRecordWrite& operator=(const TLeaderboardRecordWrite& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLeaderboardRecordWrite& default_instance();

  enum OpCase {
    kIncr = 2,
    kDecr = 3,
    kSet = 4,
    kBest = 5,
    OP_NOT_SET = 0,
  };

  static const TLeaderboardRecordWrite* internal_default_instance();

  void Swap(TLeaderboardRecordWrite* other);

  // implements Message ----------------------------------------------

  inline TLeaderboardRecordWrite* New() const { return New(NULL); }

  TLeaderboardRecordWrite* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLeaderboardRecordWrite& from);
  void MergeFrom(const TLeaderboardRecordWrite& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLeaderboardRecordWrite* other);
  void UnsafeMergeFrom(const TLeaderboardRecordWrite& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes leaderboard_id = 1;
  void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 1;
  const ::std::string& leaderboard_id() const;
  void set_leaderboard_id(const ::std::string& value);
  void set_leaderboard_id(const char* value);
  void set_leaderboard_id(const void* value, size_t size);
  ::std::string* mutable_leaderboard_id();
  ::std::string* release_leaderboard_id();
  void set_allocated_leaderboard_id(::std::string* leaderboard_id);

  // optional int64 incr = 2;
  private:
  bool has_incr() const;
  public:
  void clear_incr();
  static const int kIncrFieldNumber = 2;
  ::google::protobuf::int64 incr() const;
  void set_incr(::google::protobuf::int64 value);

  // optional int64 decr = 3;
  private:
  bool has_decr() const;
  public:
  void clear_decr();
  static const int kDecrFieldNumber = 3;
  ::google::protobuf::int64 decr() const;
  void set_decr(::google::protobuf::int64 value);

  // optional int64 set = 4;
  private:
  bool has_set() const;
  public:
  void clear_set();
  static const int kSetFieldNumber = 4;
  ::google::protobuf::int64 set() const;
  void set_set(::google::protobuf::int64 value);

  // optional int64 best = 5;
  private:
  bool has_best() const;
  public:
  void clear_best();
  static const int kBestFieldNumber = 5;
  ::google::protobuf::int64 best() const;
  void set_best(::google::protobuf::int64 value);

  // optional string location = 6;
  void clear_location();
  static const int kLocationFieldNumber = 6;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // optional string timezone = 7;
  void clear_timezone();
  static const int kTimezoneFieldNumber = 7;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional bytes metadata = 8;
  void clear_metadata();
  static const int kMetadataFieldNumber = 8;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  OpCase op_case() const;
  // @@protoc_insertion_point(class_scope:server.TLeaderboardRecordWrite)
 private:
  inline void set_has_incr();
  inline void set_has_decr();
  inline void set_has_set();
  inline void set_has_best();

  inline bool has_op() const;
  void clear_op();
  inline void clear_has_op();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr leaderboard_id_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  union OpUnion {
    OpUnion() {}
    ::google::protobuf::int64 incr_;
    ::google::protobuf::int64 decr_;
    ::google::protobuf::int64 set_;
    ::google::protobuf::int64 best_;
  } op_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TLeaderboardRecordWrite> TLeaderboardRecordWrite_default_instance_;

// -------------------------------------------------------------------

class TLeaderboardRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TLeaderboardRecord) */ {
 public:
  TLeaderboardRecord();
  virtual ~TLeaderboardRecord();

  TLeaderboardRecord(const TLeaderboardRecord& from);

  inline TLeaderboardRecord& operator=(const TLeaderboardRecord& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLeaderboardRecord& default_instance();

  static const TLeaderboardRecord* internal_default_instance();

  void Swap(TLeaderboardRecord* other);

  // implements Message ----------------------------------------------

  inline TLeaderboardRecord* New() const { return New(NULL); }

  TLeaderboardRecord* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLeaderboardRecord& from);
  void MergeFrom(const TLeaderboardRecord& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLeaderboardRecord* other);
  void UnsafeMergeFrom(const TLeaderboardRecord& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.LeaderboardRecord record = 1;
  bool has_record() const;
  void clear_record();
  static const int kRecordFieldNumber = 1;
  const ::server::LeaderboardRecord& record() const;
  ::server::LeaderboardRecord* mutable_record();
  ::server::LeaderboardRecord* release_record();
  void set_allocated_record(::server::LeaderboardRecord* record);

  // @@protoc_insertion_point(class_scope:server.TLeaderboardRecord)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::server::LeaderboardRecord* record_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TLeaderboardRecord> TLeaderboardRecord_default_instance_;

// -------------------------------------------------------------------

class TLeaderboardRecordsFetch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TLeaderboardRecordsFetch) */ {
 public:
  TLeaderboardRecordsFetch();
  virtual ~TLeaderboardRecordsFetch();

  TLeaderboardRecordsFetch(const TLeaderboardRecordsFetch& from);

  inline TLeaderboardRecordsFetch& operator=(const TLeaderboardRecordsFetch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLeaderboardRecordsFetch& default_instance();

  static const TLeaderboardRecordsFetch* internal_default_instance();

  void Swap(TLeaderboardRecordsFetch* other);

  // implements Message ----------------------------------------------

  inline TLeaderboardRecordsFetch* New() const { return New(NULL); }

  TLeaderboardRecordsFetch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLeaderboardRecordsFetch& from);
  void MergeFrom(const TLeaderboardRecordsFetch& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLeaderboardRecordsFetch* other);
  void UnsafeMergeFrom(const TLeaderboardRecordsFetch& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes leaderboard_ids = 1;
  int leaderboard_ids_size() const;
  void clear_leaderboard_ids();
  static const int kLeaderboardIdsFieldNumber = 1;
  const ::std::string& leaderboard_ids(int index) const;
  ::std::string* mutable_leaderboard_ids(int index);
  void set_leaderboard_ids(int index, const ::std::string& value);
  void set_leaderboard_ids(int index, const char* value);
  void set_leaderboard_ids(int index, const void* value, size_t size);
  ::std::string* add_leaderboard_ids();
  void add_leaderboard_ids(const ::std::string& value);
  void add_leaderboard_ids(const char* value);
  void add_leaderboard_ids(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& leaderboard_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_leaderboard_ids();

  // optional int64 limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // optional bytes cursor = 3;
  void clear_cursor();
  static const int kCursorFieldNumber = 3;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  void set_cursor(const char* value);
  void set_cursor(const void* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // @@protoc_insertion_point(class_scope:server.TLeaderboardRecordsFetch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> leaderboard_ids_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::int64 limit_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TLeaderboardRecordsFetch> TLeaderboardRecordsFetch_default_instance_;

// -------------------------------------------------------------------

class TLeaderboardRecordsList_Owners : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TLeaderboardRecordsList.Owners) */ {
 public:
  TLeaderboardRecordsList_Owners();
  virtual ~TLeaderboardRecordsList_Owners();

  TLeaderboardRecordsList_Owners(const TLeaderboardRecordsList_Owners& from);

  inline TLeaderboardRecordsList_Owners& operator=(const TLeaderboardRecordsList_Owners& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLeaderboardRecordsList_Owners& default_instance();

  static const TLeaderboardRecordsList_Owners* internal_default_instance();

  void Swap(TLeaderboardRecordsList_Owners* other);

  // implements Message ----------------------------------------------

  inline TLeaderboardRecordsList_Owners* New() const { return New(NULL); }

  TLeaderboardRecordsList_Owners* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLeaderboardRecordsList_Owners& from);
  void MergeFrom(const TLeaderboardRecordsList_Owners& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLeaderboardRecordsList_Owners* other);
  void UnsafeMergeFrom(const TLeaderboardRecordsList_Owners& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes owner_ids = 1;
  int owner_ids_size() const;
  void clear_owner_ids();
  static const int kOwnerIdsFieldNumber = 1;
  const ::std::string& owner_ids(int index) const;
  ::std::string* mutable_owner_ids(int index);
  void set_owner_ids(int index, const ::std::string& value);
  void set_owner_ids(int index, const char* value);
  void set_owner_ids(int index, const void* value, size_t size);
  ::std::string* add_owner_ids();
  void add_owner_ids(const ::std::string& value);
  void add_owner_ids(const char* value);
  void add_owner_ids(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& owner_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_owner_ids();

  // @@protoc_insertion_point(class_scope:server.TLeaderboardRecordsList.Owners)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> owner_ids_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TLeaderboardRecordsList_Owners> TLeaderboardRecordsList_Owners_default_instance_;

// -------------------------------------------------------------------

class TLeaderboardRecordsList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TLeaderboardRecordsList) */ {
 public:
  TLeaderboardRecordsList();
  virtual ~TLeaderboardRecordsList();

  TLeaderboardRecordsList(const TLeaderboardRecordsList& from);

  inline TLeaderboardRecordsList& operator=(const TLeaderboardRecordsList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLeaderboardRecordsList& default_instance();

  enum FilterCase {
    kOwnerId = 2,
    kOwnerIds = 3,
    kLang = 4,
    kLocation = 5,
    kTimezone = 6,
    FILTER_NOT_SET = 0,
  };

  static const TLeaderboardRecordsList* internal_default_instance();

  void Swap(TLeaderboardRecordsList* other);

  // implements Message ----------------------------------------------

  inline TLeaderboardRecordsList* New() const { return New(NULL); }

  TLeaderboardRecordsList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLeaderboardRecordsList& from);
  void MergeFrom(const TLeaderboardRecordsList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLeaderboardRecordsList* other);
  void UnsafeMergeFrom(const TLeaderboardRecordsList& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TLeaderboardRecordsList_Owners Owners;

  // accessors -------------------------------------------------------

  // optional bytes leaderboard_id = 1;
  void clear_leaderboard_id();
  static const int kLeaderboardIdFieldNumber = 1;
  const ::std::string& leaderboard_id() const;
  void set_leaderboard_id(const ::std::string& value);
  void set_leaderboard_id(const char* value);
  void set_leaderboard_id(const void* value, size_t size);
  ::std::string* mutable_leaderboard_id();
  ::std::string* release_leaderboard_id();
  void set_allocated_leaderboard_id(::std::string* leaderboard_id);

  // optional bytes owner_id = 2;
  private:
  bool has_owner_id() const;
  public:
  void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  const ::std::string& owner_id() const;
  void set_owner_id(const ::std::string& value);
  void set_owner_id(const char* value);
  void set_owner_id(const void* value, size_t size);
  ::std::string* mutable_owner_id();
  ::std::string* release_owner_id();
  void set_allocated_owner_id(::std::string* owner_id);

  // optional .server.TLeaderboardRecordsList.Owners owner_ids = 3;
  bool has_owner_ids() const;
  void clear_owner_ids();
  static const int kOwnerIdsFieldNumber = 3;
  const ::server::TLeaderboardRecordsList_Owners& owner_ids() const;
  ::server::TLeaderboardRecordsList_Owners* mutable_owner_ids();
  ::server::TLeaderboardRecordsList_Owners* release_owner_ids();
  void set_allocated_owner_ids(::server::TLeaderboardRecordsList_Owners* owner_ids);

  // optional string lang = 4;
  private:
  bool has_lang() const;
  public:
  void clear_lang();
  static const int kLangFieldNumber = 4;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional string location = 5;
  private:
  bool has_location() const;
  public:
  void clear_location();
  static const int kLocationFieldNumber = 5;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // optional string timezone = 6;
  private:
  bool has_timezone() const;
  public:
  void clear_timezone();
  static const int kTimezoneFieldNumber = 6;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional int64 limit = 7;
  void clear_limit();
  static const int kLimitFieldNumber = 7;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // optional bytes cursor = 8;
  void clear_cursor();
  static const int kCursorFieldNumber = 8;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  void set_cursor(const char* value);
  void set_cursor(const void* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  FilterCase filter_case() const;
  // @@protoc_insertion_point(class_scope:server.TLeaderboardRecordsList)
 private:
  inline void set_has_owner_id();
  inline void set_has_owner_ids();
  inline void set_has_lang();
  inline void set_has_location();
  inline void set_has_timezone();

  inline bool has_filter() const;
  void clear_filter();
  inline void clear_has_filter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr leaderboard_id_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  ::google::protobuf::int64 limit_;
  union FilterUnion {
    FilterUnion() {}
    ::google::protobuf::internal::ArenaStringPtr owner_id_;
    ::server::TLeaderboardRecordsList_Owners* owner_ids_;
    ::google::protobuf::internal::ArenaStringPtr lang_;
    ::google::protobuf::internal::ArenaStringPtr location_;
    ::google::protobuf::internal::ArenaStringPtr timezone_;
  } filter_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TLeaderboardRecordsList> TLeaderboardRecordsList_default_instance_;

// -------------------------------------------------------------------

class TLeaderboardRecords : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TLeaderboardRecords) */ {
 public:
  TLeaderboardRecords();
  virtual ~TLeaderboardRecords();

  TLeaderboardRecords(const TLeaderboardRecords& from);

  inline TLeaderboardRecords& operator=(const TLeaderboardRecords& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLeaderboardRecords& default_instance();

  static const TLeaderboardRecords* internal_default_instance();

  void Swap(TLeaderboardRecords* other);

  // implements Message ----------------------------------------------

  inline TLeaderboardRecords* New() const { return New(NULL); }

  TLeaderboardRecords* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLeaderboardRecords& from);
  void MergeFrom(const TLeaderboardRecords& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLeaderboardRecords* other);
  void UnsafeMergeFrom(const TLeaderboardRecords& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.LeaderboardRecord records = 1;
  int records_size() const;
  void clear_records();
  static const int kRecordsFieldNumber = 1;
  const ::server::LeaderboardRecord& records(int index) const;
  ::server::LeaderboardRecord* mutable_records(int index);
  ::server::LeaderboardRecord* add_records();
  ::google::protobuf::RepeatedPtrField< ::server::LeaderboardRecord >*
      mutable_records();
  const ::google::protobuf::RepeatedPtrField< ::server::LeaderboardRecord >&
      records() const;

  // optional bytes cursor = 2;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::std::string& cursor() const;
  void set_cursor(const ::std::string& value);
  void set_cursor(const char* value);
  void set_cursor(const void* value, size_t size);
  ::std::string* mutable_cursor();
  ::std::string* release_cursor();
  void set_allocated_cursor(::std::string* cursor);

  // @@protoc_insertion_point(class_scope:server.TLeaderboardRecords)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::server::LeaderboardRecord > records_;
  ::google::protobuf::internal::ArenaStringPtr cursor_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TLeaderboardRecords> TLeaderboardRecords_default_instance_;

// -------------------------------------------------------------------

class TRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server.TRpc) */ {
 public:
  TRpc();
  virtual ~TRpc();

  TRpc(const TRpc& from);

  inline TRpc& operator=(const TRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TRpc& default_instance();

  static const TRpc* internal_default_instance();

  void Swap(TRpc* other);

  // implements Message ----------------------------------------------

  inline TRpc* New() const { return New(NULL); }

  TRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TRpc& from);
  void MergeFrom(const TRpc& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TRpc* other);
  void UnsafeMergeFrom(const TRpc& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional bytes payload = 2;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:server.TRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_api_2eproto_impl();
  friend void  protobuf_AddDesc_api_2eproto_impl();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TRpc> TRpc_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Heartbeat

// optional int64 timestamp = 1;
inline void Heartbeat::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Heartbeat::timestamp() const {
  // @@protoc_insertion_point(field_get:server.Heartbeat.timestamp)
  return timestamp_;
}
inline void Heartbeat::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:server.Heartbeat.timestamp)
}

inline const Heartbeat* Heartbeat::internal_default_instance() {
  return &Heartbeat_default_instance_.get();
}
// -------------------------------------------------------------------

// Error

// optional int32 code = 1;
inline void Error::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 Error::code() const {
  // @@protoc_insertion_point(field_get:server.Error.code)
  return code_;
}
inline void Error::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:server.Error.code)
}

// optional string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:server.Error.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Error.message)
}
inline void Error::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:server.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:server.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:server.Error.message)
}

inline const Error* Error::internal_default_instance() {
  return &Error_default_instance_.get();
}
// -------------------------------------------------------------------

// AuthenticateRequest_Email

// optional string email = 1;
inline void AuthenticateRequest_Email::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateRequest_Email::email() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.Email.email)
  return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_Email::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.Email.email)
}
inline void AuthenticateRequest_Email::set_email(const char* value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.Email.email)
}
inline void AuthenticateRequest_Email::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.Email.email)
}
inline ::std::string* AuthenticateRequest_Email::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.Email.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest_Email::release_email() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.Email.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_Email::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.Email.email)
}

// optional string password = 2;
inline void AuthenticateRequest_Email::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateRequest_Email::password() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.Email.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_Email::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.Email.password)
}
inline void AuthenticateRequest_Email::set_password(const char* value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.Email.password)
}
inline void AuthenticateRequest_Email::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.Email.password)
}
inline ::std::string* AuthenticateRequest_Email::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.Email.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest_Email::release_password() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.Email.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_Email::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.Email.password)
}

inline const AuthenticateRequest_Email* AuthenticateRequest_Email::internal_default_instance() {
  return &AuthenticateRequest_Email_default_instance_.get();
}
// -------------------------------------------------------------------

// AuthenticateRequest_GameCenter

// optional string player_id = 1;
inline void AuthenticateRequest_GameCenter::clear_player_id() {
  player_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateRequest_GameCenter::player_id() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.GameCenter.player_id)
  return player_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_player_id(const ::std::string& value) {
  
  player_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.GameCenter.player_id)
}
inline void AuthenticateRequest_GameCenter::set_player_id(const char* value) {
  
  player_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.GameCenter.player_id)
}
inline void AuthenticateRequest_GameCenter::set_player_id(const char* value, size_t size) {
  
  player_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.GameCenter.player_id)
}
inline ::std::string* AuthenticateRequest_GameCenter::mutable_player_id() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.GameCenter.player_id)
  return player_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest_GameCenter::release_player_id() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.GameCenter.player_id)
  
  return player_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_allocated_player_id(::std::string* player_id) {
  if (player_id != NULL) {
    
  } else {
    
  }
  player_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player_id);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.GameCenter.player_id)
}

// optional string bundle_id = 2;
inline void AuthenticateRequest_GameCenter::clear_bundle_id() {
  bundle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateRequest_GameCenter::bundle_id() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.GameCenter.bundle_id)
  return bundle_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_bundle_id(const ::std::string& value) {
  
  bundle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.GameCenter.bundle_id)
}
inline void AuthenticateRequest_GameCenter::set_bundle_id(const char* value) {
  
  bundle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.GameCenter.bundle_id)
}
inline void AuthenticateRequest_GameCenter::set_bundle_id(const char* value, size_t size) {
  
  bundle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.GameCenter.bundle_id)
}
inline ::std::string* AuthenticateRequest_GameCenter::mutable_bundle_id() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.GameCenter.bundle_id)
  return bundle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest_GameCenter::release_bundle_id() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.GameCenter.bundle_id)
  
  return bundle_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_allocated_bundle_id(::std::string* bundle_id) {
  if (bundle_id != NULL) {
    
  } else {
    
  }
  bundle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bundle_id);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.GameCenter.bundle_id)
}

// optional int64 timestamp = 3;
inline void AuthenticateRequest_GameCenter::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AuthenticateRequest_GameCenter::timestamp() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.GameCenter.timestamp)
  return timestamp_;
}
inline void AuthenticateRequest_GameCenter::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.GameCenter.timestamp)
}

// optional string salt = 4;
inline void AuthenticateRequest_GameCenter::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateRequest_GameCenter::salt() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.GameCenter.salt)
  return salt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.GameCenter.salt)
}
inline void AuthenticateRequest_GameCenter::set_salt(const char* value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.GameCenter.salt)
}
inline void AuthenticateRequest_GameCenter::set_salt(const char* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.GameCenter.salt)
}
inline ::std::string* AuthenticateRequest_GameCenter::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.GameCenter.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest_GameCenter::release_salt() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.GameCenter.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.GameCenter.salt)
}

// optional string signature = 5;
inline void AuthenticateRequest_GameCenter::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateRequest_GameCenter::signature() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.GameCenter.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.GameCenter.signature)
}
inline void AuthenticateRequest_GameCenter::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.GameCenter.signature)
}
inline void AuthenticateRequest_GameCenter::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.GameCenter.signature)
}
inline ::std::string* AuthenticateRequest_GameCenter::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.GameCenter.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest_GameCenter::release_signature() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.GameCenter.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.GameCenter.signature)
}

// optional string public_key_url = 6;
inline void AuthenticateRequest_GameCenter::clear_public_key_url() {
  public_key_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateRequest_GameCenter::public_key_url() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.GameCenter.public_key_url)
  return public_key_url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_public_key_url(const ::std::string& value) {
  
  public_key_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.GameCenter.public_key_url)
}
inline void AuthenticateRequest_GameCenter::set_public_key_url(const char* value) {
  
  public_key_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.GameCenter.public_key_url)
}
inline void AuthenticateRequest_GameCenter::set_public_key_url(const char* value, size_t size) {
  
  public_key_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.GameCenter.public_key_url)
}
inline ::std::string* AuthenticateRequest_GameCenter::mutable_public_key_url() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.GameCenter.public_key_url)
  return public_key_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest_GameCenter::release_public_key_url() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.GameCenter.public_key_url)
  
  return public_key_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest_GameCenter::set_allocated_public_key_url(::std::string* public_key_url) {
  if (public_key_url != NULL) {
    
  } else {
    
  }
  public_key_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key_url);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.GameCenter.public_key_url)
}

inline const AuthenticateRequest_GameCenter* AuthenticateRequest_GameCenter::internal_default_instance() {
  return &AuthenticateRequest_GameCenter_default_instance_.get();
}
// -------------------------------------------------------------------

// AuthenticateRequest

// optional string collationId = 1;
inline void AuthenticateRequest::clear_collationid() {
  collationid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateRequest::collationid() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.collationId)
  return collationid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest::set_collationid(const ::std::string& value) {
  
  collationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.collationId)
}
inline void AuthenticateRequest::set_collationid(const char* value) {
  
  collationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.collationId)
}
inline void AuthenticateRequest::set_collationid(const char* value, size_t size) {
  
  collationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.collationId)
}
inline ::std::string* AuthenticateRequest::mutable_collationid() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.collationId)
  return collationid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest::release_collationid() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.collationId)
  
  return collationid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRequest::set_allocated_collationid(::std::string* collationid) {
  if (collationid != NULL) {
    
  } else {
    
  }
  collationid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collationid);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.collationId)
}

// optional .server.AuthenticateRequest.Email email = 2;
inline bool AuthenticateRequest::has_email() const {
  return payload_case() == kEmail;
}
inline void AuthenticateRequest::set_has_email() {
  _oneof_case_[0] = kEmail;
}
inline void AuthenticateRequest::clear_email() {
  if (has_email()) {
    delete payload_.email_;
    clear_has_payload();
  }
}
inline  const ::server::AuthenticateRequest_Email& AuthenticateRequest::email() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.email)
  return has_email()
      ? *payload_.email_
      : ::server::AuthenticateRequest_Email::default_instance();
}
inline ::server::AuthenticateRequest_Email* AuthenticateRequest::mutable_email() {
  if (!has_email()) {
    clear_payload();
    set_has_email();
    payload_.email_ = new ::server::AuthenticateRequest_Email;
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.email)
  return payload_.email_;
}
inline ::server::AuthenticateRequest_Email* AuthenticateRequest::release_email() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.email)
  if (has_email()) {
    clear_has_payload();
    ::server::AuthenticateRequest_Email* temp = payload_.email_;
    payload_.email_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AuthenticateRequest::set_allocated_email(::server::AuthenticateRequest_Email* email) {
  clear_payload();
  if (email) {
    set_has_email();
    payload_.email_ = email;
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.email)
}

// optional string facebook = 3;
inline bool AuthenticateRequest::has_facebook() const {
  return payload_case() == kFacebook;
}
inline void AuthenticateRequest::set_has_facebook() {
  _oneof_case_[0] = kFacebook;
}
inline void AuthenticateRequest::clear_facebook() {
  if (has_facebook()) {
    payload_.facebook_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& AuthenticateRequest::facebook() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.facebook)
  if (has_facebook()) {
    return payload_.facebook_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateRequest::set_facebook(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.facebook)
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.facebook_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.facebook)
}
inline void AuthenticateRequest::set_facebook(const char* value) {
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.facebook_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.facebook)
}
inline void AuthenticateRequest::set_facebook(const char* value, size_t size) {
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.facebook_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.facebook)
}
inline ::std::string* AuthenticateRequest::mutable_facebook() {
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.facebook)
  return payload_.facebook_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest::release_facebook() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.facebook)
  if (has_facebook()) {
    clear_has_payload();
    return payload_.facebook_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AuthenticateRequest::set_allocated_facebook(::std::string* facebook) {
  if (!has_facebook()) {
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (facebook != NULL) {
    set_has_facebook();
    payload_.facebook_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        facebook);
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.facebook)
}

// optional string google = 4;
inline bool AuthenticateRequest::has_google() const {
  return payload_case() == kGoogle;
}
inline void AuthenticateRequest::set_has_google() {
  _oneof_case_[0] = kGoogle;
}
inline void AuthenticateRequest::clear_google() {
  if (has_google()) {
    payload_.google_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& AuthenticateRequest::google() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.google)
  if (has_google()) {
    return payload_.google_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateRequest::set_google(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.google)
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.google_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.google)
}
inline void AuthenticateRequest::set_google(const char* value) {
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.google_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.google)
}
inline void AuthenticateRequest::set_google(const char* value, size_t size) {
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.google_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.google)
}
inline ::std::string* AuthenticateRequest::mutable_google() {
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.google)
  return payload_.google_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest::release_google() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.google)
  if (has_google()) {
    clear_has_payload();
    return payload_.google_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AuthenticateRequest::set_allocated_google(::std::string* google) {
  if (!has_google()) {
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (google != NULL) {
    set_has_google();
    payload_.google_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        google);
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.google)
}

// optional .server.AuthenticateRequest.GameCenter game_center = 5;
inline bool AuthenticateRequest::has_game_center() const {
  return payload_case() == kGameCenter;
}
inline void AuthenticateRequest::set_has_game_center() {
  _oneof_case_[0] = kGameCenter;
}
inline void AuthenticateRequest::clear_game_center() {
  if (has_game_center()) {
    delete payload_.game_center_;
    clear_has_payload();
  }
}
inline  const ::server::AuthenticateRequest_GameCenter& AuthenticateRequest::game_center() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.game_center)
  return has_game_center()
      ? *payload_.game_center_
      : ::server::AuthenticateRequest_GameCenter::default_instance();
}
inline ::server::AuthenticateRequest_GameCenter* AuthenticateRequest::mutable_game_center() {
  if (!has_game_center()) {
    clear_payload();
    set_has_game_center();
    payload_.game_center_ = new ::server::AuthenticateRequest_GameCenter;
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.game_center)
  return payload_.game_center_;
}
inline ::server::AuthenticateRequest_GameCenter* AuthenticateRequest::release_game_center() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.game_center)
  if (has_game_center()) {
    clear_has_payload();
    ::server::AuthenticateRequest_GameCenter* temp = payload_.game_center_;
    payload_.game_center_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AuthenticateRequest::set_allocated_game_center(::server::AuthenticateRequest_GameCenter* game_center) {
  clear_payload();
  if (game_center) {
    set_has_game_center();
    payload_.game_center_ = game_center;
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.game_center)
}

// optional string steam = 6;
inline bool AuthenticateRequest::has_steam() const {
  return payload_case() == kSteam;
}
inline void AuthenticateRequest::set_has_steam() {
  _oneof_case_[0] = kSteam;
}
inline void AuthenticateRequest::clear_steam() {
  if (has_steam()) {
    payload_.steam_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& AuthenticateRequest::steam() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.steam)
  if (has_steam()) {
    return payload_.steam_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateRequest::set_steam(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.steam)
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.steam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.steam)
}
inline void AuthenticateRequest::set_steam(const char* value) {
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.steam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.steam)
}
inline void AuthenticateRequest::set_steam(const char* value, size_t size) {
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.steam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.steam)
}
inline ::std::string* AuthenticateRequest::mutable_steam() {
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.steam)
  return payload_.steam_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest::release_steam() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.steam)
  if (has_steam()) {
    clear_has_payload();
    return payload_.steam_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AuthenticateRequest::set_allocated_steam(::std::string* steam) {
  if (!has_steam()) {
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (steam != NULL) {
    set_has_steam();
    payload_.steam_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        steam);
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.steam)
}

// optional string device = 7;
inline bool AuthenticateRequest::has_device() const {
  return payload_case() == kDevice;
}
inline void AuthenticateRequest::set_has_device() {
  _oneof_case_[0] = kDevice;
}
inline void AuthenticateRequest::clear_device() {
  if (has_device()) {
    payload_.device_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& AuthenticateRequest::device() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.device)
  if (has_device()) {
    return payload_.device_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateRequest::set_device(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.device)
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.device)
}
inline void AuthenticateRequest::set_device(const char* value) {
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.device)
}
inline void AuthenticateRequest::set_device(const char* value, size_t size) {
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.device)
}
inline ::std::string* AuthenticateRequest::mutable_device() {
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.device)
  return payload_.device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest::release_device() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.device)
  if (has_device()) {
    clear_has_payload();
    return payload_.device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AuthenticateRequest::set_allocated_device(::std::string* device) {
  if (!has_device()) {
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (device != NULL) {
    set_has_device();
    payload_.device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        device);
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.device)
}

// optional string custom = 8;
inline bool AuthenticateRequest::has_custom() const {
  return payload_case() == kCustom;
}
inline void AuthenticateRequest::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void AuthenticateRequest::clear_custom() {
  if (has_custom()) {
    payload_.custom_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& AuthenticateRequest::custom() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateRequest.custom)
  if (has_custom()) {
    return payload_.custom_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateRequest::set_custom(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.custom)
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.custom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateRequest.custom)
}
inline void AuthenticateRequest::set_custom(const char* value) {
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.custom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateRequest.custom)
}
inline void AuthenticateRequest::set_custom(const char* value, size_t size) {
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.custom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateRequest.custom)
}
inline ::std::string* AuthenticateRequest::mutable_custom() {
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateRequest.custom)
  return payload_.custom_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRequest::release_custom() {
  // @@protoc_insertion_point(field_release:server.AuthenticateRequest.custom)
  if (has_custom()) {
    clear_has_payload();
    return payload_.custom_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AuthenticateRequest::set_allocated_custom(::std::string* custom) {
  if (!has_custom()) {
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (custom != NULL) {
    set_has_custom();
    payload_.custom_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        custom);
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateRequest.custom)
}

inline bool AuthenticateRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void AuthenticateRequest::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline AuthenticateRequest::PayloadCase AuthenticateRequest::payload_case() const {
  return AuthenticateRequest::PayloadCase(_oneof_case_[0]);
}
inline const AuthenticateRequest* AuthenticateRequest::internal_default_instance() {
  return &AuthenticateRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// AuthenticateResponse_Session

// optional string token = 1;
inline void AuthenticateResponse_Session::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateResponse_Session::token() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateResponse.Session.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateResponse_Session::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateResponse.Session.token)
}
inline void AuthenticateResponse_Session::set_token(const char* value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateResponse.Session.token)
}
inline void AuthenticateResponse_Session::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateResponse.Session.token)
}
inline ::std::string* AuthenticateResponse_Session::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateResponse.Session.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateResponse_Session::release_token() {
  // @@protoc_insertion_point(field_release:server.AuthenticateResponse.Session.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateResponse_Session::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateResponse.Session.token)
}

inline const AuthenticateResponse_Session* AuthenticateResponse_Session::internal_default_instance() {
  return &AuthenticateResponse_Session_default_instance_.get();
}
// -------------------------------------------------------------------

// AuthenticateResponse_Error

// optional int32 code = 1;
inline void AuthenticateResponse_Error::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 AuthenticateResponse_Error::code() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateResponse.Error.code)
  return code_;
}
inline void AuthenticateResponse_Error::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:server.AuthenticateResponse.Error.code)
}

// optional string message = 2;
inline void AuthenticateResponse_Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateResponse_Error::message() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateResponse.Error.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateResponse_Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateResponse.Error.message)
}
inline void AuthenticateResponse_Error::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateResponse.Error.message)
}
inline void AuthenticateResponse_Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateResponse.Error.message)
}
inline ::std::string* AuthenticateResponse_Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateResponse.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateResponse_Error::release_message() {
  // @@protoc_insertion_point(field_release:server.AuthenticateResponse.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateResponse_Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateResponse.Error.message)
}

// optional .server.AuthenticateRequest request = 3;
inline bool AuthenticateResponse_Error::has_request() const {
  return this != internal_default_instance() && request_ != NULL;
}
inline void AuthenticateResponse_Error::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) delete request_;
  request_ = NULL;
}
inline const ::server::AuthenticateRequest& AuthenticateResponse_Error::request() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateResponse.Error.request)
  return request_ != NULL ? *request_
                         : *::server::AuthenticateRequest::internal_default_instance();
}
inline ::server::AuthenticateRequest* AuthenticateResponse_Error::mutable_request() {
  
  if (request_ == NULL) {
    request_ = new ::server::AuthenticateRequest;
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateResponse.Error.request)
  return request_;
}
inline ::server::AuthenticateRequest* AuthenticateResponse_Error::release_request() {
  // @@protoc_insertion_point(field_release:server.AuthenticateResponse.Error.request)
  
  ::server::AuthenticateRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline void AuthenticateResponse_Error::set_allocated_request(::server::AuthenticateRequest* request) {
  delete request_;
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateResponse.Error.request)
}

inline const AuthenticateResponse_Error* AuthenticateResponse_Error::internal_default_instance() {
  return &AuthenticateResponse_Error_default_instance_.get();
}
// -------------------------------------------------------------------

// AuthenticateResponse

// optional string collation_id = 1;
inline void AuthenticateResponse::clear_collation_id() {
  collation_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthenticateResponse::collation_id() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateResponse.collation_id)
  return collation_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateResponse::set_collation_id(const ::std::string& value) {
  
  collation_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.AuthenticateResponse.collation_id)
}
inline void AuthenticateResponse::set_collation_id(const char* value) {
  
  collation_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.AuthenticateResponse.collation_id)
}
inline void AuthenticateResponse::set_collation_id(const char* value, size_t size) {
  
  collation_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.AuthenticateResponse.collation_id)
}
inline ::std::string* AuthenticateResponse::mutable_collation_id() {
  
  // @@protoc_insertion_point(field_mutable:server.AuthenticateResponse.collation_id)
  return collation_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateResponse::release_collation_id() {
  // @@protoc_insertion_point(field_release:server.AuthenticateResponse.collation_id)
  
  return collation_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateResponse::set_allocated_collation_id(::std::string* collation_id) {
  if (collation_id != NULL) {
    
  } else {
    
  }
  collation_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collation_id);
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateResponse.collation_id)
}

// optional .server.AuthenticateResponse.Session session = 2;
inline bool AuthenticateResponse::has_session() const {
  return payload_case() == kSession;
}
inline void AuthenticateResponse::set_has_session() {
  _oneof_case_[0] = kSession;
}
inline void AuthenticateResponse::clear_session() {
  if (has_session()) {
    delete payload_.session_;
    clear_has_payload();
  }
}
inline  const ::server::AuthenticateResponse_Session& AuthenticateResponse::session() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateResponse.session)
  return has_session()
      ? *payload_.session_
      : ::server::AuthenticateResponse_Session::default_instance();
}
inline ::server::AuthenticateResponse_Session* AuthenticateResponse::mutable_session() {
  if (!has_session()) {
    clear_payload();
    set_has_session();
    payload_.session_ = new ::server::AuthenticateResponse_Session;
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateResponse.session)
  return payload_.session_;
}
inline ::server::AuthenticateResponse_Session* AuthenticateResponse::release_session() {
  // @@protoc_insertion_point(field_release:server.AuthenticateResponse.session)
  if (has_session()) {
    clear_has_payload();
    ::server::AuthenticateResponse_Session* temp = payload_.session_;
    payload_.session_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AuthenticateResponse::set_allocated_session(::server::AuthenticateResponse_Session* session) {
  clear_payload();
  if (session) {
    set_has_session();
    payload_.session_ = session;
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateResponse.session)
}

// optional .server.AuthenticateResponse.Error error = 3;
inline bool AuthenticateResponse::has_error() const {
  return payload_case() == kError;
}
inline void AuthenticateResponse::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void AuthenticateResponse::clear_error() {
  if (has_error()) {
    delete payload_.error_;
    clear_has_payload();
  }
}
inline  const ::server::AuthenticateResponse_Error& AuthenticateResponse::error() const {
  // @@protoc_insertion_point(field_get:server.AuthenticateResponse.error)
  return has_error()
      ? *payload_.error_
      : ::server::AuthenticateResponse_Error::default_instance();
}
inline ::server::AuthenticateResponse_Error* AuthenticateResponse::mutable_error() {
  if (!has_error()) {
    clear_payload();
    set_has_error();
    payload_.error_ = new ::server::AuthenticateResponse_Error;
  }
  // @@protoc_insertion_point(field_mutable:server.AuthenticateResponse.error)
  return payload_.error_;
}
inline ::server::AuthenticateResponse_Error* AuthenticateResponse::release_error() {
  // @@protoc_insertion_point(field_release:server.AuthenticateResponse.error)
  if (has_error()) {
    clear_has_payload();
    ::server::AuthenticateResponse_Error* temp = payload_.error_;
    payload_.error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AuthenticateResponse::set_allocated_error(::server::AuthenticateResponse_Error* error) {
  clear_payload();
  if (error) {
    set_has_error();
    payload_.error_ = error;
  }
  // @@protoc_insertion_point(field_set_allocated:server.AuthenticateResponse.error)
}

inline bool AuthenticateResponse::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void AuthenticateResponse::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline AuthenticateResponse::PayloadCase AuthenticateResponse::payload_case() const {
  return AuthenticateResponse::PayloadCase(_oneof_case_[0]);
}
inline const AuthenticateResponse* AuthenticateResponse::internal_default_instance() {
  return &AuthenticateResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// Envelope

// optional string collation_id = 1;
inline void Envelope::clear_collation_id() {
  collation_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Envelope::collation_id() const {
  // @@protoc_insertion_point(field_get:server.Envelope.collation_id)
  return collation_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Envelope::set_collation_id(const ::std::string& value) {
  
  collation_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Envelope.collation_id)
}
inline void Envelope::set_collation_id(const char* value) {
  
  collation_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Envelope.collation_id)
}
inline void Envelope::set_collation_id(const char* value, size_t size) {
  
  collation_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Envelope.collation_id)
}
inline ::std::string* Envelope::mutable_collation_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Envelope.collation_id)
  return collation_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Envelope::release_collation_id() {
  // @@protoc_insertion_point(field_release:server.Envelope.collation_id)
  
  return collation_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Envelope::set_allocated_collation_id(::std::string* collation_id) {
  if (collation_id != NULL) {
    
  } else {
    
  }
  collation_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collation_id);
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.collation_id)
}

// optional .server.Error error = 2;
inline bool Envelope::has_error() const {
  return payload_case() == kError;
}
inline void Envelope::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void Envelope::clear_error() {
  if (has_error()) {
    delete payload_.error_;
    clear_has_payload();
  }
}
inline  const ::server::Error& Envelope::error() const {
  // @@protoc_insertion_point(field_get:server.Envelope.error)
  return has_error()
      ? *payload_.error_
      : ::server::Error::default_instance();
}
inline ::server::Error* Envelope::mutable_error() {
  if (!has_error()) {
    clear_payload();
    set_has_error();
    payload_.error_ = new ::server::Error;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.error)
  return payload_.error_;
}
inline ::server::Error* Envelope::release_error() {
  // @@protoc_insertion_point(field_release:server.Envelope.error)
  if (has_error()) {
    clear_has_payload();
    ::server::Error* temp = payload_.error_;
    payload_.error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_error(::server::Error* error) {
  clear_payload();
  if (error) {
    set_has_error();
    payload_.error_ = error;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.error)
}

// optional .server.Heartbeat heartbeat = 3;
inline bool Envelope::has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline void Envelope::set_has_heartbeat() {
  _oneof_case_[0] = kHeartbeat;
}
inline void Envelope::clear_heartbeat() {
  if (has_heartbeat()) {
    delete payload_.heartbeat_;
    clear_has_payload();
  }
}
inline  const ::server::Heartbeat& Envelope::heartbeat() const {
  // @@protoc_insertion_point(field_get:server.Envelope.heartbeat)
  return has_heartbeat()
      ? *payload_.heartbeat_
      : ::server::Heartbeat::default_instance();
}
inline ::server::Heartbeat* Envelope::mutable_heartbeat() {
  if (!has_heartbeat()) {
    clear_payload();
    set_has_heartbeat();
    payload_.heartbeat_ = new ::server::Heartbeat;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.heartbeat)
  return payload_.heartbeat_;
}
inline ::server::Heartbeat* Envelope::release_heartbeat() {
  // @@protoc_insertion_point(field_release:server.Envelope.heartbeat)
  if (has_heartbeat()) {
    clear_has_payload();
    ::server::Heartbeat* temp = payload_.heartbeat_;
    payload_.heartbeat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_heartbeat(::server::Heartbeat* heartbeat) {
  clear_payload();
  if (heartbeat) {
    set_has_heartbeat();
    payload_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.heartbeat)
}

// optional .server.Logout logout = 4;
inline bool Envelope::has_logout() const {
  return payload_case() == kLogout;
}
inline void Envelope::set_has_logout() {
  _oneof_case_[0] = kLogout;
}
inline void Envelope::clear_logout() {
  if (has_logout()) {
    delete payload_.logout_;
    clear_has_payload();
  }
}
inline  const ::server::Logout& Envelope::logout() const {
  // @@protoc_insertion_point(field_get:server.Envelope.logout)
  return has_logout()
      ? *payload_.logout_
      : ::server::Logout::default_instance();
}
inline ::server::Logout* Envelope::mutable_logout() {
  if (!has_logout()) {
    clear_payload();
    set_has_logout();
    payload_.logout_ = new ::server::Logout;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.logout)
  return payload_.logout_;
}
inline ::server::Logout* Envelope::release_logout() {
  // @@protoc_insertion_point(field_release:server.Envelope.logout)
  if (has_logout()) {
    clear_has_payload();
    ::server::Logout* temp = payload_.logout_;
    payload_.logout_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_logout(::server::Logout* logout) {
  clear_payload();
  if (logout) {
    set_has_logout();
    payload_.logout_ = logout;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.logout)
}

// optional .server.TLink link = 5;
inline bool Envelope::has_link() const {
  return payload_case() == kLink;
}
inline void Envelope::set_has_link() {
  _oneof_case_[0] = kLink;
}
inline void Envelope::clear_link() {
  if (has_link()) {
    delete payload_.link_;
    clear_has_payload();
  }
}
inline  const ::server::TLink& Envelope::link() const {
  // @@protoc_insertion_point(field_get:server.Envelope.link)
  return has_link()
      ? *payload_.link_
      : ::server::TLink::default_instance();
}
inline ::server::TLink* Envelope::mutable_link() {
  if (!has_link()) {
    clear_payload();
    set_has_link();
    payload_.link_ = new ::server::TLink;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.link)
  return payload_.link_;
}
inline ::server::TLink* Envelope::release_link() {
  // @@protoc_insertion_point(field_release:server.Envelope.link)
  if (has_link()) {
    clear_has_payload();
    ::server::TLink* temp = payload_.link_;
    payload_.link_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_link(::server::TLink* link) {
  clear_payload();
  if (link) {
    set_has_link();
    payload_.link_ = link;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.link)
}

// optional .server.TUnlink unlink = 6;
inline bool Envelope::has_unlink() const {
  return payload_case() == kUnlink;
}
inline void Envelope::set_has_unlink() {
  _oneof_case_[0] = kUnlink;
}
inline void Envelope::clear_unlink() {
  if (has_unlink()) {
    delete payload_.unlink_;
    clear_has_payload();
  }
}
inline  const ::server::TUnlink& Envelope::unlink() const {
  // @@protoc_insertion_point(field_get:server.Envelope.unlink)
  return has_unlink()
      ? *payload_.unlink_
      : ::server::TUnlink::default_instance();
}
inline ::server::TUnlink* Envelope::mutable_unlink() {
  if (!has_unlink()) {
    clear_payload();
    set_has_unlink();
    payload_.unlink_ = new ::server::TUnlink;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.unlink)
  return payload_.unlink_;
}
inline ::server::TUnlink* Envelope::release_unlink() {
  // @@protoc_insertion_point(field_release:server.Envelope.unlink)
  if (has_unlink()) {
    clear_has_payload();
    ::server::TUnlink* temp = payload_.unlink_;
    payload_.unlink_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_unlink(::server::TUnlink* unlink) {
  clear_payload();
  if (unlink) {
    set_has_unlink();
    payload_.unlink_ = unlink;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.unlink)
}

// optional .server.TSelfFetch self_fetch = 7;
inline bool Envelope::has_self_fetch() const {
  return payload_case() == kSelfFetch;
}
inline void Envelope::set_has_self_fetch() {
  _oneof_case_[0] = kSelfFetch;
}
inline void Envelope::clear_self_fetch() {
  if (has_self_fetch()) {
    delete payload_.self_fetch_;
    clear_has_payload();
  }
}
inline  const ::server::TSelfFetch& Envelope::self_fetch() const {
  // @@protoc_insertion_point(field_get:server.Envelope.self_fetch)
  return has_self_fetch()
      ? *payload_.self_fetch_
      : ::server::TSelfFetch::default_instance();
}
inline ::server::TSelfFetch* Envelope::mutable_self_fetch() {
  if (!has_self_fetch()) {
    clear_payload();
    set_has_self_fetch();
    payload_.self_fetch_ = new ::server::TSelfFetch;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.self_fetch)
  return payload_.self_fetch_;
}
inline ::server::TSelfFetch* Envelope::release_self_fetch() {
  // @@protoc_insertion_point(field_release:server.Envelope.self_fetch)
  if (has_self_fetch()) {
    clear_has_payload();
    ::server::TSelfFetch* temp = payload_.self_fetch_;
    payload_.self_fetch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_self_fetch(::server::TSelfFetch* self_fetch) {
  clear_payload();
  if (self_fetch) {
    set_has_self_fetch();
    payload_.self_fetch_ = self_fetch;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.self_fetch)
}

// optional .server.TSelfUpdate self_update = 8;
inline bool Envelope::has_self_update() const {
  return payload_case() == kSelfUpdate;
}
inline void Envelope::set_has_self_update() {
  _oneof_case_[0] = kSelfUpdate;
}
inline void Envelope::clear_self_update() {
  if (has_self_update()) {
    delete payload_.self_update_;
    clear_has_payload();
  }
}
inline  const ::server::TSelfUpdate& Envelope::self_update() const {
  // @@protoc_insertion_point(field_get:server.Envelope.self_update)
  return has_self_update()
      ? *payload_.self_update_
      : ::server::TSelfUpdate::default_instance();
}
inline ::server::TSelfUpdate* Envelope::mutable_self_update() {
  if (!has_self_update()) {
    clear_payload();
    set_has_self_update();
    payload_.self_update_ = new ::server::TSelfUpdate;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.self_update)
  return payload_.self_update_;
}
inline ::server::TSelfUpdate* Envelope::release_self_update() {
  // @@protoc_insertion_point(field_release:server.Envelope.self_update)
  if (has_self_update()) {
    clear_has_payload();
    ::server::TSelfUpdate* temp = payload_.self_update_;
    payload_.self_update_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_self_update(::server::TSelfUpdate* self_update) {
  clear_payload();
  if (self_update) {
    set_has_self_update();
    payload_.self_update_ = self_update;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.self_update)
}

// optional .server.TUsersFetch users_fetch = 9;
inline bool Envelope::has_users_fetch() const {
  return payload_case() == kUsersFetch;
}
inline void Envelope::set_has_users_fetch() {
  _oneof_case_[0] = kUsersFetch;
}
inline void Envelope::clear_users_fetch() {
  if (has_users_fetch()) {
    delete payload_.users_fetch_;
    clear_has_payload();
  }
}
inline  const ::server::TUsersFetch& Envelope::users_fetch() const {
  // @@protoc_insertion_point(field_get:server.Envelope.users_fetch)
  return has_users_fetch()
      ? *payload_.users_fetch_
      : ::server::TUsersFetch::default_instance();
}
inline ::server::TUsersFetch* Envelope::mutable_users_fetch() {
  if (!has_users_fetch()) {
    clear_payload();
    set_has_users_fetch();
    payload_.users_fetch_ = new ::server::TUsersFetch;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.users_fetch)
  return payload_.users_fetch_;
}
inline ::server::TUsersFetch* Envelope::release_users_fetch() {
  // @@protoc_insertion_point(field_release:server.Envelope.users_fetch)
  if (has_users_fetch()) {
    clear_has_payload();
    ::server::TUsersFetch* temp = payload_.users_fetch_;
    payload_.users_fetch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_users_fetch(::server::TUsersFetch* users_fetch) {
  clear_payload();
  if (users_fetch) {
    set_has_users_fetch();
    payload_.users_fetch_ = users_fetch;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.users_fetch)
}

// optional .server.TSelf self = 10;
inline bool Envelope::has_self() const {
  return payload_case() == kSelf;
}
inline void Envelope::set_has_self() {
  _oneof_case_[0] = kSelf;
}
inline void Envelope::clear_self() {
  if (has_self()) {
    delete payload_.self_;
    clear_has_payload();
  }
}
inline  const ::server::TSelf& Envelope::self() const {
  // @@protoc_insertion_point(field_get:server.Envelope.self)
  return has_self()
      ? *payload_.self_
      : ::server::TSelf::default_instance();
}
inline ::server::TSelf* Envelope::mutable_self() {
  if (!has_self()) {
    clear_payload();
    set_has_self();
    payload_.self_ = new ::server::TSelf;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.self)
  return payload_.self_;
}
inline ::server::TSelf* Envelope::release_self() {
  // @@protoc_insertion_point(field_release:server.Envelope.self)
  if (has_self()) {
    clear_has_payload();
    ::server::TSelf* temp = payload_.self_;
    payload_.self_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_self(::server::TSelf* self) {
  clear_payload();
  if (self) {
    set_has_self();
    payload_.self_ = self;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.self)
}

// optional .server.TUsers users = 11;
inline bool Envelope::has_users() const {
  return payload_case() == kUsers;
}
inline void Envelope::set_has_users() {
  _oneof_case_[0] = kUsers;
}
inline void Envelope::clear_users() {
  if (has_users()) {
    delete payload_.users_;
    clear_has_payload();
  }
}
inline  const ::server::TUsers& Envelope::users() const {
  // @@protoc_insertion_point(field_get:server.Envelope.users)
  return has_users()
      ? *payload_.users_
      : ::server::TUsers::default_instance();
}
inline ::server::TUsers* Envelope::mutable_users() {
  if (!has_users()) {
    clear_payload();
    set_has_users();
    payload_.users_ = new ::server::TUsers;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.users)
  return payload_.users_;
}
inline ::server::TUsers* Envelope::release_users() {
  // @@protoc_insertion_point(field_release:server.Envelope.users)
  if (has_users()) {
    clear_has_payload();
    ::server::TUsers* temp = payload_.users_;
    payload_.users_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_users(::server::TUsers* users) {
  clear_payload();
  if (users) {
    set_has_users();
    payload_.users_ = users;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.users)
}

// optional .server.TFriendAdd friend_add = 12;
inline bool Envelope::has_friend_add() const {
  return payload_case() == kFriendAdd;
}
inline void Envelope::set_has_friend_add() {
  _oneof_case_[0] = kFriendAdd;
}
inline void Envelope::clear_friend_add() {
  if (has_friend_add()) {
    delete payload_.friend_add_;
    clear_has_payload();
  }
}
inline  const ::server::TFriendAdd& Envelope::friend_add() const {
  // @@protoc_insertion_point(field_get:server.Envelope.friend_add)
  return has_friend_add()
      ? *payload_.friend_add_
      : ::server::TFriendAdd::default_instance();
}
inline ::server::TFriendAdd* Envelope::mutable_friend_add() {
  if (!has_friend_add()) {
    clear_payload();
    set_has_friend_add();
    payload_.friend_add_ = new ::server::TFriendAdd;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.friend_add)
  return payload_.friend_add_;
}
inline ::server::TFriendAdd* Envelope::release_friend_add() {
  // @@protoc_insertion_point(field_release:server.Envelope.friend_add)
  if (has_friend_add()) {
    clear_has_payload();
    ::server::TFriendAdd* temp = payload_.friend_add_;
    payload_.friend_add_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_friend_add(::server::TFriendAdd* friend_add) {
  clear_payload();
  if (friend_add) {
    set_has_friend_add();
    payload_.friend_add_ = friend_add;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.friend_add)
}

// optional .server.TFriendRemove friend_remove = 13;
inline bool Envelope::has_friend_remove() const {
  return payload_case() == kFriendRemove;
}
inline void Envelope::set_has_friend_remove() {
  _oneof_case_[0] = kFriendRemove;
}
inline void Envelope::clear_friend_remove() {
  if (has_friend_remove()) {
    delete payload_.friend_remove_;
    clear_has_payload();
  }
}
inline  const ::server::TFriendRemove& Envelope::friend_remove() const {
  // @@protoc_insertion_point(field_get:server.Envelope.friend_remove)
  return has_friend_remove()
      ? *payload_.friend_remove_
      : ::server::TFriendRemove::default_instance();
}
inline ::server::TFriendRemove* Envelope::mutable_friend_remove() {
  if (!has_friend_remove()) {
    clear_payload();
    set_has_friend_remove();
    payload_.friend_remove_ = new ::server::TFriendRemove;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.friend_remove)
  return payload_.friend_remove_;
}
inline ::server::TFriendRemove* Envelope::release_friend_remove() {
  // @@protoc_insertion_point(field_release:server.Envelope.friend_remove)
  if (has_friend_remove()) {
    clear_has_payload();
    ::server::TFriendRemove* temp = payload_.friend_remove_;
    payload_.friend_remove_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_friend_remove(::server::TFriendRemove* friend_remove) {
  clear_payload();
  if (friend_remove) {
    set_has_friend_remove();
    payload_.friend_remove_ = friend_remove;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.friend_remove)
}

// optional .server.TFriendBlock friend_block = 14;
inline bool Envelope::has_friend_block() const {
  return payload_case() == kFriendBlock;
}
inline void Envelope::set_has_friend_block() {
  _oneof_case_[0] = kFriendBlock;
}
inline void Envelope::clear_friend_block() {
  if (has_friend_block()) {
    delete payload_.friend_block_;
    clear_has_payload();
  }
}
inline  const ::server::TFriendBlock& Envelope::friend_block() const {
  // @@protoc_insertion_point(field_get:server.Envelope.friend_block)
  return has_friend_block()
      ? *payload_.friend_block_
      : ::server::TFriendBlock::default_instance();
}
inline ::server::TFriendBlock* Envelope::mutable_friend_block() {
  if (!has_friend_block()) {
    clear_payload();
    set_has_friend_block();
    payload_.friend_block_ = new ::server::TFriendBlock;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.friend_block)
  return payload_.friend_block_;
}
inline ::server::TFriendBlock* Envelope::release_friend_block() {
  // @@protoc_insertion_point(field_release:server.Envelope.friend_block)
  if (has_friend_block()) {
    clear_has_payload();
    ::server::TFriendBlock* temp = payload_.friend_block_;
    payload_.friend_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_friend_block(::server::TFriendBlock* friend_block) {
  clear_payload();
  if (friend_block) {
    set_has_friend_block();
    payload_.friend_block_ = friend_block;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.friend_block)
}

// optional .server.TFriendsList friends_list = 15;
inline bool Envelope::has_friends_list() const {
  return payload_case() == kFriendsList;
}
inline void Envelope::set_has_friends_list() {
  _oneof_case_[0] = kFriendsList;
}
inline void Envelope::clear_friends_list() {
  if (has_friends_list()) {
    delete payload_.friends_list_;
    clear_has_payload();
  }
}
inline  const ::server::TFriendsList& Envelope::friends_list() const {
  // @@protoc_insertion_point(field_get:server.Envelope.friends_list)
  return has_friends_list()
      ? *payload_.friends_list_
      : ::server::TFriendsList::default_instance();
}
inline ::server::TFriendsList* Envelope::mutable_friends_list() {
  if (!has_friends_list()) {
    clear_payload();
    set_has_friends_list();
    payload_.friends_list_ = new ::server::TFriendsList;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.friends_list)
  return payload_.friends_list_;
}
inline ::server::TFriendsList* Envelope::release_friends_list() {
  // @@protoc_insertion_point(field_release:server.Envelope.friends_list)
  if (has_friends_list()) {
    clear_has_payload();
    ::server::TFriendsList* temp = payload_.friends_list_;
    payload_.friends_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_friends_list(::server::TFriendsList* friends_list) {
  clear_payload();
  if (friends_list) {
    set_has_friends_list();
    payload_.friends_list_ = friends_list;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.friends_list)
}

// optional .server.TFriends friends = 16;
inline bool Envelope::has_friends() const {
  return payload_case() == kFriends;
}
inline void Envelope::set_has_friends() {
  _oneof_case_[0] = kFriends;
}
inline void Envelope::clear_friends() {
  if (has_friends()) {
    delete payload_.friends_;
    clear_has_payload();
  }
}
inline  const ::server::TFriends& Envelope::friends() const {
  // @@protoc_insertion_point(field_get:server.Envelope.friends)
  return has_friends()
      ? *payload_.friends_
      : ::server::TFriends::default_instance();
}
inline ::server::TFriends* Envelope::mutable_friends() {
  if (!has_friends()) {
    clear_payload();
    set_has_friends();
    payload_.friends_ = new ::server::TFriends;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.friends)
  return payload_.friends_;
}
inline ::server::TFriends* Envelope::release_friends() {
  // @@protoc_insertion_point(field_release:server.Envelope.friends)
  if (has_friends()) {
    clear_has_payload();
    ::server::TFriends* temp = payload_.friends_;
    payload_.friends_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_friends(::server::TFriends* friends) {
  clear_payload();
  if (friends) {
    set_has_friends();
    payload_.friends_ = friends;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.friends)
}

// optional .server.TGroupCreate group_create = 17;
inline bool Envelope::has_group_create() const {
  return payload_case() == kGroupCreate;
}
inline void Envelope::set_has_group_create() {
  _oneof_case_[0] = kGroupCreate;
}
inline void Envelope::clear_group_create() {
  if (has_group_create()) {
    delete payload_.group_create_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupCreate& Envelope::group_create() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_create)
  return has_group_create()
      ? *payload_.group_create_
      : ::server::TGroupCreate::default_instance();
}
inline ::server::TGroupCreate* Envelope::mutable_group_create() {
  if (!has_group_create()) {
    clear_payload();
    set_has_group_create();
    payload_.group_create_ = new ::server::TGroupCreate;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_create)
  return payload_.group_create_;
}
inline ::server::TGroupCreate* Envelope::release_group_create() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_create)
  if (has_group_create()) {
    clear_has_payload();
    ::server::TGroupCreate* temp = payload_.group_create_;
    payload_.group_create_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_create(::server::TGroupCreate* group_create) {
  clear_payload();
  if (group_create) {
    set_has_group_create();
    payload_.group_create_ = group_create;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_create)
}

// optional .server.TGroupUpdate group_update = 18;
inline bool Envelope::has_group_update() const {
  return payload_case() == kGroupUpdate;
}
inline void Envelope::set_has_group_update() {
  _oneof_case_[0] = kGroupUpdate;
}
inline void Envelope::clear_group_update() {
  if (has_group_update()) {
    delete payload_.group_update_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupUpdate& Envelope::group_update() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_update)
  return has_group_update()
      ? *payload_.group_update_
      : ::server::TGroupUpdate::default_instance();
}
inline ::server::TGroupUpdate* Envelope::mutable_group_update() {
  if (!has_group_update()) {
    clear_payload();
    set_has_group_update();
    payload_.group_update_ = new ::server::TGroupUpdate;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_update)
  return payload_.group_update_;
}
inline ::server::TGroupUpdate* Envelope::release_group_update() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_update)
  if (has_group_update()) {
    clear_has_payload();
    ::server::TGroupUpdate* temp = payload_.group_update_;
    payload_.group_update_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_update(::server::TGroupUpdate* group_update) {
  clear_payload();
  if (group_update) {
    set_has_group_update();
    payload_.group_update_ = group_update;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_update)
}

// optional .server.TGroupRemove group_remove = 19;
inline bool Envelope::has_group_remove() const {
  return payload_case() == kGroupRemove;
}
inline void Envelope::set_has_group_remove() {
  _oneof_case_[0] = kGroupRemove;
}
inline void Envelope::clear_group_remove() {
  if (has_group_remove()) {
    delete payload_.group_remove_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupRemove& Envelope::group_remove() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_remove)
  return has_group_remove()
      ? *payload_.group_remove_
      : ::server::TGroupRemove::default_instance();
}
inline ::server::TGroupRemove* Envelope::mutable_group_remove() {
  if (!has_group_remove()) {
    clear_payload();
    set_has_group_remove();
    payload_.group_remove_ = new ::server::TGroupRemove;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_remove)
  return payload_.group_remove_;
}
inline ::server::TGroupRemove* Envelope::release_group_remove() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_remove)
  if (has_group_remove()) {
    clear_has_payload();
    ::server::TGroupRemove* temp = payload_.group_remove_;
    payload_.group_remove_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_remove(::server::TGroupRemove* group_remove) {
  clear_payload();
  if (group_remove) {
    set_has_group_remove();
    payload_.group_remove_ = group_remove;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_remove)
}

// optional .server.TGroupsFetch groups_fetch = 20;
inline bool Envelope::has_groups_fetch() const {
  return payload_case() == kGroupsFetch;
}
inline void Envelope::set_has_groups_fetch() {
  _oneof_case_[0] = kGroupsFetch;
}
inline void Envelope::clear_groups_fetch() {
  if (has_groups_fetch()) {
    delete payload_.groups_fetch_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupsFetch& Envelope::groups_fetch() const {
  // @@protoc_insertion_point(field_get:server.Envelope.groups_fetch)
  return has_groups_fetch()
      ? *payload_.groups_fetch_
      : ::server::TGroupsFetch::default_instance();
}
inline ::server::TGroupsFetch* Envelope::mutable_groups_fetch() {
  if (!has_groups_fetch()) {
    clear_payload();
    set_has_groups_fetch();
    payload_.groups_fetch_ = new ::server::TGroupsFetch;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.groups_fetch)
  return payload_.groups_fetch_;
}
inline ::server::TGroupsFetch* Envelope::release_groups_fetch() {
  // @@protoc_insertion_point(field_release:server.Envelope.groups_fetch)
  if (has_groups_fetch()) {
    clear_has_payload();
    ::server::TGroupsFetch* temp = payload_.groups_fetch_;
    payload_.groups_fetch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_groups_fetch(::server::TGroupsFetch* groups_fetch) {
  clear_payload();
  if (groups_fetch) {
    set_has_groups_fetch();
    payload_.groups_fetch_ = groups_fetch;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.groups_fetch)
}

// optional .server.TGroupsList groups_list = 21;
inline bool Envelope::has_groups_list() const {
  return payload_case() == kGroupsList;
}
inline void Envelope::set_has_groups_list() {
  _oneof_case_[0] = kGroupsList;
}
inline void Envelope::clear_groups_list() {
  if (has_groups_list()) {
    delete payload_.groups_list_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupsList& Envelope::groups_list() const {
  // @@protoc_insertion_point(field_get:server.Envelope.groups_list)
  return has_groups_list()
      ? *payload_.groups_list_
      : ::server::TGroupsList::default_instance();
}
inline ::server::TGroupsList* Envelope::mutable_groups_list() {
  if (!has_groups_list()) {
    clear_payload();
    set_has_groups_list();
    payload_.groups_list_ = new ::server::TGroupsList;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.groups_list)
  return payload_.groups_list_;
}
inline ::server::TGroupsList* Envelope::release_groups_list() {
  // @@protoc_insertion_point(field_release:server.Envelope.groups_list)
  if (has_groups_list()) {
    clear_has_payload();
    ::server::TGroupsList* temp = payload_.groups_list_;
    payload_.groups_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_groups_list(::server::TGroupsList* groups_list) {
  clear_payload();
  if (groups_list) {
    set_has_groups_list();
    payload_.groups_list_ = groups_list;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.groups_list)
}

// optional .server.TGroupsSelfList groups_self_list = 22;
inline bool Envelope::has_groups_self_list() const {
  return payload_case() == kGroupsSelfList;
}
inline void Envelope::set_has_groups_self_list() {
  _oneof_case_[0] = kGroupsSelfList;
}
inline void Envelope::clear_groups_self_list() {
  if (has_groups_self_list()) {
    delete payload_.groups_self_list_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupsSelfList& Envelope::groups_self_list() const {
  // @@protoc_insertion_point(field_get:server.Envelope.groups_self_list)
  return has_groups_self_list()
      ? *payload_.groups_self_list_
      : ::server::TGroupsSelfList::default_instance();
}
inline ::server::TGroupsSelfList* Envelope::mutable_groups_self_list() {
  if (!has_groups_self_list()) {
    clear_payload();
    set_has_groups_self_list();
    payload_.groups_self_list_ = new ::server::TGroupsSelfList;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.groups_self_list)
  return payload_.groups_self_list_;
}
inline ::server::TGroupsSelfList* Envelope::release_groups_self_list() {
  // @@protoc_insertion_point(field_release:server.Envelope.groups_self_list)
  if (has_groups_self_list()) {
    clear_has_payload();
    ::server::TGroupsSelfList* temp = payload_.groups_self_list_;
    payload_.groups_self_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_groups_self_list(::server::TGroupsSelfList* groups_self_list) {
  clear_payload();
  if (groups_self_list) {
    set_has_groups_self_list();
    payload_.groups_self_list_ = groups_self_list;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.groups_self_list)
}

// optional .server.TGroupUsersList group_users_list = 23;
inline bool Envelope::has_group_users_list() const {
  return payload_case() == kGroupUsersList;
}
inline void Envelope::set_has_group_users_list() {
  _oneof_case_[0] = kGroupUsersList;
}
inline void Envelope::clear_group_users_list() {
  if (has_group_users_list()) {
    delete payload_.group_users_list_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupUsersList& Envelope::group_users_list() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_users_list)
  return has_group_users_list()
      ? *payload_.group_users_list_
      : ::server::TGroupUsersList::default_instance();
}
inline ::server::TGroupUsersList* Envelope::mutable_group_users_list() {
  if (!has_group_users_list()) {
    clear_payload();
    set_has_group_users_list();
    payload_.group_users_list_ = new ::server::TGroupUsersList;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_users_list)
  return payload_.group_users_list_;
}
inline ::server::TGroupUsersList* Envelope::release_group_users_list() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_users_list)
  if (has_group_users_list()) {
    clear_has_payload();
    ::server::TGroupUsersList* temp = payload_.group_users_list_;
    payload_.group_users_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_users_list(::server::TGroupUsersList* group_users_list) {
  clear_payload();
  if (group_users_list) {
    set_has_group_users_list();
    payload_.group_users_list_ = group_users_list;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_users_list)
}

// optional .server.TGroupJoin group_join = 24;
inline bool Envelope::has_group_join() const {
  return payload_case() == kGroupJoin;
}
inline void Envelope::set_has_group_join() {
  _oneof_case_[0] = kGroupJoin;
}
inline void Envelope::clear_group_join() {
  if (has_group_join()) {
    delete payload_.group_join_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupJoin& Envelope::group_join() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_join)
  return has_group_join()
      ? *payload_.group_join_
      : ::server::TGroupJoin::default_instance();
}
inline ::server::TGroupJoin* Envelope::mutable_group_join() {
  if (!has_group_join()) {
    clear_payload();
    set_has_group_join();
    payload_.group_join_ = new ::server::TGroupJoin;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_join)
  return payload_.group_join_;
}
inline ::server::TGroupJoin* Envelope::release_group_join() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_join)
  if (has_group_join()) {
    clear_has_payload();
    ::server::TGroupJoin* temp = payload_.group_join_;
    payload_.group_join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_join(::server::TGroupJoin* group_join) {
  clear_payload();
  if (group_join) {
    set_has_group_join();
    payload_.group_join_ = group_join;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_join)
}

// optional .server.TGroupLeave group_leave = 25;
inline bool Envelope::has_group_leave() const {
  return payload_case() == kGroupLeave;
}
inline void Envelope::set_has_group_leave() {
  _oneof_case_[0] = kGroupLeave;
}
inline void Envelope::clear_group_leave() {
  if (has_group_leave()) {
    delete payload_.group_leave_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupLeave& Envelope::group_leave() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_leave)
  return has_group_leave()
      ? *payload_.group_leave_
      : ::server::TGroupLeave::default_instance();
}
inline ::server::TGroupLeave* Envelope::mutable_group_leave() {
  if (!has_group_leave()) {
    clear_payload();
    set_has_group_leave();
    payload_.group_leave_ = new ::server::TGroupLeave;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_leave)
  return payload_.group_leave_;
}
inline ::server::TGroupLeave* Envelope::release_group_leave() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_leave)
  if (has_group_leave()) {
    clear_has_payload();
    ::server::TGroupLeave* temp = payload_.group_leave_;
    payload_.group_leave_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_leave(::server::TGroupLeave* group_leave) {
  clear_payload();
  if (group_leave) {
    set_has_group_leave();
    payload_.group_leave_ = group_leave;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_leave)
}

// optional .server.TGroupUserAdd group_user_add = 26;
inline bool Envelope::has_group_user_add() const {
  return payload_case() == kGroupUserAdd;
}
inline void Envelope::set_has_group_user_add() {
  _oneof_case_[0] = kGroupUserAdd;
}
inline void Envelope::clear_group_user_add() {
  if (has_group_user_add()) {
    delete payload_.group_user_add_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupUserAdd& Envelope::group_user_add() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_user_add)
  return has_group_user_add()
      ? *payload_.group_user_add_
      : ::server::TGroupUserAdd::default_instance();
}
inline ::server::TGroupUserAdd* Envelope::mutable_group_user_add() {
  if (!has_group_user_add()) {
    clear_payload();
    set_has_group_user_add();
    payload_.group_user_add_ = new ::server::TGroupUserAdd;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_user_add)
  return payload_.group_user_add_;
}
inline ::server::TGroupUserAdd* Envelope::release_group_user_add() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_user_add)
  if (has_group_user_add()) {
    clear_has_payload();
    ::server::TGroupUserAdd* temp = payload_.group_user_add_;
    payload_.group_user_add_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_user_add(::server::TGroupUserAdd* group_user_add) {
  clear_payload();
  if (group_user_add) {
    set_has_group_user_add();
    payload_.group_user_add_ = group_user_add;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_user_add)
}

// optional .server.TGroupUserKick group_user_kick = 27;
inline bool Envelope::has_group_user_kick() const {
  return payload_case() == kGroupUserKick;
}
inline void Envelope::set_has_group_user_kick() {
  _oneof_case_[0] = kGroupUserKick;
}
inline void Envelope::clear_group_user_kick() {
  if (has_group_user_kick()) {
    delete payload_.group_user_kick_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupUserKick& Envelope::group_user_kick() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_user_kick)
  return has_group_user_kick()
      ? *payload_.group_user_kick_
      : ::server::TGroupUserKick::default_instance();
}
inline ::server::TGroupUserKick* Envelope::mutable_group_user_kick() {
  if (!has_group_user_kick()) {
    clear_payload();
    set_has_group_user_kick();
    payload_.group_user_kick_ = new ::server::TGroupUserKick;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_user_kick)
  return payload_.group_user_kick_;
}
inline ::server::TGroupUserKick* Envelope::release_group_user_kick() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_user_kick)
  if (has_group_user_kick()) {
    clear_has_payload();
    ::server::TGroupUserKick* temp = payload_.group_user_kick_;
    payload_.group_user_kick_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_user_kick(::server::TGroupUserKick* group_user_kick) {
  clear_payload();
  if (group_user_kick) {
    set_has_group_user_kick();
    payload_.group_user_kick_ = group_user_kick;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_user_kick)
}

// optional .server.TGroupUserPromote group_user_promote = 28;
inline bool Envelope::has_group_user_promote() const {
  return payload_case() == kGroupUserPromote;
}
inline void Envelope::set_has_group_user_promote() {
  _oneof_case_[0] = kGroupUserPromote;
}
inline void Envelope::clear_group_user_promote() {
  if (has_group_user_promote()) {
    delete payload_.group_user_promote_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupUserPromote& Envelope::group_user_promote() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_user_promote)
  return has_group_user_promote()
      ? *payload_.group_user_promote_
      : ::server::TGroupUserPromote::default_instance();
}
inline ::server::TGroupUserPromote* Envelope::mutable_group_user_promote() {
  if (!has_group_user_promote()) {
    clear_payload();
    set_has_group_user_promote();
    payload_.group_user_promote_ = new ::server::TGroupUserPromote;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_user_promote)
  return payload_.group_user_promote_;
}
inline ::server::TGroupUserPromote* Envelope::release_group_user_promote() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_user_promote)
  if (has_group_user_promote()) {
    clear_has_payload();
    ::server::TGroupUserPromote* temp = payload_.group_user_promote_;
    payload_.group_user_promote_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_user_promote(::server::TGroupUserPromote* group_user_promote) {
  clear_payload();
  if (group_user_promote) {
    set_has_group_user_promote();
    payload_.group_user_promote_ = group_user_promote;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_user_promote)
}

// optional .server.TGroup group = 29;
inline bool Envelope::has_group() const {
  return payload_case() == kGroup;
}
inline void Envelope::set_has_group() {
  _oneof_case_[0] = kGroup;
}
inline void Envelope::clear_group() {
  if (has_group()) {
    delete payload_.group_;
    clear_has_payload();
  }
}
inline  const ::server::TGroup& Envelope::group() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group)
  return has_group()
      ? *payload_.group_
      : ::server::TGroup::default_instance();
}
inline ::server::TGroup* Envelope::mutable_group() {
  if (!has_group()) {
    clear_payload();
    set_has_group();
    payload_.group_ = new ::server::TGroup;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group)
  return payload_.group_;
}
inline ::server::TGroup* Envelope::release_group() {
  // @@protoc_insertion_point(field_release:server.Envelope.group)
  if (has_group()) {
    clear_has_payload();
    ::server::TGroup* temp = payload_.group_;
    payload_.group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group(::server::TGroup* group) {
  clear_payload();
  if (group) {
    set_has_group();
    payload_.group_ = group;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group)
}

// optional .server.TGroups groups = 30;
inline bool Envelope::has_groups() const {
  return payload_case() == kGroups;
}
inline void Envelope::set_has_groups() {
  _oneof_case_[0] = kGroups;
}
inline void Envelope::clear_groups() {
  if (has_groups()) {
    delete payload_.groups_;
    clear_has_payload();
  }
}
inline  const ::server::TGroups& Envelope::groups() const {
  // @@protoc_insertion_point(field_get:server.Envelope.groups)
  return has_groups()
      ? *payload_.groups_
      : ::server::TGroups::default_instance();
}
inline ::server::TGroups* Envelope::mutable_groups() {
  if (!has_groups()) {
    clear_payload();
    set_has_groups();
    payload_.groups_ = new ::server::TGroups;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.groups)
  return payload_.groups_;
}
inline ::server::TGroups* Envelope::release_groups() {
  // @@protoc_insertion_point(field_release:server.Envelope.groups)
  if (has_groups()) {
    clear_has_payload();
    ::server::TGroups* temp = payload_.groups_;
    payload_.groups_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_groups(::server::TGroups* groups) {
  clear_payload();
  if (groups) {
    set_has_groups();
    payload_.groups_ = groups;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.groups)
}

// optional .server.TGroupUsers group_users = 31;
inline bool Envelope::has_group_users() const {
  return payload_case() == kGroupUsers;
}
inline void Envelope::set_has_group_users() {
  _oneof_case_[0] = kGroupUsers;
}
inline void Envelope::clear_group_users() {
  if (has_group_users()) {
    delete payload_.group_users_;
    clear_has_payload();
  }
}
inline  const ::server::TGroupUsers& Envelope::group_users() const {
  // @@protoc_insertion_point(field_get:server.Envelope.group_users)
  return has_group_users()
      ? *payload_.group_users_
      : ::server::TGroupUsers::default_instance();
}
inline ::server::TGroupUsers* Envelope::mutable_group_users() {
  if (!has_group_users()) {
    clear_payload();
    set_has_group_users();
    payload_.group_users_ = new ::server::TGroupUsers;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.group_users)
  return payload_.group_users_;
}
inline ::server::TGroupUsers* Envelope::release_group_users() {
  // @@protoc_insertion_point(field_release:server.Envelope.group_users)
  if (has_group_users()) {
    clear_has_payload();
    ::server::TGroupUsers* temp = payload_.group_users_;
    payload_.group_users_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_group_users(::server::TGroupUsers* group_users) {
  clear_payload();
  if (group_users) {
    set_has_group_users();
    payload_.group_users_ = group_users;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.group_users)
}

// optional .server.TTopicJoin topic_join = 32;
inline bool Envelope::has_topic_join() const {
  return payload_case() == kTopicJoin;
}
inline void Envelope::set_has_topic_join() {
  _oneof_case_[0] = kTopicJoin;
}
inline void Envelope::clear_topic_join() {
  if (has_topic_join()) {
    delete payload_.topic_join_;
    clear_has_payload();
  }
}
inline  const ::server::TTopicJoin& Envelope::topic_join() const {
  // @@protoc_insertion_point(field_get:server.Envelope.topic_join)
  return has_topic_join()
      ? *payload_.topic_join_
      : ::server::TTopicJoin::default_instance();
}
inline ::server::TTopicJoin* Envelope::mutable_topic_join() {
  if (!has_topic_join()) {
    clear_payload();
    set_has_topic_join();
    payload_.topic_join_ = new ::server::TTopicJoin;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.topic_join)
  return payload_.topic_join_;
}
inline ::server::TTopicJoin* Envelope::release_topic_join() {
  // @@protoc_insertion_point(field_release:server.Envelope.topic_join)
  if (has_topic_join()) {
    clear_has_payload();
    ::server::TTopicJoin* temp = payload_.topic_join_;
    payload_.topic_join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_topic_join(::server::TTopicJoin* topic_join) {
  clear_payload();
  if (topic_join) {
    set_has_topic_join();
    payload_.topic_join_ = topic_join;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.topic_join)
}

// optional .server.TTopicLeave topic_leave = 33;
inline bool Envelope::has_topic_leave() const {
  return payload_case() == kTopicLeave;
}
inline void Envelope::set_has_topic_leave() {
  _oneof_case_[0] = kTopicLeave;
}
inline void Envelope::clear_topic_leave() {
  if (has_topic_leave()) {
    delete payload_.topic_leave_;
    clear_has_payload();
  }
}
inline  const ::server::TTopicLeave& Envelope::topic_leave() const {
  // @@protoc_insertion_point(field_get:server.Envelope.topic_leave)
  return has_topic_leave()
      ? *payload_.topic_leave_
      : ::server::TTopicLeave::default_instance();
}
inline ::server::TTopicLeave* Envelope::mutable_topic_leave() {
  if (!has_topic_leave()) {
    clear_payload();
    set_has_topic_leave();
    payload_.topic_leave_ = new ::server::TTopicLeave;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.topic_leave)
  return payload_.topic_leave_;
}
inline ::server::TTopicLeave* Envelope::release_topic_leave() {
  // @@protoc_insertion_point(field_release:server.Envelope.topic_leave)
  if (has_topic_leave()) {
    clear_has_payload();
    ::server::TTopicLeave* temp = payload_.topic_leave_;
    payload_.topic_leave_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_topic_leave(::server::TTopicLeave* topic_leave) {
  clear_payload();
  if (topic_leave) {
    set_has_topic_leave();
    payload_.topic_leave_ = topic_leave;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.topic_leave)
}

// optional .server.TTopicMessageSend topic_message_send = 34;
inline bool Envelope::has_topic_message_send() const {
  return payload_case() == kTopicMessageSend;
}
inline void Envelope::set_has_topic_message_send() {
  _oneof_case_[0] = kTopicMessageSend;
}
inline void Envelope::clear_topic_message_send() {
  if (has_topic_message_send()) {
    delete payload_.topic_message_send_;
    clear_has_payload();
  }
}
inline  const ::server::TTopicMessageSend& Envelope::topic_message_send() const {
  // @@protoc_insertion_point(field_get:server.Envelope.topic_message_send)
  return has_topic_message_send()
      ? *payload_.topic_message_send_
      : ::server::TTopicMessageSend::default_instance();
}
inline ::server::TTopicMessageSend* Envelope::mutable_topic_message_send() {
  if (!has_topic_message_send()) {
    clear_payload();
    set_has_topic_message_send();
    payload_.topic_message_send_ = new ::server::TTopicMessageSend;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.topic_message_send)
  return payload_.topic_message_send_;
}
inline ::server::TTopicMessageSend* Envelope::release_topic_message_send() {
  // @@protoc_insertion_point(field_release:server.Envelope.topic_message_send)
  if (has_topic_message_send()) {
    clear_has_payload();
    ::server::TTopicMessageSend* temp = payload_.topic_message_send_;
    payload_.topic_message_send_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_topic_message_send(::server::TTopicMessageSend* topic_message_send) {
  clear_payload();
  if (topic_message_send) {
    set_has_topic_message_send();
    payload_.topic_message_send_ = topic_message_send;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.topic_message_send)
}

// optional .server.TTopicMessagesList topic_messages_list = 35;
inline bool Envelope::has_topic_messages_list() const {
  return payload_case() == kTopicMessagesList;
}
inline void Envelope::set_has_topic_messages_list() {
  _oneof_case_[0] = kTopicMessagesList;
}
inline void Envelope::clear_topic_messages_list() {
  if (has_topic_messages_list()) {
    delete payload_.topic_messages_list_;
    clear_has_payload();
  }
}
inline  const ::server::TTopicMessagesList& Envelope::topic_messages_list() const {
  // @@protoc_insertion_point(field_get:server.Envelope.topic_messages_list)
  return has_topic_messages_list()
      ? *payload_.topic_messages_list_
      : ::server::TTopicMessagesList::default_instance();
}
inline ::server::TTopicMessagesList* Envelope::mutable_topic_messages_list() {
  if (!has_topic_messages_list()) {
    clear_payload();
    set_has_topic_messages_list();
    payload_.topic_messages_list_ = new ::server::TTopicMessagesList;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.topic_messages_list)
  return payload_.topic_messages_list_;
}
inline ::server::TTopicMessagesList* Envelope::release_topic_messages_list() {
  // @@protoc_insertion_point(field_release:server.Envelope.topic_messages_list)
  if (has_topic_messages_list()) {
    clear_has_payload();
    ::server::TTopicMessagesList* temp = payload_.topic_messages_list_;
    payload_.topic_messages_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_topic_messages_list(::server::TTopicMessagesList* topic_messages_list) {
  clear_payload();
  if (topic_messages_list) {
    set_has_topic_messages_list();
    payload_.topic_messages_list_ = topic_messages_list;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.topic_messages_list)
}

// optional .server.TTopic topic = 36;
inline bool Envelope::has_topic() const {
  return payload_case() == kTopic;
}
inline void Envelope::set_has_topic() {
  _oneof_case_[0] = kTopic;
}
inline void Envelope::clear_topic() {
  if (has_topic()) {
    delete payload_.topic_;
    clear_has_payload();
  }
}
inline  const ::server::TTopic& Envelope::topic() const {
  // @@protoc_insertion_point(field_get:server.Envelope.topic)
  return has_topic()
      ? *payload_.topic_
      : ::server::TTopic::default_instance();
}
inline ::server::TTopic* Envelope::mutable_topic() {
  if (!has_topic()) {
    clear_payload();
    set_has_topic();
    payload_.topic_ = new ::server::TTopic;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.topic)
  return payload_.topic_;
}
inline ::server::TTopic* Envelope::release_topic() {
  // @@protoc_insertion_point(field_release:server.Envelope.topic)
  if (has_topic()) {
    clear_has_payload();
    ::server::TTopic* temp = payload_.topic_;
    payload_.topic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_topic(::server::TTopic* topic) {
  clear_payload();
  if (topic) {
    set_has_topic();
    payload_.topic_ = topic;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.topic)
}

// optional .server.TTopicMessageAck topic_message_ack = 37;
inline bool Envelope::has_topic_message_ack() const {
  return payload_case() == kTopicMessageAck;
}
inline void Envelope::set_has_topic_message_ack() {
  _oneof_case_[0] = kTopicMessageAck;
}
inline void Envelope::clear_topic_message_ack() {
  if (has_topic_message_ack()) {
    delete payload_.topic_message_ack_;
    clear_has_payload();
  }
}
inline  const ::server::TTopicMessageAck& Envelope::topic_message_ack() const {
  // @@protoc_insertion_point(field_get:server.Envelope.topic_message_ack)
  return has_topic_message_ack()
      ? *payload_.topic_message_ack_
      : ::server::TTopicMessageAck::default_instance();
}
inline ::server::TTopicMessageAck* Envelope::mutable_topic_message_ack() {
  if (!has_topic_message_ack()) {
    clear_payload();
    set_has_topic_message_ack();
    payload_.topic_message_ack_ = new ::server::TTopicMessageAck;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.topic_message_ack)
  return payload_.topic_message_ack_;
}
inline ::server::TTopicMessageAck* Envelope::release_topic_message_ack() {
  // @@protoc_insertion_point(field_release:server.Envelope.topic_message_ack)
  if (has_topic_message_ack()) {
    clear_has_payload();
    ::server::TTopicMessageAck* temp = payload_.topic_message_ack_;
    payload_.topic_message_ack_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_topic_message_ack(::server::TTopicMessageAck* topic_message_ack) {
  clear_payload();
  if (topic_message_ack) {
    set_has_topic_message_ack();
    payload_.topic_message_ack_ = topic_message_ack;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.topic_message_ack)
}

// optional .server.TopicMessage topic_message = 38;
inline bool Envelope::has_topic_message() const {
  return payload_case() == kTopicMessage;
}
inline void Envelope::set_has_topic_message() {
  _oneof_case_[0] = kTopicMessage;
}
inline void Envelope::clear_topic_message() {
  if (has_topic_message()) {
    delete payload_.topic_message_;
    clear_has_payload();
  }
}
inline  const ::server::TopicMessage& Envelope::topic_message() const {
  // @@protoc_insertion_point(field_get:server.Envelope.topic_message)
  return has_topic_message()
      ? *payload_.topic_message_
      : ::server::TopicMessage::default_instance();
}
inline ::server::TopicMessage* Envelope::mutable_topic_message() {
  if (!has_topic_message()) {
    clear_payload();
    set_has_topic_message();
    payload_.topic_message_ = new ::server::TopicMessage;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.topic_message)
  return payload_.topic_message_;
}
inline ::server::TopicMessage* Envelope::release_topic_message() {
  // @@protoc_insertion_point(field_release:server.Envelope.topic_message)
  if (has_topic_message()) {
    clear_has_payload();
    ::server::TopicMessage* temp = payload_.topic_message_;
    payload_.topic_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_topic_message(::server::TopicMessage* topic_message) {
  clear_payload();
  if (topic_message) {
    set_has_topic_message();
    payload_.topic_message_ = topic_message;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.topic_message)
}

// optional .server.TTopicMessages topic_messages = 39;
inline bool Envelope::has_topic_messages() const {
  return payload_case() == kTopicMessages;
}
inline void Envelope::set_has_topic_messages() {
  _oneof_case_[0] = kTopicMessages;
}
inline void Envelope::clear_topic_messages() {
  if (has_topic_messages()) {
    delete payload_.topic_messages_;
    clear_has_payload();
  }
}
inline  const ::server::TTopicMessages& Envelope::topic_messages() const {
  // @@protoc_insertion_point(field_get:server.Envelope.topic_messages)
  return has_topic_messages()
      ? *payload_.topic_messages_
      : ::server::TTopicMessages::default_instance();
}
inline ::server::TTopicMessages* Envelope::mutable_topic_messages() {
  if (!has_topic_messages()) {
    clear_payload();
    set_has_topic_messages();
    payload_.topic_messages_ = new ::server::TTopicMessages;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.topic_messages)
  return payload_.topic_messages_;
}
inline ::server::TTopicMessages* Envelope::release_topic_messages() {
  // @@protoc_insertion_point(field_release:server.Envelope.topic_messages)
  if (has_topic_messages()) {
    clear_has_payload();
    ::server::TTopicMessages* temp = payload_.topic_messages_;
    payload_.topic_messages_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_topic_messages(::server::TTopicMessages* topic_messages) {
  clear_payload();
  if (topic_messages) {
    set_has_topic_messages();
    payload_.topic_messages_ = topic_messages;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.topic_messages)
}

// optional .server.TopicPresence topic_presence = 40;
inline bool Envelope::has_topic_presence() const {
  return payload_case() == kTopicPresence;
}
inline void Envelope::set_has_topic_presence() {
  _oneof_case_[0] = kTopicPresence;
}
inline void Envelope::clear_topic_presence() {
  if (has_topic_presence()) {
    delete payload_.topic_presence_;
    clear_has_payload();
  }
}
inline  const ::server::TopicPresence& Envelope::topic_presence() const {
  // @@protoc_insertion_point(field_get:server.Envelope.topic_presence)
  return has_topic_presence()
      ? *payload_.topic_presence_
      : ::server::TopicPresence::default_instance();
}
inline ::server::TopicPresence* Envelope::mutable_topic_presence() {
  if (!has_topic_presence()) {
    clear_payload();
    set_has_topic_presence();
    payload_.topic_presence_ = new ::server::TopicPresence;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.topic_presence)
  return payload_.topic_presence_;
}
inline ::server::TopicPresence* Envelope::release_topic_presence() {
  // @@protoc_insertion_point(field_release:server.Envelope.topic_presence)
  if (has_topic_presence()) {
    clear_has_payload();
    ::server::TopicPresence* temp = payload_.topic_presence_;
    payload_.topic_presence_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_topic_presence(::server::TopicPresence* topic_presence) {
  clear_payload();
  if (topic_presence) {
    set_has_topic_presence();
    payload_.topic_presence_ = topic_presence;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.topic_presence)
}

// optional .server.TMatchCreate match_create = 41;
inline bool Envelope::has_match_create() const {
  return payload_case() == kMatchCreate;
}
inline void Envelope::set_has_match_create() {
  _oneof_case_[0] = kMatchCreate;
}
inline void Envelope::clear_match_create() {
  if (has_match_create()) {
    delete payload_.match_create_;
    clear_has_payload();
  }
}
inline  const ::server::TMatchCreate& Envelope::match_create() const {
  // @@protoc_insertion_point(field_get:server.Envelope.match_create)
  return has_match_create()
      ? *payload_.match_create_
      : ::server::TMatchCreate::default_instance();
}
inline ::server::TMatchCreate* Envelope::mutable_match_create() {
  if (!has_match_create()) {
    clear_payload();
    set_has_match_create();
    payload_.match_create_ = new ::server::TMatchCreate;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.match_create)
  return payload_.match_create_;
}
inline ::server::TMatchCreate* Envelope::release_match_create() {
  // @@protoc_insertion_point(field_release:server.Envelope.match_create)
  if (has_match_create()) {
    clear_has_payload();
    ::server::TMatchCreate* temp = payload_.match_create_;
    payload_.match_create_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_match_create(::server::TMatchCreate* match_create) {
  clear_payload();
  if (match_create) {
    set_has_match_create();
    payload_.match_create_ = match_create;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.match_create)
}

// optional .server.TMatchJoin match_join = 42;
inline bool Envelope::has_match_join() const {
  return payload_case() == kMatchJoin;
}
inline void Envelope::set_has_match_join() {
  _oneof_case_[0] = kMatchJoin;
}
inline void Envelope::clear_match_join() {
  if (has_match_join()) {
    delete payload_.match_join_;
    clear_has_payload();
  }
}
inline  const ::server::TMatchJoin& Envelope::match_join() const {
  // @@protoc_insertion_point(field_get:server.Envelope.match_join)
  return has_match_join()
      ? *payload_.match_join_
      : ::server::TMatchJoin::default_instance();
}
inline ::server::TMatchJoin* Envelope::mutable_match_join() {
  if (!has_match_join()) {
    clear_payload();
    set_has_match_join();
    payload_.match_join_ = new ::server::TMatchJoin;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.match_join)
  return payload_.match_join_;
}
inline ::server::TMatchJoin* Envelope::release_match_join() {
  // @@protoc_insertion_point(field_release:server.Envelope.match_join)
  if (has_match_join()) {
    clear_has_payload();
    ::server::TMatchJoin* temp = payload_.match_join_;
    payload_.match_join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_match_join(::server::TMatchJoin* match_join) {
  clear_payload();
  if (match_join) {
    set_has_match_join();
    payload_.match_join_ = match_join;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.match_join)
}

// optional .server.TMatchLeave match_leave = 43;
inline bool Envelope::has_match_leave() const {
  return payload_case() == kMatchLeave;
}
inline void Envelope::set_has_match_leave() {
  _oneof_case_[0] = kMatchLeave;
}
inline void Envelope::clear_match_leave() {
  if (has_match_leave()) {
    delete payload_.match_leave_;
    clear_has_payload();
  }
}
inline  const ::server::TMatchLeave& Envelope::match_leave() const {
  // @@protoc_insertion_point(field_get:server.Envelope.match_leave)
  return has_match_leave()
      ? *payload_.match_leave_
      : ::server::TMatchLeave::default_instance();
}
inline ::server::TMatchLeave* Envelope::mutable_match_leave() {
  if (!has_match_leave()) {
    clear_payload();
    set_has_match_leave();
    payload_.match_leave_ = new ::server::TMatchLeave;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.match_leave)
  return payload_.match_leave_;
}
inline ::server::TMatchLeave* Envelope::release_match_leave() {
  // @@protoc_insertion_point(field_release:server.Envelope.match_leave)
  if (has_match_leave()) {
    clear_has_payload();
    ::server::TMatchLeave* temp = payload_.match_leave_;
    payload_.match_leave_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_match_leave(::server::TMatchLeave* match_leave) {
  clear_payload();
  if (match_leave) {
    set_has_match_leave();
    payload_.match_leave_ = match_leave;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.match_leave)
}

// optional .server.MatchDataSend match_data_send = 44;
inline bool Envelope::has_match_data_send() const {
  return payload_case() == kMatchDataSend;
}
inline void Envelope::set_has_match_data_send() {
  _oneof_case_[0] = kMatchDataSend;
}
inline void Envelope::clear_match_data_send() {
  if (has_match_data_send()) {
    delete payload_.match_data_send_;
    clear_has_payload();
  }
}
inline  const ::server::MatchDataSend& Envelope::match_data_send() const {
  // @@protoc_insertion_point(field_get:server.Envelope.match_data_send)
  return has_match_data_send()
      ? *payload_.match_data_send_
      : ::server::MatchDataSend::default_instance();
}
inline ::server::MatchDataSend* Envelope::mutable_match_data_send() {
  if (!has_match_data_send()) {
    clear_payload();
    set_has_match_data_send();
    payload_.match_data_send_ = new ::server::MatchDataSend;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.match_data_send)
  return payload_.match_data_send_;
}
inline ::server::MatchDataSend* Envelope::release_match_data_send() {
  // @@protoc_insertion_point(field_release:server.Envelope.match_data_send)
  if (has_match_data_send()) {
    clear_has_payload();
    ::server::MatchDataSend* temp = payload_.match_data_send_;
    payload_.match_data_send_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_match_data_send(::server::MatchDataSend* match_data_send) {
  clear_payload();
  if (match_data_send) {
    set_has_match_data_send();
    payload_.match_data_send_ = match_data_send;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.match_data_send)
}

// optional .server.TMatch match = 45;
inline bool Envelope::has_match() const {
  return payload_case() == kMatch;
}
inline void Envelope::set_has_match() {
  _oneof_case_[0] = kMatch;
}
inline void Envelope::clear_match() {
  if (has_match()) {
    delete payload_.match_;
    clear_has_payload();
  }
}
inline  const ::server::TMatch& Envelope::match() const {
  // @@protoc_insertion_point(field_get:server.Envelope.match)
  return has_match()
      ? *payload_.match_
      : ::server::TMatch::default_instance();
}
inline ::server::TMatch* Envelope::mutable_match() {
  if (!has_match()) {
    clear_payload();
    set_has_match();
    payload_.match_ = new ::server::TMatch;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.match)
  return payload_.match_;
}
inline ::server::TMatch* Envelope::release_match() {
  // @@protoc_insertion_point(field_release:server.Envelope.match)
  if (has_match()) {
    clear_has_payload();
    ::server::TMatch* temp = payload_.match_;
    payload_.match_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_match(::server::TMatch* match) {
  clear_payload();
  if (match) {
    set_has_match();
    payload_.match_ = match;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.match)
}

// optional .server.MatchData match_data = 46;
inline bool Envelope::has_match_data() const {
  return payload_case() == kMatchData;
}
inline void Envelope::set_has_match_data() {
  _oneof_case_[0] = kMatchData;
}
inline void Envelope::clear_match_data() {
  if (has_match_data()) {
    delete payload_.match_data_;
    clear_has_payload();
  }
}
inline  const ::server::MatchData& Envelope::match_data() const {
  // @@protoc_insertion_point(field_get:server.Envelope.match_data)
  return has_match_data()
      ? *payload_.match_data_
      : ::server::MatchData::default_instance();
}
inline ::server::MatchData* Envelope::mutable_match_data() {
  if (!has_match_data()) {
    clear_payload();
    set_has_match_data();
    payload_.match_data_ = new ::server::MatchData;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.match_data)
  return payload_.match_data_;
}
inline ::server::MatchData* Envelope::release_match_data() {
  // @@protoc_insertion_point(field_release:server.Envelope.match_data)
  if (has_match_data()) {
    clear_has_payload();
    ::server::MatchData* temp = payload_.match_data_;
    payload_.match_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_match_data(::server::MatchData* match_data) {
  clear_payload();
  if (match_data) {
    set_has_match_data();
    payload_.match_data_ = match_data;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.match_data)
}

// optional .server.MatchPresence match_presence = 47;
inline bool Envelope::has_match_presence() const {
  return payload_case() == kMatchPresence;
}
inline void Envelope::set_has_match_presence() {
  _oneof_case_[0] = kMatchPresence;
}
inline void Envelope::clear_match_presence() {
  if (has_match_presence()) {
    delete payload_.match_presence_;
    clear_has_payload();
  }
}
inline  const ::server::MatchPresence& Envelope::match_presence() const {
  // @@protoc_insertion_point(field_get:server.Envelope.match_presence)
  return has_match_presence()
      ? *payload_.match_presence_
      : ::server::MatchPresence::default_instance();
}
inline ::server::MatchPresence* Envelope::mutable_match_presence() {
  if (!has_match_presence()) {
    clear_payload();
    set_has_match_presence();
    payload_.match_presence_ = new ::server::MatchPresence;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.match_presence)
  return payload_.match_presence_;
}
inline ::server::MatchPresence* Envelope::release_match_presence() {
  // @@protoc_insertion_point(field_release:server.Envelope.match_presence)
  if (has_match_presence()) {
    clear_has_payload();
    ::server::MatchPresence* temp = payload_.match_presence_;
    payload_.match_presence_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_match_presence(::server::MatchPresence* match_presence) {
  clear_payload();
  if (match_presence) {
    set_has_match_presence();
    payload_.match_presence_ = match_presence;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.match_presence)
}

// optional .server.TStorageFetch storage_fetch = 48;
inline bool Envelope::has_storage_fetch() const {
  return payload_case() == kStorageFetch;
}
inline void Envelope::set_has_storage_fetch() {
  _oneof_case_[0] = kStorageFetch;
}
inline void Envelope::clear_storage_fetch() {
  if (has_storage_fetch()) {
    delete payload_.storage_fetch_;
    clear_has_payload();
  }
}
inline  const ::server::TStorageFetch& Envelope::storage_fetch() const {
  // @@protoc_insertion_point(field_get:server.Envelope.storage_fetch)
  return has_storage_fetch()
      ? *payload_.storage_fetch_
      : ::server::TStorageFetch::default_instance();
}
inline ::server::TStorageFetch* Envelope::mutable_storage_fetch() {
  if (!has_storage_fetch()) {
    clear_payload();
    set_has_storage_fetch();
    payload_.storage_fetch_ = new ::server::TStorageFetch;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.storage_fetch)
  return payload_.storage_fetch_;
}
inline ::server::TStorageFetch* Envelope::release_storage_fetch() {
  // @@protoc_insertion_point(field_release:server.Envelope.storage_fetch)
  if (has_storage_fetch()) {
    clear_has_payload();
    ::server::TStorageFetch* temp = payload_.storage_fetch_;
    payload_.storage_fetch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_storage_fetch(::server::TStorageFetch* storage_fetch) {
  clear_payload();
  if (storage_fetch) {
    set_has_storage_fetch();
    payload_.storage_fetch_ = storage_fetch;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.storage_fetch)
}

// optional .server.TStorageWrite storage_write = 49;
inline bool Envelope::has_storage_write() const {
  return payload_case() == kStorageWrite;
}
inline void Envelope::set_has_storage_write() {
  _oneof_case_[0] = kStorageWrite;
}
inline void Envelope::clear_storage_write() {
  if (has_storage_write()) {
    delete payload_.storage_write_;
    clear_has_payload();
  }
}
inline  const ::server::TStorageWrite& Envelope::storage_write() const {
  // @@protoc_insertion_point(field_get:server.Envelope.storage_write)
  return has_storage_write()
      ? *payload_.storage_write_
      : ::server::TStorageWrite::default_instance();
}
inline ::server::TStorageWrite* Envelope::mutable_storage_write() {
  if (!has_storage_write()) {
    clear_payload();
    set_has_storage_write();
    payload_.storage_write_ = new ::server::TStorageWrite;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.storage_write)
  return payload_.storage_write_;
}
inline ::server::TStorageWrite* Envelope::release_storage_write() {
  // @@protoc_insertion_point(field_release:server.Envelope.storage_write)
  if (has_storage_write()) {
    clear_has_payload();
    ::server::TStorageWrite* temp = payload_.storage_write_;
    payload_.storage_write_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_storage_write(::server::TStorageWrite* storage_write) {
  clear_payload();
  if (storage_write) {
    set_has_storage_write();
    payload_.storage_write_ = storage_write;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.storage_write)
}

// optional .server.TStorageRemove storage_remove = 50;
inline bool Envelope::has_storage_remove() const {
  return payload_case() == kStorageRemove;
}
inline void Envelope::set_has_storage_remove() {
  _oneof_case_[0] = kStorageRemove;
}
inline void Envelope::clear_storage_remove() {
  if (has_storage_remove()) {
    delete payload_.storage_remove_;
    clear_has_payload();
  }
}
inline  const ::server::TStorageRemove& Envelope::storage_remove() const {
  // @@protoc_insertion_point(field_get:server.Envelope.storage_remove)
  return has_storage_remove()
      ? *payload_.storage_remove_
      : ::server::TStorageRemove::default_instance();
}
inline ::server::TStorageRemove* Envelope::mutable_storage_remove() {
  if (!has_storage_remove()) {
    clear_payload();
    set_has_storage_remove();
    payload_.storage_remove_ = new ::server::TStorageRemove;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.storage_remove)
  return payload_.storage_remove_;
}
inline ::server::TStorageRemove* Envelope::release_storage_remove() {
  // @@protoc_insertion_point(field_release:server.Envelope.storage_remove)
  if (has_storage_remove()) {
    clear_has_payload();
    ::server::TStorageRemove* temp = payload_.storage_remove_;
    payload_.storage_remove_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_storage_remove(::server::TStorageRemove* storage_remove) {
  clear_payload();
  if (storage_remove) {
    set_has_storage_remove();
    payload_.storage_remove_ = storage_remove;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.storage_remove)
}

// optional .server.TStorageData storage_data = 51;
inline bool Envelope::has_storage_data() const {
  return payload_case() == kStorageData;
}
inline void Envelope::set_has_storage_data() {
  _oneof_case_[0] = kStorageData;
}
inline void Envelope::clear_storage_data() {
  if (has_storage_data()) {
    delete payload_.storage_data_;
    clear_has_payload();
  }
}
inline  const ::server::TStorageData& Envelope::storage_data() const {
  // @@protoc_insertion_point(field_get:server.Envelope.storage_data)
  return has_storage_data()
      ? *payload_.storage_data_
      : ::server::TStorageData::default_instance();
}
inline ::server::TStorageData* Envelope::mutable_storage_data() {
  if (!has_storage_data()) {
    clear_payload();
    set_has_storage_data();
    payload_.storage_data_ = new ::server::TStorageData;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.storage_data)
  return payload_.storage_data_;
}
inline ::server::TStorageData* Envelope::release_storage_data() {
  // @@protoc_insertion_point(field_release:server.Envelope.storage_data)
  if (has_storage_data()) {
    clear_has_payload();
    ::server::TStorageData* temp = payload_.storage_data_;
    payload_.storage_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_storage_data(::server::TStorageData* storage_data) {
  clear_payload();
  if (storage_data) {
    set_has_storage_data();
    payload_.storage_data_ = storage_data;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.storage_data)
}

// optional .server.TStorageKey storage_key = 52;
inline bool Envelope::has_storage_key() const {
  return payload_case() == kStorageKey;
}
inline void Envelope::set_has_storage_key() {
  _oneof_case_[0] = kStorageKey;
}
inline void Envelope::clear_storage_key() {
  if (has_storage_key()) {
    delete payload_.storage_key_;
    clear_has_payload();
  }
}
inline  const ::server::TStorageKey& Envelope::storage_key() const {
  // @@protoc_insertion_point(field_get:server.Envelope.storage_key)
  return has_storage_key()
      ? *payload_.storage_key_
      : ::server::TStorageKey::default_instance();
}
inline ::server::TStorageKey* Envelope::mutable_storage_key() {
  if (!has_storage_key()) {
    clear_payload();
    set_has_storage_key();
    payload_.storage_key_ = new ::server::TStorageKey;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.storage_key)
  return payload_.storage_key_;
}
inline ::server::TStorageKey* Envelope::release_storage_key() {
  // @@protoc_insertion_point(field_release:server.Envelope.storage_key)
  if (has_storage_key()) {
    clear_has_payload();
    ::server::TStorageKey* temp = payload_.storage_key_;
    payload_.storage_key_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_storage_key(::server::TStorageKey* storage_key) {
  clear_payload();
  if (storage_key) {
    set_has_storage_key();
    payload_.storage_key_ = storage_key;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.storage_key)
}

// optional .server.TLeaderboardsList leaderboards_list = 53;
inline bool Envelope::has_leaderboards_list() const {
  return payload_case() == kLeaderboardsList;
}
inline void Envelope::set_has_leaderboards_list() {
  _oneof_case_[0] = kLeaderboardsList;
}
inline void Envelope::clear_leaderboards_list() {
  if (has_leaderboards_list()) {
    delete payload_.leaderboards_list_;
    clear_has_payload();
  }
}
inline  const ::server::TLeaderboardsList& Envelope::leaderboards_list() const {
  // @@protoc_insertion_point(field_get:server.Envelope.leaderboards_list)
  return has_leaderboards_list()
      ? *payload_.leaderboards_list_
      : ::server::TLeaderboardsList::default_instance();
}
inline ::server::TLeaderboardsList* Envelope::mutable_leaderboards_list() {
  if (!has_leaderboards_list()) {
    clear_payload();
    set_has_leaderboards_list();
    payload_.leaderboards_list_ = new ::server::TLeaderboardsList;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.leaderboards_list)
  return payload_.leaderboards_list_;
}
inline ::server::TLeaderboardsList* Envelope::release_leaderboards_list() {
  // @@protoc_insertion_point(field_release:server.Envelope.leaderboards_list)
  if (has_leaderboards_list()) {
    clear_has_payload();
    ::server::TLeaderboardsList* temp = payload_.leaderboards_list_;
    payload_.leaderboards_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_leaderboards_list(::server::TLeaderboardsList* leaderboards_list) {
  clear_payload();
  if (leaderboards_list) {
    set_has_leaderboards_list();
    payload_.leaderboards_list_ = leaderboards_list;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.leaderboards_list)
}

// optional .server.TLeaderboardRecordWrite leaderboard_record_write = 54;
inline bool Envelope::has_leaderboard_record_write() const {
  return payload_case() == kLeaderboardRecordWrite;
}
inline void Envelope::set_has_leaderboard_record_write() {
  _oneof_case_[0] = kLeaderboardRecordWrite;
}
inline void Envelope::clear_leaderboard_record_write() {
  if (has_leaderboard_record_write()) {
    delete payload_.leaderboard_record_write_;
    clear_has_payload();
  }
}
inline  const ::server::TLeaderboardRecordWrite& Envelope::leaderboard_record_write() const {
  // @@protoc_insertion_point(field_get:server.Envelope.leaderboard_record_write)
  return has_leaderboard_record_write()
      ? *payload_.leaderboard_record_write_
      : ::server::TLeaderboardRecordWrite::default_instance();
}
inline ::server::TLeaderboardRecordWrite* Envelope::mutable_leaderboard_record_write() {
  if (!has_leaderboard_record_write()) {
    clear_payload();
    set_has_leaderboard_record_write();
    payload_.leaderboard_record_write_ = new ::server::TLeaderboardRecordWrite;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.leaderboard_record_write)
  return payload_.leaderboard_record_write_;
}
inline ::server::TLeaderboardRecordWrite* Envelope::release_leaderboard_record_write() {
  // @@protoc_insertion_point(field_release:server.Envelope.leaderboard_record_write)
  if (has_leaderboard_record_write()) {
    clear_has_payload();
    ::server::TLeaderboardRecordWrite* temp = payload_.leaderboard_record_write_;
    payload_.leaderboard_record_write_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_leaderboard_record_write(::server::TLeaderboardRecordWrite* leaderboard_record_write) {
  clear_payload();
  if (leaderboard_record_write) {
    set_has_leaderboard_record_write();
    payload_.leaderboard_record_write_ = leaderboard_record_write;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.leaderboard_record_write)
}

// optional .server.TLeaderboardRecordsFetch leaderboard_records_fetch = 55;
inline bool Envelope::has_leaderboard_records_fetch() const {
  return payload_case() == kLeaderboardRecordsFetch;
}
inline void Envelope::set_has_leaderboard_records_fetch() {
  _oneof_case_[0] = kLeaderboardRecordsFetch;
}
inline void Envelope::clear_leaderboard_records_fetch() {
  if (has_leaderboard_records_fetch()) {
    delete payload_.leaderboard_records_fetch_;
    clear_has_payload();
  }
}
inline  const ::server::TLeaderboardRecordsFetch& Envelope::leaderboard_records_fetch() const {
  // @@protoc_insertion_point(field_get:server.Envelope.leaderboard_records_fetch)
  return has_leaderboard_records_fetch()
      ? *payload_.leaderboard_records_fetch_
      : ::server::TLeaderboardRecordsFetch::default_instance();
}
inline ::server::TLeaderboardRecordsFetch* Envelope::mutable_leaderboard_records_fetch() {
  if (!has_leaderboard_records_fetch()) {
    clear_payload();
    set_has_leaderboard_records_fetch();
    payload_.leaderboard_records_fetch_ = new ::server::TLeaderboardRecordsFetch;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.leaderboard_records_fetch)
  return payload_.leaderboard_records_fetch_;
}
inline ::server::TLeaderboardRecordsFetch* Envelope::release_leaderboard_records_fetch() {
  // @@protoc_insertion_point(field_release:server.Envelope.leaderboard_records_fetch)
  if (has_leaderboard_records_fetch()) {
    clear_has_payload();
    ::server::TLeaderboardRecordsFetch* temp = payload_.leaderboard_records_fetch_;
    payload_.leaderboard_records_fetch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_leaderboard_records_fetch(::server::TLeaderboardRecordsFetch* leaderboard_records_fetch) {
  clear_payload();
  if (leaderboard_records_fetch) {
    set_has_leaderboard_records_fetch();
    payload_.leaderboard_records_fetch_ = leaderboard_records_fetch;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.leaderboard_records_fetch)
}

// optional .server.TLeaderboardRecordsList leaderboard_records_list = 56;
inline bool Envelope::has_leaderboard_records_list() const {
  return payload_case() == kLeaderboardRecordsList;
}
inline void Envelope::set_has_leaderboard_records_list() {
  _oneof_case_[0] = kLeaderboardRecordsList;
}
inline void Envelope::clear_leaderboard_records_list() {
  if (has_leaderboard_records_list()) {
    delete payload_.leaderboard_records_list_;
    clear_has_payload();
  }
}
inline  const ::server::TLeaderboardRecordsList& Envelope::leaderboard_records_list() const {
  // @@protoc_insertion_point(field_get:server.Envelope.leaderboard_records_list)
  return has_leaderboard_records_list()
      ? *payload_.leaderboard_records_list_
      : ::server::TLeaderboardRecordsList::default_instance();
}
inline ::server::TLeaderboardRecordsList* Envelope::mutable_leaderboard_records_list() {
  if (!has_leaderboard_records_list()) {
    clear_payload();
    set_has_leaderboard_records_list();
    payload_.leaderboard_records_list_ = new ::server::TLeaderboardRecordsList;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.leaderboard_records_list)
  return payload_.leaderboard_records_list_;
}
inline ::server::TLeaderboardRecordsList* Envelope::release_leaderboard_records_list() {
  // @@protoc_insertion_point(field_release:server.Envelope.leaderboard_records_list)
  if (has_leaderboard_records_list()) {
    clear_has_payload();
    ::server::TLeaderboardRecordsList* temp = payload_.leaderboard_records_list_;
    payload_.leaderboard_records_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_leaderboard_records_list(::server::TLeaderboardRecordsList* leaderboard_records_list) {
  clear_payload();
  if (leaderboard_records_list) {
    set_has_leaderboard_records_list();
    payload_.leaderboard_records_list_ = leaderboard_records_list;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.leaderboard_records_list)
}

// optional .server.TLeaderboards leaderboards = 57;
inline bool Envelope::has_leaderboards() const {
  return payload_case() == kLeaderboards;
}
inline void Envelope::set_has_leaderboards() {
  _oneof_case_[0] = kLeaderboards;
}
inline void Envelope::clear_leaderboards() {
  if (has_leaderboards()) {
    delete payload_.leaderboards_;
    clear_has_payload();
  }
}
inline  const ::server::TLeaderboards& Envelope::leaderboards() const {
  // @@protoc_insertion_point(field_get:server.Envelope.leaderboards)
  return has_leaderboards()
      ? *payload_.leaderboards_
      : ::server::TLeaderboards::default_instance();
}
inline ::server::TLeaderboards* Envelope::mutable_leaderboards() {
  if (!has_leaderboards()) {
    clear_payload();
    set_has_leaderboards();
    payload_.leaderboards_ = new ::server::TLeaderboards;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.leaderboards)
  return payload_.leaderboards_;
}
inline ::server::TLeaderboards* Envelope::release_leaderboards() {
  // @@protoc_insertion_point(field_release:server.Envelope.leaderboards)
  if (has_leaderboards()) {
    clear_has_payload();
    ::server::TLeaderboards* temp = payload_.leaderboards_;
    payload_.leaderboards_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_leaderboards(::server::TLeaderboards* leaderboards) {
  clear_payload();
  if (leaderboards) {
    set_has_leaderboards();
    payload_.leaderboards_ = leaderboards;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.leaderboards)
}

// optional .server.TLeaderboardRecord leaderboard_record = 58;
inline bool Envelope::has_leaderboard_record() const {
  return payload_case() == kLeaderboardRecord;
}
inline void Envelope::set_has_leaderboard_record() {
  _oneof_case_[0] = kLeaderboardRecord;
}
inline void Envelope::clear_leaderboard_record() {
  if (has_leaderboard_record()) {
    delete payload_.leaderboard_record_;
    clear_has_payload();
  }
}
inline  const ::server::TLeaderboardRecord& Envelope::leaderboard_record() const {
  // @@protoc_insertion_point(field_get:server.Envelope.leaderboard_record)
  return has_leaderboard_record()
      ? *payload_.leaderboard_record_
      : ::server::TLeaderboardRecord::default_instance();
}
inline ::server::TLeaderboardRecord* Envelope::mutable_leaderboard_record() {
  if (!has_leaderboard_record()) {
    clear_payload();
    set_has_leaderboard_record();
    payload_.leaderboard_record_ = new ::server::TLeaderboardRecord;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.leaderboard_record)
  return payload_.leaderboard_record_;
}
inline ::server::TLeaderboardRecord* Envelope::release_leaderboard_record() {
  // @@protoc_insertion_point(field_release:server.Envelope.leaderboard_record)
  if (has_leaderboard_record()) {
    clear_has_payload();
    ::server::TLeaderboardRecord* temp = payload_.leaderboard_record_;
    payload_.leaderboard_record_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_leaderboard_record(::server::TLeaderboardRecord* leaderboard_record) {
  clear_payload();
  if (leaderboard_record) {
    set_has_leaderboard_record();
    payload_.leaderboard_record_ = leaderboard_record;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.leaderboard_record)
}

// optional .server.TLeaderboardRecords leaderboard_records = 59;
inline bool Envelope::has_leaderboard_records() const {
  return payload_case() == kLeaderboardRecords;
}
inline void Envelope::set_has_leaderboard_records() {
  _oneof_case_[0] = kLeaderboardRecords;
}
inline void Envelope::clear_leaderboard_records() {
  if (has_leaderboard_records()) {
    delete payload_.leaderboard_records_;
    clear_has_payload();
  }
}
inline  const ::server::TLeaderboardRecords& Envelope::leaderboard_records() const {
  // @@protoc_insertion_point(field_get:server.Envelope.leaderboard_records)
  return has_leaderboard_records()
      ? *payload_.leaderboard_records_
      : ::server::TLeaderboardRecords::default_instance();
}
inline ::server::TLeaderboardRecords* Envelope::mutable_leaderboard_records() {
  if (!has_leaderboard_records()) {
    clear_payload();
    set_has_leaderboard_records();
    payload_.leaderboard_records_ = new ::server::TLeaderboardRecords;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.leaderboard_records)
  return payload_.leaderboard_records_;
}
inline ::server::TLeaderboardRecords* Envelope::release_leaderboard_records() {
  // @@protoc_insertion_point(field_release:server.Envelope.leaderboard_records)
  if (has_leaderboard_records()) {
    clear_has_payload();
    ::server::TLeaderboardRecords* temp = payload_.leaderboard_records_;
    payload_.leaderboard_records_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_leaderboard_records(::server::TLeaderboardRecords* leaderboard_records) {
  clear_payload();
  if (leaderboard_records) {
    set_has_leaderboard_records();
    payload_.leaderboard_records_ = leaderboard_records;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.leaderboard_records)
}

// optional .server.TMatchmakeAdd matchmake_add = 60;
inline bool Envelope::has_matchmake_add() const {
  return payload_case() == kMatchmakeAdd;
}
inline void Envelope::set_has_matchmake_add() {
  _oneof_case_[0] = kMatchmakeAdd;
}
inline void Envelope::clear_matchmake_add() {
  if (has_matchmake_add()) {
    delete payload_.matchmake_add_;
    clear_has_payload();
  }
}
inline  const ::server::TMatchmakeAdd& Envelope::matchmake_add() const {
  // @@protoc_insertion_point(field_get:server.Envelope.matchmake_add)
  return has_matchmake_add()
      ? *payload_.matchmake_add_
      : ::server::TMatchmakeAdd::default_instance();
}
inline ::server::TMatchmakeAdd* Envelope::mutable_matchmake_add() {
  if (!has_matchmake_add()) {
    clear_payload();
    set_has_matchmake_add();
    payload_.matchmake_add_ = new ::server::TMatchmakeAdd;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.matchmake_add)
  return payload_.matchmake_add_;
}
inline ::server::TMatchmakeAdd* Envelope::release_matchmake_add() {
  // @@protoc_insertion_point(field_release:server.Envelope.matchmake_add)
  if (has_matchmake_add()) {
    clear_has_payload();
    ::server::TMatchmakeAdd* temp = payload_.matchmake_add_;
    payload_.matchmake_add_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_matchmake_add(::server::TMatchmakeAdd* matchmake_add) {
  clear_payload();
  if (matchmake_add) {
    set_has_matchmake_add();
    payload_.matchmake_add_ = matchmake_add;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.matchmake_add)
}

// optional .server.TMatchmakeRemove matchmake_remove = 61;
inline bool Envelope::has_matchmake_remove() const {
  return payload_case() == kMatchmakeRemove;
}
inline void Envelope::set_has_matchmake_remove() {
  _oneof_case_[0] = kMatchmakeRemove;
}
inline void Envelope::clear_matchmake_remove() {
  if (has_matchmake_remove()) {
    delete payload_.matchmake_remove_;
    clear_has_payload();
  }
}
inline  const ::server::TMatchmakeRemove& Envelope::matchmake_remove() const {
  // @@protoc_insertion_point(field_get:server.Envelope.matchmake_remove)
  return has_matchmake_remove()
      ? *payload_.matchmake_remove_
      : ::server::TMatchmakeRemove::default_instance();
}
inline ::server::TMatchmakeRemove* Envelope::mutable_matchmake_remove() {
  if (!has_matchmake_remove()) {
    clear_payload();
    set_has_matchmake_remove();
    payload_.matchmake_remove_ = new ::server::TMatchmakeRemove;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.matchmake_remove)
  return payload_.matchmake_remove_;
}
inline ::server::TMatchmakeRemove* Envelope::release_matchmake_remove() {
  // @@protoc_insertion_point(field_release:server.Envelope.matchmake_remove)
  if (has_matchmake_remove()) {
    clear_has_payload();
    ::server::TMatchmakeRemove* temp = payload_.matchmake_remove_;
    payload_.matchmake_remove_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_matchmake_remove(::server::TMatchmakeRemove* matchmake_remove) {
  clear_payload();
  if (matchmake_remove) {
    set_has_matchmake_remove();
    payload_.matchmake_remove_ = matchmake_remove;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.matchmake_remove)
}

// optional .server.TMatchmakeTicket matchmake_ticket = 62;
inline bool Envelope::has_matchmake_ticket() const {
  return payload_case() == kMatchmakeTicket;
}
inline void Envelope::set_has_matchmake_ticket() {
  _oneof_case_[0] = kMatchmakeTicket;
}
inline void Envelope::clear_matchmake_ticket() {
  if (has_matchmake_ticket()) {
    delete payload_.matchmake_ticket_;
    clear_has_payload();
  }
}
inline  const ::server::TMatchmakeTicket& Envelope::matchmake_ticket() const {
  // @@protoc_insertion_point(field_get:server.Envelope.matchmake_ticket)
  return has_matchmake_ticket()
      ? *payload_.matchmake_ticket_
      : ::server::TMatchmakeTicket::default_instance();
}
inline ::server::TMatchmakeTicket* Envelope::mutable_matchmake_ticket() {
  if (!has_matchmake_ticket()) {
    clear_payload();
    set_has_matchmake_ticket();
    payload_.matchmake_ticket_ = new ::server::TMatchmakeTicket;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.matchmake_ticket)
  return payload_.matchmake_ticket_;
}
inline ::server::TMatchmakeTicket* Envelope::release_matchmake_ticket() {
  // @@protoc_insertion_point(field_release:server.Envelope.matchmake_ticket)
  if (has_matchmake_ticket()) {
    clear_has_payload();
    ::server::TMatchmakeTicket* temp = payload_.matchmake_ticket_;
    payload_.matchmake_ticket_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_matchmake_ticket(::server::TMatchmakeTicket* matchmake_ticket) {
  clear_payload();
  if (matchmake_ticket) {
    set_has_matchmake_ticket();
    payload_.matchmake_ticket_ = matchmake_ticket;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.matchmake_ticket)
}

// optional .server.MatchmakeMatched matchmake_matched = 63;
inline bool Envelope::has_matchmake_matched() const {
  return payload_case() == kMatchmakeMatched;
}
inline void Envelope::set_has_matchmake_matched() {
  _oneof_case_[0] = kMatchmakeMatched;
}
inline void Envelope::clear_matchmake_matched() {
  if (has_matchmake_matched()) {
    delete payload_.matchmake_matched_;
    clear_has_payload();
  }
}
inline  const ::server::MatchmakeMatched& Envelope::matchmake_matched() const {
  // @@protoc_insertion_point(field_get:server.Envelope.matchmake_matched)
  return has_matchmake_matched()
      ? *payload_.matchmake_matched_
      : ::server::MatchmakeMatched::default_instance();
}
inline ::server::MatchmakeMatched* Envelope::mutable_matchmake_matched() {
  if (!has_matchmake_matched()) {
    clear_payload();
    set_has_matchmake_matched();
    payload_.matchmake_matched_ = new ::server::MatchmakeMatched;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.matchmake_matched)
  return payload_.matchmake_matched_;
}
inline ::server::MatchmakeMatched* Envelope::release_matchmake_matched() {
  // @@protoc_insertion_point(field_release:server.Envelope.matchmake_matched)
  if (has_matchmake_matched()) {
    clear_has_payload();
    ::server::MatchmakeMatched* temp = payload_.matchmake_matched_;
    payload_.matchmake_matched_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_matchmake_matched(::server::MatchmakeMatched* matchmake_matched) {
  clear_payload();
  if (matchmake_matched) {
    set_has_matchmake_matched();
    payload_.matchmake_matched_ = matchmake_matched;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.matchmake_matched)
}

// optional .server.TRpc rpc = 64;
inline bool Envelope::has_rpc() const {
  return payload_case() == kRpc;
}
inline void Envelope::set_has_rpc() {
  _oneof_case_[0] = kRpc;
}
inline void Envelope::clear_rpc() {
  if (has_rpc()) {
    delete payload_.rpc_;
    clear_has_payload();
  }
}
inline  const ::server::TRpc& Envelope::rpc() const {
  // @@protoc_insertion_point(field_get:server.Envelope.rpc)
  return has_rpc()
      ? *payload_.rpc_
      : ::server::TRpc::default_instance();
}
inline ::server::TRpc* Envelope::mutable_rpc() {
  if (!has_rpc()) {
    clear_payload();
    set_has_rpc();
    payload_.rpc_ = new ::server::TRpc;
  }
  // @@protoc_insertion_point(field_mutable:server.Envelope.rpc)
  return payload_.rpc_;
}
inline ::server::TRpc* Envelope::release_rpc() {
  // @@protoc_insertion_point(field_release:server.Envelope.rpc)
  if (has_rpc()) {
    clear_has_payload();
    ::server::TRpc* temp = payload_.rpc_;
    payload_.rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Envelope::set_allocated_rpc(::server::TRpc* rpc) {
  clear_payload();
  if (rpc) {
    set_has_rpc();
    payload_.rpc_ = rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:server.Envelope.rpc)
}

inline bool Envelope::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Envelope::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Envelope::PayloadCase Envelope::payload_case() const {
  return Envelope::PayloadCase(_oneof_case_[0]);
}
inline const Envelope* Envelope::internal_default_instance() {
  return &Envelope_default_instance_.get();
}
// -------------------------------------------------------------------

// Logout

inline const Logout* Logout::internal_default_instance() {
  return &Logout_default_instance_.get();
}
// -------------------------------------------------------------------

// TLink

// optional .server.AuthenticateRequest.Email email = 1;
inline bool TLink::has_email() const {
  return payload_case() == kEmail;
}
inline void TLink::set_has_email() {
  _oneof_case_[0] = kEmail;
}
inline void TLink::clear_email() {
  if (has_email()) {
    delete payload_.email_;
    clear_has_payload();
  }
}
inline  const ::server::AuthenticateRequest_Email& TLink::email() const {
  // @@protoc_insertion_point(field_get:server.TLink.email)
  return has_email()
      ? *payload_.email_
      : ::server::AuthenticateRequest_Email::default_instance();
}
inline ::server::AuthenticateRequest_Email* TLink::mutable_email() {
  if (!has_email()) {
    clear_payload();
    set_has_email();
    payload_.email_ = new ::server::AuthenticateRequest_Email;
  }
  // @@protoc_insertion_point(field_mutable:server.TLink.email)
  return payload_.email_;
}
inline ::server::AuthenticateRequest_Email* TLink::release_email() {
  // @@protoc_insertion_point(field_release:server.TLink.email)
  if (has_email()) {
    clear_has_payload();
    ::server::AuthenticateRequest_Email* temp = payload_.email_;
    payload_.email_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TLink::set_allocated_email(::server::AuthenticateRequest_Email* email) {
  clear_payload();
  if (email) {
    set_has_email();
    payload_.email_ = email;
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLink.email)
}

// optional string facebook = 2;
inline bool TLink::has_facebook() const {
  return payload_case() == kFacebook;
}
inline void TLink::set_has_facebook() {
  _oneof_case_[0] = kFacebook;
}
inline void TLink::clear_facebook() {
  if (has_facebook()) {
    payload_.facebook_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TLink::facebook() const {
  // @@protoc_insertion_point(field_get:server.TLink.facebook)
  if (has_facebook()) {
    return payload_.facebook_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TLink::set_facebook(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLink.facebook)
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.facebook_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLink.facebook)
}
inline void TLink::set_facebook(const char* value) {
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.facebook_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLink.facebook)
}
inline void TLink::set_facebook(const char* value, size_t size) {
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.facebook_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLink.facebook)
}
inline ::std::string* TLink::mutable_facebook() {
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TLink.facebook)
  return payload_.facebook_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLink::release_facebook() {
  // @@protoc_insertion_point(field_release:server.TLink.facebook)
  if (has_facebook()) {
    clear_has_payload();
    return payload_.facebook_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TLink::set_allocated_facebook(::std::string* facebook) {
  if (!has_facebook()) {
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (facebook != NULL) {
    set_has_facebook();
    payload_.facebook_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        facebook);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLink.facebook)
}

// optional string google = 3;
inline bool TLink::has_google() const {
  return payload_case() == kGoogle;
}
inline void TLink::set_has_google() {
  _oneof_case_[0] = kGoogle;
}
inline void TLink::clear_google() {
  if (has_google()) {
    payload_.google_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TLink::google() const {
  // @@protoc_insertion_point(field_get:server.TLink.google)
  if (has_google()) {
    return payload_.google_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TLink::set_google(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLink.google)
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.google_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLink.google)
}
inline void TLink::set_google(const char* value) {
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.google_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLink.google)
}
inline void TLink::set_google(const char* value, size_t size) {
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.google_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLink.google)
}
inline ::std::string* TLink::mutable_google() {
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TLink.google)
  return payload_.google_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLink::release_google() {
  // @@protoc_insertion_point(field_release:server.TLink.google)
  if (has_google()) {
    clear_has_payload();
    return payload_.google_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TLink::set_allocated_google(::std::string* google) {
  if (!has_google()) {
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (google != NULL) {
    set_has_google();
    payload_.google_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        google);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLink.google)
}

// optional .server.AuthenticateRequest.GameCenter game_center = 4;
inline bool TLink::has_game_center() const {
  return payload_case() == kGameCenter;
}
inline void TLink::set_has_game_center() {
  _oneof_case_[0] = kGameCenter;
}
inline void TLink::clear_game_center() {
  if (has_game_center()) {
    delete payload_.game_center_;
    clear_has_payload();
  }
}
inline  const ::server::AuthenticateRequest_GameCenter& TLink::game_center() const {
  // @@protoc_insertion_point(field_get:server.TLink.game_center)
  return has_game_center()
      ? *payload_.game_center_
      : ::server::AuthenticateRequest_GameCenter::default_instance();
}
inline ::server::AuthenticateRequest_GameCenter* TLink::mutable_game_center() {
  if (!has_game_center()) {
    clear_payload();
    set_has_game_center();
    payload_.game_center_ = new ::server::AuthenticateRequest_GameCenter;
  }
  // @@protoc_insertion_point(field_mutable:server.TLink.game_center)
  return payload_.game_center_;
}
inline ::server::AuthenticateRequest_GameCenter* TLink::release_game_center() {
  // @@protoc_insertion_point(field_release:server.TLink.game_center)
  if (has_game_center()) {
    clear_has_payload();
    ::server::AuthenticateRequest_GameCenter* temp = payload_.game_center_;
    payload_.game_center_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TLink::set_allocated_game_center(::server::AuthenticateRequest_GameCenter* game_center) {
  clear_payload();
  if (game_center) {
    set_has_game_center();
    payload_.game_center_ = game_center;
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLink.game_center)
}

// optional string steam = 5;
inline bool TLink::has_steam() const {
  return payload_case() == kSteam;
}
inline void TLink::set_has_steam() {
  _oneof_case_[0] = kSteam;
}
inline void TLink::clear_steam() {
  if (has_steam()) {
    payload_.steam_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TLink::steam() const {
  // @@protoc_insertion_point(field_get:server.TLink.steam)
  if (has_steam()) {
    return payload_.steam_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TLink::set_steam(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLink.steam)
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.steam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLink.steam)
}
inline void TLink::set_steam(const char* value) {
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.steam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLink.steam)
}
inline void TLink::set_steam(const char* value, size_t size) {
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.steam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLink.steam)
}
inline ::std::string* TLink::mutable_steam() {
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TLink.steam)
  return payload_.steam_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLink::release_steam() {
  // @@protoc_insertion_point(field_release:server.TLink.steam)
  if (has_steam()) {
    clear_has_payload();
    return payload_.steam_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TLink::set_allocated_steam(::std::string* steam) {
  if (!has_steam()) {
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (steam != NULL) {
    set_has_steam();
    payload_.steam_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        steam);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLink.steam)
}

// optional string device = 6;
inline bool TLink::has_device() const {
  return payload_case() == kDevice;
}
inline void TLink::set_has_device() {
  _oneof_case_[0] = kDevice;
}
inline void TLink::clear_device() {
  if (has_device()) {
    payload_.device_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TLink::device() const {
  // @@protoc_insertion_point(field_get:server.TLink.device)
  if (has_device()) {
    return payload_.device_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TLink::set_device(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLink.device)
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLink.device)
}
inline void TLink::set_device(const char* value) {
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLink.device)
}
inline void TLink::set_device(const char* value, size_t size) {
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLink.device)
}
inline ::std::string* TLink::mutable_device() {
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TLink.device)
  return payload_.device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLink::release_device() {
  // @@protoc_insertion_point(field_release:server.TLink.device)
  if (has_device()) {
    clear_has_payload();
    return payload_.device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TLink::set_allocated_device(::std::string* device) {
  if (!has_device()) {
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (device != NULL) {
    set_has_device();
    payload_.device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        device);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLink.device)
}

// optional string custom = 7;
inline bool TLink::has_custom() const {
  return payload_case() == kCustom;
}
inline void TLink::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void TLink::clear_custom() {
  if (has_custom()) {
    payload_.custom_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TLink::custom() const {
  // @@protoc_insertion_point(field_get:server.TLink.custom)
  if (has_custom()) {
    return payload_.custom_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TLink::set_custom(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLink.custom)
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.custom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLink.custom)
}
inline void TLink::set_custom(const char* value) {
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.custom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLink.custom)
}
inline void TLink::set_custom(const char* value, size_t size) {
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.custom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLink.custom)
}
inline ::std::string* TLink::mutable_custom() {
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TLink.custom)
  return payload_.custom_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLink::release_custom() {
  // @@protoc_insertion_point(field_release:server.TLink.custom)
  if (has_custom()) {
    clear_has_payload();
    return payload_.custom_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TLink::set_allocated_custom(::std::string* custom) {
  if (!has_custom()) {
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (custom != NULL) {
    set_has_custom();
    payload_.custom_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        custom);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLink.custom)
}

inline bool TLink::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void TLink::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline TLink::PayloadCase TLink::payload_case() const {
  return TLink::PayloadCase(_oneof_case_[0]);
}
inline const TLink* TLink::internal_default_instance() {
  return &TLink_default_instance_.get();
}
// -------------------------------------------------------------------

// TUnlink

// optional string email = 1;
inline bool TUnlink::has_email() const {
  return payload_case() == kEmail;
}
inline void TUnlink::set_has_email() {
  _oneof_case_[0] = kEmail;
}
inline void TUnlink::clear_email() {
  if (has_email()) {
    payload_.email_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TUnlink::email() const {
  // @@protoc_insertion_point(field_get:server.TUnlink.email)
  if (has_email()) {
    return payload_.email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TUnlink::set_email(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TUnlink.email)
  if (!has_email()) {
    clear_payload();
    set_has_email();
    payload_.email_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TUnlink.email)
}
inline void TUnlink::set_email(const char* value) {
  if (!has_email()) {
    clear_payload();
    set_has_email();
    payload_.email_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TUnlink.email)
}
inline void TUnlink::set_email(const char* value, size_t size) {
  if (!has_email()) {
    clear_payload();
    set_has_email();
    payload_.email_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TUnlink.email)
}
inline ::std::string* TUnlink::mutable_email() {
  if (!has_email()) {
    clear_payload();
    set_has_email();
    payload_.email_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TUnlink.email)
  return payload_.email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TUnlink::release_email() {
  // @@protoc_insertion_point(field_release:server.TUnlink.email)
  if (has_email()) {
    clear_has_payload();
    return payload_.email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TUnlink::set_allocated_email(::std::string* email) {
  if (!has_email()) {
    payload_.email_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (email != NULL) {
    set_has_email();
    payload_.email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        email);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TUnlink.email)
}

// optional string facebook = 2;
inline bool TUnlink::has_facebook() const {
  return payload_case() == kFacebook;
}
inline void TUnlink::set_has_facebook() {
  _oneof_case_[0] = kFacebook;
}
inline void TUnlink::clear_facebook() {
  if (has_facebook()) {
    payload_.facebook_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TUnlink::facebook() const {
  // @@protoc_insertion_point(field_get:server.TUnlink.facebook)
  if (has_facebook()) {
    return payload_.facebook_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TUnlink::set_facebook(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TUnlink.facebook)
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.facebook_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TUnlink.facebook)
}
inline void TUnlink::set_facebook(const char* value) {
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.facebook_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TUnlink.facebook)
}
inline void TUnlink::set_facebook(const char* value, size_t size) {
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.facebook_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TUnlink.facebook)
}
inline ::std::string* TUnlink::mutable_facebook() {
  if (!has_facebook()) {
    clear_payload();
    set_has_facebook();
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TUnlink.facebook)
  return payload_.facebook_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TUnlink::release_facebook() {
  // @@protoc_insertion_point(field_release:server.TUnlink.facebook)
  if (has_facebook()) {
    clear_has_payload();
    return payload_.facebook_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TUnlink::set_allocated_facebook(::std::string* facebook) {
  if (!has_facebook()) {
    payload_.facebook_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (facebook != NULL) {
    set_has_facebook();
    payload_.facebook_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        facebook);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TUnlink.facebook)
}

// optional string google = 3;
inline bool TUnlink::has_google() const {
  return payload_case() == kGoogle;
}
inline void TUnlink::set_has_google() {
  _oneof_case_[0] = kGoogle;
}
inline void TUnlink::clear_google() {
  if (has_google()) {
    payload_.google_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TUnlink::google() const {
  // @@protoc_insertion_point(field_get:server.TUnlink.google)
  if (has_google()) {
    return payload_.google_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TUnlink::set_google(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TUnlink.google)
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.google_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TUnlink.google)
}
inline void TUnlink::set_google(const char* value) {
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.google_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TUnlink.google)
}
inline void TUnlink::set_google(const char* value, size_t size) {
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.google_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TUnlink.google)
}
inline ::std::string* TUnlink::mutable_google() {
  if (!has_google()) {
    clear_payload();
    set_has_google();
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TUnlink.google)
  return payload_.google_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TUnlink::release_google() {
  // @@protoc_insertion_point(field_release:server.TUnlink.google)
  if (has_google()) {
    clear_has_payload();
    return payload_.google_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TUnlink::set_allocated_google(::std::string* google) {
  if (!has_google()) {
    payload_.google_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (google != NULL) {
    set_has_google();
    payload_.google_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        google);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TUnlink.google)
}

// optional string game_center = 4;
inline bool TUnlink::has_game_center() const {
  return payload_case() == kGameCenter;
}
inline void TUnlink::set_has_game_center() {
  _oneof_case_[0] = kGameCenter;
}
inline void TUnlink::clear_game_center() {
  if (has_game_center()) {
    payload_.game_center_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TUnlink::game_center() const {
  // @@protoc_insertion_point(field_get:server.TUnlink.game_center)
  if (has_game_center()) {
    return payload_.game_center_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TUnlink::set_game_center(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TUnlink.game_center)
  if (!has_game_center()) {
    clear_payload();
    set_has_game_center();
    payload_.game_center_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.game_center_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TUnlink.game_center)
}
inline void TUnlink::set_game_center(const char* value) {
  if (!has_game_center()) {
    clear_payload();
    set_has_game_center();
    payload_.game_center_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.game_center_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TUnlink.game_center)
}
inline void TUnlink::set_game_center(const char* value, size_t size) {
  if (!has_game_center()) {
    clear_payload();
    set_has_game_center();
    payload_.game_center_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.game_center_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TUnlink.game_center)
}
inline ::std::string* TUnlink::mutable_game_center() {
  if (!has_game_center()) {
    clear_payload();
    set_has_game_center();
    payload_.game_center_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TUnlink.game_center)
  return payload_.game_center_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TUnlink::release_game_center() {
  // @@protoc_insertion_point(field_release:server.TUnlink.game_center)
  if (has_game_center()) {
    clear_has_payload();
    return payload_.game_center_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TUnlink::set_allocated_game_center(::std::string* game_center) {
  if (!has_game_center()) {
    payload_.game_center_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (game_center != NULL) {
    set_has_game_center();
    payload_.game_center_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        game_center);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TUnlink.game_center)
}

// optional string steam = 5;
inline bool TUnlink::has_steam() const {
  return payload_case() == kSteam;
}
inline void TUnlink::set_has_steam() {
  _oneof_case_[0] = kSteam;
}
inline void TUnlink::clear_steam() {
  if (has_steam()) {
    payload_.steam_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TUnlink::steam() const {
  // @@protoc_insertion_point(field_get:server.TUnlink.steam)
  if (has_steam()) {
    return payload_.steam_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TUnlink::set_steam(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TUnlink.steam)
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.steam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TUnlink.steam)
}
inline void TUnlink::set_steam(const char* value) {
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.steam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TUnlink.steam)
}
inline void TUnlink::set_steam(const char* value, size_t size) {
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.steam_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TUnlink.steam)
}
inline ::std::string* TUnlink::mutable_steam() {
  if (!has_steam()) {
    clear_payload();
    set_has_steam();
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TUnlink.steam)
  return payload_.steam_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TUnlink::release_steam() {
  // @@protoc_insertion_point(field_release:server.TUnlink.steam)
  if (has_steam()) {
    clear_has_payload();
    return payload_.steam_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TUnlink::set_allocated_steam(::std::string* steam) {
  if (!has_steam()) {
    payload_.steam_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (steam != NULL) {
    set_has_steam();
    payload_.steam_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        steam);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TUnlink.steam)
}

// optional string device = 6;
inline bool TUnlink::has_device() const {
  return payload_case() == kDevice;
}
inline void TUnlink::set_has_device() {
  _oneof_case_[0] = kDevice;
}
inline void TUnlink::clear_device() {
  if (has_device()) {
    payload_.device_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TUnlink::device() const {
  // @@protoc_insertion_point(field_get:server.TUnlink.device)
  if (has_device()) {
    return payload_.device_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TUnlink::set_device(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TUnlink.device)
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TUnlink.device)
}
inline void TUnlink::set_device(const char* value) {
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TUnlink.device)
}
inline void TUnlink::set_device(const char* value, size_t size) {
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TUnlink.device)
}
inline ::std::string* TUnlink::mutable_device() {
  if (!has_device()) {
    clear_payload();
    set_has_device();
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TUnlink.device)
  return payload_.device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TUnlink::release_device() {
  // @@protoc_insertion_point(field_release:server.TUnlink.device)
  if (has_device()) {
    clear_has_payload();
    return payload_.device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TUnlink::set_allocated_device(::std::string* device) {
  if (!has_device()) {
    payload_.device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (device != NULL) {
    set_has_device();
    payload_.device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        device);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TUnlink.device)
}

// optional string custom = 7;
inline bool TUnlink::has_custom() const {
  return payload_case() == kCustom;
}
inline void TUnlink::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void TUnlink::clear_custom() {
  if (has_custom()) {
    payload_.custom_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& TUnlink::custom() const {
  // @@protoc_insertion_point(field_get:server.TUnlink.custom)
  if (has_custom()) {
    return payload_.custom_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TUnlink::set_custom(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TUnlink.custom)
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.custom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TUnlink.custom)
}
inline void TUnlink::set_custom(const char* value) {
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.custom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TUnlink.custom)
}
inline void TUnlink::set_custom(const char* value, size_t size) {
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.custom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TUnlink.custom)
}
inline ::std::string* TUnlink::mutable_custom() {
  if (!has_custom()) {
    clear_payload();
    set_has_custom();
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TUnlink.custom)
  return payload_.custom_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TUnlink::release_custom() {
  // @@protoc_insertion_point(field_release:server.TUnlink.custom)
  if (has_custom()) {
    clear_has_payload();
    return payload_.custom_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TUnlink::set_allocated_custom(::std::string* custom) {
  if (!has_custom()) {
    payload_.custom_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (custom != NULL) {
    set_has_custom();
    payload_.custom_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        custom);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TUnlink.custom)
}

inline bool TUnlink::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void TUnlink::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline TUnlink::PayloadCase TUnlink::payload_case() const {
  return TUnlink::PayloadCase(_oneof_case_[0]);
}
inline const TUnlink* TUnlink::internal_default_instance() {
  return &TUnlink_default_instance_.get();
}
// -------------------------------------------------------------------

// User

// optional bytes id = 1;
inline void User::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::id() const {
  // @@protoc_insertion_point(field_get:server.User.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.User.id)
}
inline void User::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.User.id)
}
inline void User::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.User.id)
}
inline ::std::string* User::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:server.User.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:server.User.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:server.User.id)
}

// optional string handle = 2;
inline void User::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::handle() const {
  // @@protoc_insertion_point(field_get:server.User.handle)
  return handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.User.handle)
}
inline void User::set_handle(const char* value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.User.handle)
}
inline void User::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.User.handle)
}
inline ::std::string* User::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:server.User.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_handle() {
  // @@protoc_insertion_point(field_release:server.User.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:server.User.handle)
}

// optional string fullname = 3;
inline void User::clear_fullname() {
  fullname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::fullname() const {
  // @@protoc_insertion_point(field_get:server.User.fullname)
  return fullname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_fullname(const ::std::string& value) {
  
  fullname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.User.fullname)
}
inline void User::set_fullname(const char* value) {
  
  fullname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.User.fullname)
}
inline void User::set_fullname(const char* value, size_t size) {
  
  fullname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.User.fullname)
}
inline ::std::string* User::mutable_fullname() {
  
  // @@protoc_insertion_point(field_mutable:server.User.fullname)
  return fullname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_fullname() {
  // @@protoc_insertion_point(field_release:server.User.fullname)
  
  return fullname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_fullname(::std::string* fullname) {
  if (fullname != NULL) {
    
  } else {
    
  }
  fullname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fullname);
  // @@protoc_insertion_point(field_set_allocated:server.User.fullname)
}

// optional string avatar_url = 4;
inline void User::clear_avatar_url() {
  avatar_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::avatar_url() const {
  // @@protoc_insertion_point(field_get:server.User.avatar_url)
  return avatar_url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_avatar_url(const ::std::string& value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.User.avatar_url)
}
inline void User::set_avatar_url(const char* value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.User.avatar_url)
}
inline void User::set_avatar_url(const char* value, size_t size) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.User.avatar_url)
}
inline ::std::string* User::mutable_avatar_url() {
  
  // @@protoc_insertion_point(field_mutable:server.User.avatar_url)
  return avatar_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_avatar_url() {
  // @@protoc_insertion_point(field_release:server.User.avatar_url)
  
  return avatar_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url != NULL) {
    
  } else {
    
  }
  avatar_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar_url);
  // @@protoc_insertion_point(field_set_allocated:server.User.avatar_url)
}

// optional string lang = 5;
inline void User::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::lang() const {
  // @@protoc_insertion_point(field_get:server.User.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.User.lang)
}
inline void User::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.User.lang)
}
inline void User::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.User.lang)
}
inline ::std::string* User::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:server.User.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_lang() {
  // @@protoc_insertion_point(field_release:server.User.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:server.User.lang)
}

// optional string location = 6;
inline void User::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::location() const {
  // @@protoc_insertion_point(field_get:server.User.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.User.location)
}
inline void User::set_location(const char* value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.User.location)
}
inline void User::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.User.location)
}
inline ::std::string* User::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:server.User.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_location() {
  // @@protoc_insertion_point(field_release:server.User.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:server.User.location)
}

// optional string timezone = 7;
inline void User::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::timezone() const {
  // @@protoc_insertion_point(field_get:server.User.timezone)
  return timezone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_timezone(const ::std::string& value) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.User.timezone)
}
inline void User::set_timezone(const char* value) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.User.timezone)
}
inline void User::set_timezone(const char* value, size_t size) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.User.timezone)
}
inline ::std::string* User::mutable_timezone() {
  
  // @@protoc_insertion_point(field_mutable:server.User.timezone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_timezone() {
  // @@protoc_insertion_point(field_release:server.User.timezone)
  
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    
  } else {
    
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:server.User.timezone)
}

// optional bytes metadata = 8;
inline void User::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::metadata() const {
  // @@protoc_insertion_point(field_get:server.User.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.User.metadata)
}
inline void User::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.User.metadata)
}
inline void User::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.User.metadata)
}
inline ::std::string* User::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:server.User.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_metadata() {
  // @@protoc_insertion_point(field_release:server.User.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:server.User.metadata)
}

// optional int64 created_at = 9;
inline void User::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 User::created_at() const {
  // @@protoc_insertion_point(field_get:server.User.created_at)
  return created_at_;
}
inline void User::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:server.User.created_at)
}

// optional int64 updated_at = 10;
inline void User::clear_updated_at() {
  updated_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 User::updated_at() const {
  // @@protoc_insertion_point(field_get:server.User.updated_at)
  return updated_at_;
}
inline void User::set_updated_at(::google::protobuf::int64 value) {
  
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:server.User.updated_at)
}

// optional int64 last_online_at = 11;
inline void User::clear_last_online_at() {
  last_online_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 User::last_online_at() const {
  // @@protoc_insertion_point(field_get:server.User.last_online_at)
  return last_online_at_;
}
inline void User::set_last_online_at(::google::protobuf::int64 value) {
  
  last_online_at_ = value;
  // @@protoc_insertion_point(field_set:server.User.last_online_at)
}

inline const User* User::internal_default_instance() {
  return &User_default_instance_.get();
}
// -------------------------------------------------------------------

// Self

// optional .server.User user = 1;
inline bool Self::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void Self::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) delete user_;
  user_ = NULL;
}
inline const ::server::User& Self::user() const {
  // @@protoc_insertion_point(field_get:server.Self.user)
  return user_ != NULL ? *user_
                         : *::server::User::internal_default_instance();
}
inline ::server::User* Self::mutable_user() {
  
  if (user_ == NULL) {
    user_ = new ::server::User;
  }
  // @@protoc_insertion_point(field_mutable:server.Self.user)
  return user_;
}
inline ::server::User* Self::release_user() {
  // @@protoc_insertion_point(field_release:server.Self.user)
  
  ::server::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void Self::set_allocated_user(::server::User* user) {
  delete user_;
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.Self.user)
}

// optional bool verified = 2;
inline void Self::clear_verified() {
  verified_ = false;
}
inline bool Self::verified() const {
  // @@protoc_insertion_point(field_get:server.Self.verified)
  return verified_;
}
inline void Self::set_verified(bool value) {
  
  verified_ = value;
  // @@protoc_insertion_point(field_set:server.Self.verified)
}

// optional string email = 3;
inline void Self::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Self::email() const {
  // @@protoc_insertion_point(field_get:server.Self.email)
  return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Self.email)
}
inline void Self::set_email(const char* value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Self.email)
}
inline void Self::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Self.email)
}
inline ::std::string* Self::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:server.Self.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Self::release_email() {
  // @@protoc_insertion_point(field_release:server.Self.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:server.Self.email)
}

// repeated string device_id = 4;
inline int Self::device_id_size() const {
  return device_id_.size();
}
inline void Self::clear_device_id() {
  device_id_.Clear();
}
inline const ::std::string& Self::device_id(int index) const {
  // @@protoc_insertion_point(field_get:server.Self.device_id)
  return device_id_.Get(index);
}
inline ::std::string* Self::mutable_device_id(int index) {
  // @@protoc_insertion_point(field_mutable:server.Self.device_id)
  return device_id_.Mutable(index);
}
inline void Self::set_device_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.Self.device_id)
  device_id_.Mutable(index)->assign(value);
}
inline void Self::set_device_id(int index, const char* value) {
  device_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:server.Self.device_id)
}
inline void Self::set_device_id(int index, const char* value, size_t size) {
  device_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:server.Self.device_id)
}
inline ::std::string* Self::add_device_id() {
  // @@protoc_insertion_point(field_add_mutable:server.Self.device_id)
  return device_id_.Add();
}
inline void Self::add_device_id(const ::std::string& value) {
  device_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:server.Self.device_id)
}
inline void Self::add_device_id(const char* value) {
  device_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:server.Self.device_id)
}
inline void Self::add_device_id(const char* value, size_t size) {
  device_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:server.Self.device_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Self::device_id() const {
  // @@protoc_insertion_point(field_list:server.Self.device_id)
  return device_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Self::mutable_device_id() {
  // @@protoc_insertion_point(field_mutable_list:server.Self.device_id)
  return &device_id_;
}

// optional string facebook_id = 5;
inline void Self::clear_facebook_id() {
  facebook_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Self::facebook_id() const {
  // @@protoc_insertion_point(field_get:server.Self.facebook_id)
  return facebook_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_facebook_id(const ::std::string& value) {
  
  facebook_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Self.facebook_id)
}
inline void Self::set_facebook_id(const char* value) {
  
  facebook_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Self.facebook_id)
}
inline void Self::set_facebook_id(const char* value, size_t size) {
  
  facebook_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Self.facebook_id)
}
inline ::std::string* Self::mutable_facebook_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Self.facebook_id)
  return facebook_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Self::release_facebook_id() {
  // @@protoc_insertion_point(field_release:server.Self.facebook_id)
  
  return facebook_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_allocated_facebook_id(::std::string* facebook_id) {
  if (facebook_id != NULL) {
    
  } else {
    
  }
  facebook_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), facebook_id);
  // @@protoc_insertion_point(field_set_allocated:server.Self.facebook_id)
}

// optional string google_id = 6;
inline void Self::clear_google_id() {
  google_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Self::google_id() const {
  // @@protoc_insertion_point(field_get:server.Self.google_id)
  return google_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_google_id(const ::std::string& value) {
  
  google_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Self.google_id)
}
inline void Self::set_google_id(const char* value) {
  
  google_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Self.google_id)
}
inline void Self::set_google_id(const char* value, size_t size) {
  
  google_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Self.google_id)
}
inline ::std::string* Self::mutable_google_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Self.google_id)
  return google_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Self::release_google_id() {
  // @@protoc_insertion_point(field_release:server.Self.google_id)
  
  return google_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_allocated_google_id(::std::string* google_id) {
  if (google_id != NULL) {
    
  } else {
    
  }
  google_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), google_id);
  // @@protoc_insertion_point(field_set_allocated:server.Self.google_id)
}

// optional string gamecenter_id = 7;
inline void Self::clear_gamecenter_id() {
  gamecenter_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Self::gamecenter_id() const {
  // @@protoc_insertion_point(field_get:server.Self.gamecenter_id)
  return gamecenter_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_gamecenter_id(const ::std::string& value) {
  
  gamecenter_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Self.gamecenter_id)
}
inline void Self::set_gamecenter_id(const char* value) {
  
  gamecenter_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Self.gamecenter_id)
}
inline void Self::set_gamecenter_id(const char* value, size_t size) {
  
  gamecenter_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Self.gamecenter_id)
}
inline ::std::string* Self::mutable_gamecenter_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Self.gamecenter_id)
  return gamecenter_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Self::release_gamecenter_id() {
  // @@protoc_insertion_point(field_release:server.Self.gamecenter_id)
  
  return gamecenter_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_allocated_gamecenter_id(::std::string* gamecenter_id) {
  if (gamecenter_id != NULL) {
    
  } else {
    
  }
  gamecenter_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamecenter_id);
  // @@protoc_insertion_point(field_set_allocated:server.Self.gamecenter_id)
}

// optional string steam_id = 8;
inline void Self::clear_steam_id() {
  steam_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Self::steam_id() const {
  // @@protoc_insertion_point(field_get:server.Self.steam_id)
  return steam_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_steam_id(const ::std::string& value) {
  
  steam_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Self.steam_id)
}
inline void Self::set_steam_id(const char* value) {
  
  steam_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Self.steam_id)
}
inline void Self::set_steam_id(const char* value, size_t size) {
  
  steam_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Self.steam_id)
}
inline ::std::string* Self::mutable_steam_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Self.steam_id)
  return steam_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Self::release_steam_id() {
  // @@protoc_insertion_point(field_release:server.Self.steam_id)
  
  return steam_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id != NULL) {
    
  } else {
    
  }
  steam_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), steam_id);
  // @@protoc_insertion_point(field_set_allocated:server.Self.steam_id)
}

// optional string custom_id = 9;
inline void Self::clear_custom_id() {
  custom_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Self::custom_id() const {
  // @@protoc_insertion_point(field_get:server.Self.custom_id)
  return custom_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_custom_id(const ::std::string& value) {
  
  custom_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Self.custom_id)
}
inline void Self::set_custom_id(const char* value) {
  
  custom_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Self.custom_id)
}
inline void Self::set_custom_id(const char* value, size_t size) {
  
  custom_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Self.custom_id)
}
inline ::std::string* Self::mutable_custom_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Self.custom_id)
  return custom_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Self::release_custom_id() {
  // @@protoc_insertion_point(field_release:server.Self.custom_id)
  
  return custom_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Self::set_allocated_custom_id(::std::string* custom_id) {
  if (custom_id != NULL) {
    
  } else {
    
  }
  custom_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_id);
  // @@protoc_insertion_point(field_set_allocated:server.Self.custom_id)
}

inline const Self* Self::internal_default_instance() {
  return &Self_default_instance_.get();
}
// -------------------------------------------------------------------

// TSelfFetch

inline const TSelfFetch* TSelfFetch::internal_default_instance() {
  return &TSelfFetch_default_instance_.get();
}
// -------------------------------------------------------------------

// TSelf

// optional .server.Self self = 1;
inline bool TSelf::has_self() const {
  return this != internal_default_instance() && self_ != NULL;
}
inline void TSelf::clear_self() {
  if (GetArenaNoVirtual() == NULL && self_ != NULL) delete self_;
  self_ = NULL;
}
inline const ::server::Self& TSelf::self() const {
  // @@protoc_insertion_point(field_get:server.TSelf.self)
  return self_ != NULL ? *self_
                         : *::server::Self::internal_default_instance();
}
inline ::server::Self* TSelf::mutable_self() {
  
  if (self_ == NULL) {
    self_ = new ::server::Self;
  }
  // @@protoc_insertion_point(field_mutable:server.TSelf.self)
  return self_;
}
inline ::server::Self* TSelf::release_self() {
  // @@protoc_insertion_point(field_release:server.TSelf.self)
  
  ::server::Self* temp = self_;
  self_ = NULL;
  return temp;
}
inline void TSelf::set_allocated_self(::server::Self* self) {
  delete self_;
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TSelf.self)
}

inline const TSelf* TSelf::internal_default_instance() {
  return &TSelf_default_instance_.get();
}
// -------------------------------------------------------------------

// TSelfUpdate

// optional string handle = 1;
inline void TSelfUpdate::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TSelfUpdate::handle() const {
  // @@protoc_insertion_point(field_get:server.TSelfUpdate.handle)
  return handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TSelfUpdate.handle)
}
inline void TSelfUpdate::set_handle(const char* value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TSelfUpdate.handle)
}
inline void TSelfUpdate::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TSelfUpdate.handle)
}
inline ::std::string* TSelfUpdate::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:server.TSelfUpdate.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TSelfUpdate::release_handle() {
  // @@protoc_insertion_point(field_release:server.TSelfUpdate.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:server.TSelfUpdate.handle)
}

// optional string fullname = 2;
inline void TSelfUpdate::clear_fullname() {
  fullname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TSelfUpdate::fullname() const {
  // @@protoc_insertion_point(field_get:server.TSelfUpdate.fullname)
  return fullname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_fullname(const ::std::string& value) {
  
  fullname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TSelfUpdate.fullname)
}
inline void TSelfUpdate::set_fullname(const char* value) {
  
  fullname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TSelfUpdate.fullname)
}
inline void TSelfUpdate::set_fullname(const char* value, size_t size) {
  
  fullname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TSelfUpdate.fullname)
}
inline ::std::string* TSelfUpdate::mutable_fullname() {
  
  // @@protoc_insertion_point(field_mutable:server.TSelfUpdate.fullname)
  return fullname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TSelfUpdate::release_fullname() {
  // @@protoc_insertion_point(field_release:server.TSelfUpdate.fullname)
  
  return fullname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_allocated_fullname(::std::string* fullname) {
  if (fullname != NULL) {
    
  } else {
    
  }
  fullname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fullname);
  // @@protoc_insertion_point(field_set_allocated:server.TSelfUpdate.fullname)
}

// optional string timezone = 3;
inline void TSelfUpdate::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TSelfUpdate::timezone() const {
  // @@protoc_insertion_point(field_get:server.TSelfUpdate.timezone)
  return timezone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_timezone(const ::std::string& value) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TSelfUpdate.timezone)
}
inline void TSelfUpdate::set_timezone(const char* value) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TSelfUpdate.timezone)
}
inline void TSelfUpdate::set_timezone(const char* value, size_t size) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TSelfUpdate.timezone)
}
inline ::std::string* TSelfUpdate::mutable_timezone() {
  
  // @@protoc_insertion_point(field_mutable:server.TSelfUpdate.timezone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TSelfUpdate::release_timezone() {
  // @@protoc_insertion_point(field_release:server.TSelfUpdate.timezone)
  
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    
  } else {
    
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:server.TSelfUpdate.timezone)
}

// optional string location = 4;
inline void TSelfUpdate::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TSelfUpdate::location() const {
  // @@protoc_insertion_point(field_get:server.TSelfUpdate.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TSelfUpdate.location)
}
inline void TSelfUpdate::set_location(const char* value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TSelfUpdate.location)
}
inline void TSelfUpdate::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TSelfUpdate.location)
}
inline ::std::string* TSelfUpdate::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:server.TSelfUpdate.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TSelfUpdate::release_location() {
  // @@protoc_insertion_point(field_release:server.TSelfUpdate.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:server.TSelfUpdate.location)
}

// optional string lang = 5;
inline void TSelfUpdate::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TSelfUpdate::lang() const {
  // @@protoc_insertion_point(field_get:server.TSelfUpdate.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TSelfUpdate.lang)
}
inline void TSelfUpdate::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TSelfUpdate.lang)
}
inline void TSelfUpdate::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TSelfUpdate.lang)
}
inline ::std::string* TSelfUpdate::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:server.TSelfUpdate.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TSelfUpdate::release_lang() {
  // @@protoc_insertion_point(field_release:server.TSelfUpdate.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:server.TSelfUpdate.lang)
}

// optional bytes metadata = 6;
inline void TSelfUpdate::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TSelfUpdate::metadata() const {
  // @@protoc_insertion_point(field_get:server.TSelfUpdate.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TSelfUpdate.metadata)
}
inline void TSelfUpdate::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TSelfUpdate.metadata)
}
inline void TSelfUpdate::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TSelfUpdate.metadata)
}
inline ::std::string* TSelfUpdate::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:server.TSelfUpdate.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TSelfUpdate::release_metadata() {
  // @@protoc_insertion_point(field_release:server.TSelfUpdate.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:server.TSelfUpdate.metadata)
}

// optional string avatar_url = 7;
inline void TSelfUpdate::clear_avatar_url() {
  avatar_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TSelfUpdate::avatar_url() const {
  // @@protoc_insertion_point(field_get:server.TSelfUpdate.avatar_url)
  return avatar_url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_avatar_url(const ::std::string& value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TSelfUpdate.avatar_url)
}
inline void TSelfUpdate::set_avatar_url(const char* value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TSelfUpdate.avatar_url)
}
inline void TSelfUpdate::set_avatar_url(const char* value, size_t size) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TSelfUpdate.avatar_url)
}
inline ::std::string* TSelfUpdate::mutable_avatar_url() {
  
  // @@protoc_insertion_point(field_mutable:server.TSelfUpdate.avatar_url)
  return avatar_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TSelfUpdate::release_avatar_url() {
  // @@protoc_insertion_point(field_release:server.TSelfUpdate.avatar_url)
  
  return avatar_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TSelfUpdate::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url != NULL) {
    
  } else {
    
  }
  avatar_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar_url);
  // @@protoc_insertion_point(field_set_allocated:server.TSelfUpdate.avatar_url)
}

inline const TSelfUpdate* TSelfUpdate::internal_default_instance() {
  return &TSelfUpdate_default_instance_.get();
}
// -------------------------------------------------------------------

// TUsersFetch_UserIds

// repeated bytes user_ids = 1;
inline int TUsersFetch_UserIds::user_ids_size() const {
  return user_ids_.size();
}
inline void TUsersFetch_UserIds::clear_user_ids() {
  user_ids_.Clear();
}
inline const ::std::string& TUsersFetch_UserIds::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:server.TUsersFetch.UserIds.user_ids)
  return user_ids_.Get(index);
}
inline ::std::string* TUsersFetch_UserIds::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:server.TUsersFetch.UserIds.user_ids)
  return user_ids_.Mutable(index);
}
inline void TUsersFetch_UserIds::set_user_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TUsersFetch.UserIds.user_ids)
  user_ids_.Mutable(index)->assign(value);
}
inline void TUsersFetch_UserIds::set_user_ids(int index, const char* value) {
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:server.TUsersFetch.UserIds.user_ids)
}
inline void TUsersFetch_UserIds::set_user_ids(int index, const void* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:server.TUsersFetch.UserIds.user_ids)
}
inline ::std::string* TUsersFetch_UserIds::add_user_ids() {
  // @@protoc_insertion_point(field_add_mutable:server.TUsersFetch.UserIds.user_ids)
  return user_ids_.Add();
}
inline void TUsersFetch_UserIds::add_user_ids(const ::std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:server.TUsersFetch.UserIds.user_ids)
}
inline void TUsersFetch_UserIds::add_user_ids(const char* value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:server.TUsersFetch.UserIds.user_ids)
}
inline void TUsersFetch_UserIds::add_user_ids(const void* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:server.TUsersFetch.UserIds.user_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TUsersFetch_UserIds::user_ids() const {
  // @@protoc_insertion_point(field_list:server.TUsersFetch.UserIds.user_ids)
  return user_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TUsersFetch_UserIds::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:server.TUsersFetch.UserIds.user_ids)
  return &user_ids_;
}

inline const TUsersFetch_UserIds* TUsersFetch_UserIds::internal_default_instance() {
  return &TUsersFetch_UserIds_default_instance_.get();
}
// -------------------------------------------------------------------

// TUsersFetch_Handles

// repeated string handles = 1;
inline int TUsersFetch_Handles::handles_size() const {
  return handles_.size();
}
inline void TUsersFetch_Handles::clear_handles() {
  handles_.Clear();
}
inline const ::std::string& TUsersFetch_Handles::handles(int index) const {
  // @@protoc_insertion_point(field_get:server.TUsersFetch.Handles.handles)
  return handles_.Get(index);
}
inline ::std::string* TUsersFetch_Handles::mutable_handles(int index) {
  // @@protoc_insertion_point(field_mutable:server.TUsersFetch.Handles.handles)
  return handles_.Mutable(index);
}
inline void TUsersFetch_Handles::set_handles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TUsersFetch.Handles.handles)
  handles_.Mutable(index)->assign(value);
}
inline void TUsersFetch_Handles::set_handles(int index, const char* value) {
  handles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:server.TUsersFetch.Handles.handles)
}
inline void TUsersFetch_Handles::set_handles(int index, const char* value, size_t size) {
  handles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:server.TUsersFetch.Handles.handles)
}
inline ::std::string* TUsersFetch_Handles::add_handles() {
  // @@protoc_insertion_point(field_add_mutable:server.TUsersFetch.Handles.handles)
  return handles_.Add();
}
inline void TUsersFetch_Handles::add_handles(const ::std::string& value) {
  handles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:server.TUsersFetch.Handles.handles)
}
inline void TUsersFetch_Handles::add_handles(const char* value) {
  handles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:server.TUsersFetch.Handles.handles)
}
inline void TUsersFetch_Handles::add_handles(const char* value, size_t size) {
  handles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:server.TUsersFetch.Handles.handles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TUsersFetch_Handles::handles() const {
  // @@protoc_insertion_point(field_list:server.TUsersFetch.Handles.handles)
  return handles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TUsersFetch_Handles::mutable_handles() {
  // @@protoc_insertion_point(field_mutable_list:server.TUsersFetch.Handles.handles)
  return &handles_;
}

inline const TUsersFetch_Handles* TUsersFetch_Handles::internal_default_instance() {
  return &TUsersFetch_Handles_default_instance_.get();
}
// -------------------------------------------------------------------

// TUsersFetch

// optional .server.TUsersFetch.UserIds user_ids = 1;
inline bool TUsersFetch::has_user_ids() const {
  return set_case() == kUserIds;
}
inline void TUsersFetch::set_has_user_ids() {
  _oneof_case_[0] = kUserIds;
}
inline void TUsersFetch::clear_user_ids() {
  if (has_user_ids()) {
    delete set_.user_ids_;
    clear_has_set();
  }
}
inline  const ::server::TUsersFetch_UserIds& TUsersFetch::user_ids() const {
  // @@protoc_insertion_point(field_get:server.TUsersFetch.user_ids)
  return has_user_ids()
      ? *set_.user_ids_
      : ::server::TUsersFetch_UserIds::default_instance();
}
inline ::server::TUsersFetch_UserIds* TUsersFetch::mutable_user_ids() {
  if (!has_user_ids()) {
    clear_set();
    set_has_user_ids();
    set_.user_ids_ = new ::server::TUsersFetch_UserIds;
  }
  // @@protoc_insertion_point(field_mutable:server.TUsersFetch.user_ids)
  return set_.user_ids_;
}
inline ::server::TUsersFetch_UserIds* TUsersFetch::release_user_ids() {
  // @@protoc_insertion_point(field_release:server.TUsersFetch.user_ids)
  if (has_user_ids()) {
    clear_has_set();
    ::server::TUsersFetch_UserIds* temp = set_.user_ids_;
    set_.user_ids_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TUsersFetch::set_allocated_user_ids(::server::TUsersFetch_UserIds* user_ids) {
  clear_set();
  if (user_ids) {
    set_has_user_ids();
    set_.user_ids_ = user_ids;
  }
  // @@protoc_insertion_point(field_set_allocated:server.TUsersFetch.user_ids)
}

// optional .server.TUsersFetch.Handles handles = 2;
inline bool TUsersFetch::has_handles() const {
  return set_case() == kHandles;
}
inline void TUsersFetch::set_has_handles() {
  _oneof_case_[0] = kHandles;
}
inline void TUsersFetch::clear_handles() {
  if (has_handles()) {
    delete set_.handles_;
    clear_has_set();
  }
}
inline  const ::server::TUsersFetch_Handles& TUsersFetch::handles() const {
  // @@protoc_insertion_point(field_get:server.TUsersFetch.handles)
  return has_handles()
      ? *set_.handles_
      : ::server::TUsersFetch_Handles::default_instance();
}
inline ::server::TUsersFetch_Handles* TUsersFetch::mutable_handles() {
  if (!has_handles()) {
    clear_set();
    set_has_handles();
    set_.handles_ = new ::server::TUsersFetch_Handles;
  }
  // @@protoc_insertion_point(field_mutable:server.TUsersFetch.handles)
  return set_.handles_;
}
inline ::server::TUsersFetch_Handles* TUsersFetch::release_handles() {
  // @@protoc_insertion_point(field_release:server.TUsersFetch.handles)
  if (has_handles()) {
    clear_has_set();
    ::server::TUsersFetch_Handles* temp = set_.handles_;
    set_.handles_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TUsersFetch::set_allocated_handles(::server::TUsersFetch_Handles* handles) {
  clear_set();
  if (handles) {
    set_has_handles();
    set_.handles_ = handles;
  }
  // @@protoc_insertion_point(field_set_allocated:server.TUsersFetch.handles)
}

inline bool TUsersFetch::has_set() const {
  return set_case() != SET_NOT_SET;
}
inline void TUsersFetch::clear_has_set() {
  _oneof_case_[0] = SET_NOT_SET;
}
inline TUsersFetch::SetCase TUsersFetch::set_case() const {
  return TUsersFetch::SetCase(_oneof_case_[0]);
}
inline const TUsersFetch* TUsersFetch::internal_default_instance() {
  return &TUsersFetch_default_instance_.get();
}
// -------------------------------------------------------------------

// TUsers

// repeated .server.User users = 1;
inline int TUsers::users_size() const {
  return users_.size();
}
inline void TUsers::clear_users() {
  users_.Clear();
}
inline const ::server::User& TUsers::users(int index) const {
  // @@protoc_insertion_point(field_get:server.TUsers.users)
  return users_.Get(index);
}
inline ::server::User* TUsers::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:server.TUsers.users)
  return users_.Mutable(index);
}
inline ::server::User* TUsers::add_users() {
  // @@protoc_insertion_point(field_add:server.TUsers.users)
  return users_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::User >*
TUsers::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:server.TUsers.users)
  return &users_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::User >&
TUsers::users() const {
  // @@protoc_insertion_point(field_list:server.TUsers.users)
  return users_;
}

inline const TUsers* TUsers::internal_default_instance() {
  return &TUsers_default_instance_.get();
}
// -------------------------------------------------------------------

// Friend

// optional .server.User user = 1;
inline bool Friend::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void Friend::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) delete user_;
  user_ = NULL;
}
inline const ::server::User& Friend::user() const {
  // @@protoc_insertion_point(field_get:server.Friend.user)
  return user_ != NULL ? *user_
                         : *::server::User::internal_default_instance();
}
inline ::server::User* Friend::mutable_user() {
  
  if (user_ == NULL) {
    user_ = new ::server::User;
  }
  // @@protoc_insertion_point(field_mutable:server.Friend.user)
  return user_;
}
inline ::server::User* Friend::release_user() {
  // @@protoc_insertion_point(field_release:server.Friend.user)
  
  ::server::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void Friend::set_allocated_user(::server::User* user) {
  delete user_;
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.Friend.user)
}

// optional int64 type = 2;
inline void Friend::clear_type() {
  type_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Friend::type() const {
  // @@protoc_insertion_point(field_get:server.Friend.type)
  return type_;
}
inline void Friend::set_type(::google::protobuf::int64 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:server.Friend.type)
}

inline const Friend* Friend::internal_default_instance() {
  return &Friend_default_instance_.get();
}
// -------------------------------------------------------------------

// TFriendAdd

// optional bytes user_id = 1;
inline bool TFriendAdd::has_user_id() const {
  return set_case() == kUserId;
}
inline void TFriendAdd::set_has_user_id() {
  _oneof_case_[0] = kUserId;
}
inline void TFriendAdd::clear_user_id() {
  if (has_user_id()) {
    set_.user_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_set();
  }
}
inline const ::std::string& TFriendAdd::user_id() const {
  // @@protoc_insertion_point(field_get:server.TFriendAdd.user_id)
  if (has_user_id()) {
    return set_.user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TFriendAdd::set_user_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TFriendAdd.user_id)
  if (!has_user_id()) {
    clear_set();
    set_has_user_id();
    set_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  set_.user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TFriendAdd.user_id)
}
inline void TFriendAdd::set_user_id(const char* value) {
  if (!has_user_id()) {
    clear_set();
    set_has_user_id();
    set_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  set_.user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TFriendAdd.user_id)
}
inline void TFriendAdd::set_user_id(const void* value, size_t size) {
  if (!has_user_id()) {
    clear_set();
    set_has_user_id();
    set_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  set_.user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TFriendAdd.user_id)
}
inline ::std::string* TFriendAdd::mutable_user_id() {
  if (!has_user_id()) {
    clear_set();
    set_has_user_id();
    set_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TFriendAdd.user_id)
  return set_.user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TFriendAdd::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TFriendAdd.user_id)
  if (has_user_id()) {
    clear_has_set();
    return set_.user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TFriendAdd::set_allocated_user_id(::std::string* user_id) {
  if (!has_user_id()) {
    set_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_set();
  if (user_id != NULL) {
    set_has_user_id();
    set_.user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        user_id);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TFriendAdd.user_id)
}

// optional string handle = 2;
inline bool TFriendAdd::has_handle() const {
  return set_case() == kHandle;
}
inline void TFriendAdd::set_has_handle() {
  _oneof_case_[0] = kHandle;
}
inline void TFriendAdd::clear_handle() {
  if (has_handle()) {
    set_.handle_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_set();
  }
}
inline const ::std::string& TFriendAdd::handle() const {
  // @@protoc_insertion_point(field_get:server.TFriendAdd.handle)
  if (has_handle()) {
    return set_.handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TFriendAdd::set_handle(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TFriendAdd.handle)
  if (!has_handle()) {
    clear_set();
    set_has_handle();
    set_.handle_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  set_.handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TFriendAdd.handle)
}
inline void TFriendAdd::set_handle(const char* value) {
  if (!has_handle()) {
    clear_set();
    set_has_handle();
    set_.handle_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  set_.handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TFriendAdd.handle)
}
inline void TFriendAdd::set_handle(const char* value, size_t size) {
  if (!has_handle()) {
    clear_set();
    set_has_handle();
    set_.handle_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  set_.handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TFriendAdd.handle)
}
inline ::std::string* TFriendAdd::mutable_handle() {
  if (!has_handle()) {
    clear_set();
    set_has_handle();
    set_.handle_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TFriendAdd.handle)
  return set_.handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TFriendAdd::release_handle() {
  // @@protoc_insertion_point(field_release:server.TFriendAdd.handle)
  if (has_handle()) {
    clear_has_set();
    return set_.handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TFriendAdd::set_allocated_handle(::std::string* handle) {
  if (!has_handle()) {
    set_.handle_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_set();
  if (handle != NULL) {
    set_has_handle();
    set_.handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        handle);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TFriendAdd.handle)
}

inline bool TFriendAdd::has_set() const {
  return set_case() != SET_NOT_SET;
}
inline void TFriendAdd::clear_has_set() {
  _oneof_case_[0] = SET_NOT_SET;
}
inline TFriendAdd::SetCase TFriendAdd::set_case() const {
  return TFriendAdd::SetCase(_oneof_case_[0]);
}
inline const TFriendAdd* TFriendAdd::internal_default_instance() {
  return &TFriendAdd_default_instance_.get();
}
// -------------------------------------------------------------------

// TFriendRemove

// optional bytes user_id = 1;
inline void TFriendRemove::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TFriendRemove::user_id() const {
  // @@protoc_insertion_point(field_get:server.TFriendRemove.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TFriendRemove::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TFriendRemove.user_id)
}
inline void TFriendRemove::set_user_id(const char* value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TFriendRemove.user_id)
}
inline void TFriendRemove::set_user_id(const void* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TFriendRemove.user_id)
}
inline ::std::string* TFriendRemove::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TFriendRemove.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TFriendRemove::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TFriendRemove.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TFriendRemove::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:server.TFriendRemove.user_id)
}

inline const TFriendRemove* TFriendRemove::internal_default_instance() {
  return &TFriendRemove_default_instance_.get();
}
// -------------------------------------------------------------------

// TFriendBlock

// optional bytes user_id = 1;
inline void TFriendBlock::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TFriendBlock::user_id() const {
  // @@protoc_insertion_point(field_get:server.TFriendBlock.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TFriendBlock::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TFriendBlock.user_id)
}
inline void TFriendBlock::set_user_id(const char* value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TFriendBlock.user_id)
}
inline void TFriendBlock::set_user_id(const void* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TFriendBlock.user_id)
}
inline ::std::string* TFriendBlock::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TFriendBlock.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TFriendBlock::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TFriendBlock.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TFriendBlock::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:server.TFriendBlock.user_id)
}

inline const TFriendBlock* TFriendBlock::internal_default_instance() {
  return &TFriendBlock_default_instance_.get();
}
// -------------------------------------------------------------------

// TFriendsList

inline const TFriendsList* TFriendsList::internal_default_instance() {
  return &TFriendsList_default_instance_.get();
}
// -------------------------------------------------------------------

// TFriends

// repeated .server.Friend friends = 1;
inline int TFriends::friends_size() const {
  return friends_.size();
}
inline void TFriends::clear_friends() {
  friends_.Clear();
}
inline const ::server::Friend& TFriends::friends(int index) const {
  // @@protoc_insertion_point(field_get:server.TFriends.friends)
  return friends_.Get(index);
}
inline ::server::Friend* TFriends::mutable_friends(int index) {
  // @@protoc_insertion_point(field_mutable:server.TFriends.friends)
  return friends_.Mutable(index);
}
inline ::server::Friend* TFriends::add_friends() {
  // @@protoc_insertion_point(field_add:server.TFriends.friends)
  return friends_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::Friend >*
TFriends::mutable_friends() {
  // @@protoc_insertion_point(field_mutable_list:server.TFriends.friends)
  return &friends_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::Friend >&
TFriends::friends() const {
  // @@protoc_insertion_point(field_list:server.TFriends.friends)
  return friends_;
}

inline const TFriends* TFriends::internal_default_instance() {
  return &TFriends_default_instance_.get();
}
// -------------------------------------------------------------------

// Group

// optional bytes id = 1;
inline void Group::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::id() const {
  // @@protoc_insertion_point(field_get:server.Group.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Group.id)
}
inline void Group::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Group.id)
}
inline void Group::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Group.id)
}
inline ::std::string* Group::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Group.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_id() {
  // @@protoc_insertion_point(field_release:server.Group.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:server.Group.id)
}

// optional bool private = 2;
inline void Group::clear_private_() {
  private__ = false;
}
inline bool Group::private_() const {
  // @@protoc_insertion_point(field_get:server.Group.private)
  return private__;
}
inline void Group::set_private_(bool value) {
  
  private__ = value;
  // @@protoc_insertion_point(field_set:server.Group.private)
}

// optional bytes creator_id = 3;
inline void Group::clear_creator_id() {
  creator_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::creator_id() const {
  // @@protoc_insertion_point(field_get:server.Group.creator_id)
  return creator_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_creator_id(const ::std::string& value) {
  
  creator_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Group.creator_id)
}
inline void Group::set_creator_id(const char* value) {
  
  creator_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Group.creator_id)
}
inline void Group::set_creator_id(const void* value, size_t size) {
  
  creator_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Group.creator_id)
}
inline ::std::string* Group::mutable_creator_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Group.creator_id)
  return creator_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_creator_id() {
  // @@protoc_insertion_point(field_release:server.Group.creator_id)
  
  return creator_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_creator_id(::std::string* creator_id) {
  if (creator_id != NULL) {
    
  } else {
    
  }
  creator_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), creator_id);
  // @@protoc_insertion_point(field_set_allocated:server.Group.creator_id)
}

// optional string name = 4;
inline void Group::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:server.Group.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Group.name)
}
inline void Group::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Group.name)
}
inline void Group::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Group.name)
}
inline ::std::string* Group::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:server.Group.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_name() {
  // @@protoc_insertion_point(field_release:server.Group.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:server.Group.name)
}

// optional string description = 5;
inline void Group::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::description() const {
  // @@protoc_insertion_point(field_get:server.Group.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Group.description)
}
inline void Group::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Group.description)
}
inline void Group::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Group.description)
}
inline ::std::string* Group::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:server.Group.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_description() {
  // @@protoc_insertion_point(field_release:server.Group.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:server.Group.description)
}

// optional string avatar_url = 6;
inline void Group::clear_avatar_url() {
  avatar_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::avatar_url() const {
  // @@protoc_insertion_point(field_get:server.Group.avatar_url)
  return avatar_url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_avatar_url(const ::std::string& value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Group.avatar_url)
}
inline void Group::set_avatar_url(const char* value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Group.avatar_url)
}
inline void Group::set_avatar_url(const char* value, size_t size) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Group.avatar_url)
}
inline ::std::string* Group::mutable_avatar_url() {
  
  // @@protoc_insertion_point(field_mutable:server.Group.avatar_url)
  return avatar_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_avatar_url() {
  // @@protoc_insertion_point(field_release:server.Group.avatar_url)
  
  return avatar_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url != NULL) {
    
  } else {
    
  }
  avatar_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar_url);
  // @@protoc_insertion_point(field_set_allocated:server.Group.avatar_url)
}

// optional string lang = 7;
inline void Group::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::lang() const {
  // @@protoc_insertion_point(field_get:server.Group.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Group.lang)
}
inline void Group::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Group.lang)
}
inline void Group::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Group.lang)
}
inline ::std::string* Group::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:server.Group.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_lang() {
  // @@protoc_insertion_point(field_release:server.Group.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:server.Group.lang)
}

// optional int64 utc_offset_ms = 8;
inline void Group::clear_utc_offset_ms() {
  utc_offset_ms_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Group::utc_offset_ms() const {
  // @@protoc_insertion_point(field_get:server.Group.utc_offset_ms)
  return utc_offset_ms_;
}
inline void Group::set_utc_offset_ms(::google::protobuf::int64 value) {
  
  utc_offset_ms_ = value;
  // @@protoc_insertion_point(field_set:server.Group.utc_offset_ms)
}

// optional bytes metadata = 9;
inline void Group::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Group::metadata() const {
  // @@protoc_insertion_point(field_get:server.Group.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Group.metadata)
}
inline void Group::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Group.metadata)
}
inline void Group::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Group.metadata)
}
inline ::std::string* Group::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:server.Group.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_metadata() {
  // @@protoc_insertion_point(field_release:server.Group.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:server.Group.metadata)
}

// optional int64 count = 10;
inline void Group::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Group::count() const {
  // @@protoc_insertion_point(field_get:server.Group.count)
  return count_;
}
inline void Group::set_count(::google::protobuf::int64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:server.Group.count)
}

// optional int64 created_at = 11;
inline void Group::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Group::created_at() const {
  // @@protoc_insertion_point(field_get:server.Group.created_at)
  return created_at_;
}
inline void Group::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:server.Group.created_at)
}

// optional int64 updated_at = 12;
inline void Group::clear_updated_at() {
  updated_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Group::updated_at() const {
  // @@protoc_insertion_point(field_get:server.Group.updated_at)
  return updated_at_;
}
inline void Group::set_updated_at(::google::protobuf::int64 value) {
  
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:server.Group.updated_at)
}

inline const Group* Group::internal_default_instance() {
  return &Group_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupCreate

// optional string name = 1;
inline void TGroupCreate::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupCreate::name() const {
  // @@protoc_insertion_point(field_get:server.TGroupCreate.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupCreate.name)
}
inline void TGroupCreate::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupCreate.name)
}
inline void TGroupCreate::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupCreate.name)
}
inline ::std::string* TGroupCreate::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupCreate.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupCreate::release_name() {
  // @@protoc_insertion_point(field_release:server.TGroupCreate.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupCreate.name)
}

// optional string description = 2;
inline void TGroupCreate::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupCreate::description() const {
  // @@protoc_insertion_point(field_get:server.TGroupCreate.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupCreate.description)
}
inline void TGroupCreate::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupCreate.description)
}
inline void TGroupCreate::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupCreate.description)
}
inline ::std::string* TGroupCreate::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupCreate.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupCreate::release_description() {
  // @@protoc_insertion_point(field_release:server.TGroupCreate.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupCreate.description)
}

// optional string avatar_url = 3;
inline void TGroupCreate::clear_avatar_url() {
  avatar_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupCreate::avatar_url() const {
  // @@protoc_insertion_point(field_get:server.TGroupCreate.avatar_url)
  return avatar_url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_avatar_url(const ::std::string& value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupCreate.avatar_url)
}
inline void TGroupCreate::set_avatar_url(const char* value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupCreate.avatar_url)
}
inline void TGroupCreate::set_avatar_url(const char* value, size_t size) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupCreate.avatar_url)
}
inline ::std::string* TGroupCreate::mutable_avatar_url() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupCreate.avatar_url)
  return avatar_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupCreate::release_avatar_url() {
  // @@protoc_insertion_point(field_release:server.TGroupCreate.avatar_url)
  
  return avatar_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url != NULL) {
    
  } else {
    
  }
  avatar_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar_url);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupCreate.avatar_url)
}

// optional string lang = 4;
inline void TGroupCreate::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupCreate::lang() const {
  // @@protoc_insertion_point(field_get:server.TGroupCreate.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupCreate.lang)
}
inline void TGroupCreate::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupCreate.lang)
}
inline void TGroupCreate::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupCreate.lang)
}
inline ::std::string* TGroupCreate::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupCreate.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupCreate::release_lang() {
  // @@protoc_insertion_point(field_release:server.TGroupCreate.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupCreate.lang)
}

// optional bytes metadata = 5;
inline void TGroupCreate::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupCreate::metadata() const {
  // @@protoc_insertion_point(field_get:server.TGroupCreate.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupCreate.metadata)
}
inline void TGroupCreate::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupCreate.metadata)
}
inline void TGroupCreate::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupCreate.metadata)
}
inline ::std::string* TGroupCreate::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupCreate.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupCreate::release_metadata() {
  // @@protoc_insertion_point(field_release:server.TGroupCreate.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupCreate::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupCreate.metadata)
}

// optional bool private = 6;
inline void TGroupCreate::clear_private_() {
  private__ = false;
}
inline bool TGroupCreate::private_() const {
  // @@protoc_insertion_point(field_get:server.TGroupCreate.private)
  return private__;
}
inline void TGroupCreate::set_private_(bool value) {
  
  private__ = value;
  // @@protoc_insertion_point(field_set:server.TGroupCreate.private)
}

inline const TGroupCreate* TGroupCreate::internal_default_instance() {
  return &TGroupCreate_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroup

// optional .server.Group group = 1;
inline bool TGroup::has_group() const {
  return this != internal_default_instance() && group_ != NULL;
}
inline void TGroup::clear_group() {
  if (GetArenaNoVirtual() == NULL && group_ != NULL) delete group_;
  group_ = NULL;
}
inline const ::server::Group& TGroup::group() const {
  // @@protoc_insertion_point(field_get:server.TGroup.group)
  return group_ != NULL ? *group_
                         : *::server::Group::internal_default_instance();
}
inline ::server::Group* TGroup::mutable_group() {
  
  if (group_ == NULL) {
    group_ = new ::server::Group;
  }
  // @@protoc_insertion_point(field_mutable:server.TGroup.group)
  return group_;
}
inline ::server::Group* TGroup::release_group() {
  // @@protoc_insertion_point(field_release:server.TGroup.group)
  
  ::server::Group* temp = group_;
  group_ = NULL;
  return temp;
}
inline void TGroup::set_allocated_group(::server::Group* group) {
  delete group_;
  group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TGroup.group)
}

inline const TGroup* TGroup::internal_default_instance() {
  return &TGroup_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupUpdate

// optional bytes group_id = 1;
inline void TGroupUpdate::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUpdate::group_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupUpdate.group_id)
  return group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUpdate.group_id)
}
inline void TGroupUpdate::set_group_id(const char* value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUpdate.group_id)
}
inline void TGroupUpdate::set_group_id(const void* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUpdate.group_id)
}
inline ::std::string* TGroupUpdate::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUpdate.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUpdate::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TGroupUpdate.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUpdate.group_id)
}

// optional bool private = 2;
inline void TGroupUpdate::clear_private_() {
  private__ = false;
}
inline bool TGroupUpdate::private_() const {
  // @@protoc_insertion_point(field_get:server.TGroupUpdate.private)
  return private__;
}
inline void TGroupUpdate::set_private_(bool value) {
  
  private__ = value;
  // @@protoc_insertion_point(field_set:server.TGroupUpdate.private)
}

// optional string name = 3;
inline void TGroupUpdate::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUpdate::name() const {
  // @@protoc_insertion_point(field_get:server.TGroupUpdate.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUpdate.name)
}
inline void TGroupUpdate::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUpdate.name)
}
inline void TGroupUpdate::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUpdate.name)
}
inline ::std::string* TGroupUpdate::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUpdate.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUpdate::release_name() {
  // @@protoc_insertion_point(field_release:server.TGroupUpdate.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUpdate.name)
}

// optional string description = 4;
inline void TGroupUpdate::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUpdate::description() const {
  // @@protoc_insertion_point(field_get:server.TGroupUpdate.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUpdate.description)
}
inline void TGroupUpdate::set_description(const char* value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUpdate.description)
}
inline void TGroupUpdate::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUpdate.description)
}
inline ::std::string* TGroupUpdate::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUpdate.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUpdate::release_description() {
  // @@protoc_insertion_point(field_release:server.TGroupUpdate.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUpdate.description)
}

// optional string avatar_url = 5;
inline void TGroupUpdate::clear_avatar_url() {
  avatar_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUpdate::avatar_url() const {
  // @@protoc_insertion_point(field_get:server.TGroupUpdate.avatar_url)
  return avatar_url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_avatar_url(const ::std::string& value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUpdate.avatar_url)
}
inline void TGroupUpdate::set_avatar_url(const char* value) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUpdate.avatar_url)
}
inline void TGroupUpdate::set_avatar_url(const char* value, size_t size) {
  
  avatar_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUpdate.avatar_url)
}
inline ::std::string* TGroupUpdate::mutable_avatar_url() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUpdate.avatar_url)
  return avatar_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUpdate::release_avatar_url() {
  // @@protoc_insertion_point(field_release:server.TGroupUpdate.avatar_url)
  
  return avatar_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url != NULL) {
    
  } else {
    
  }
  avatar_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar_url);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUpdate.avatar_url)
}

// optional string lang = 6;
inline void TGroupUpdate::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUpdate::lang() const {
  // @@protoc_insertion_point(field_get:server.TGroupUpdate.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUpdate.lang)
}
inline void TGroupUpdate::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUpdate.lang)
}
inline void TGroupUpdate::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUpdate.lang)
}
inline ::std::string* TGroupUpdate::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUpdate.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUpdate::release_lang() {
  // @@protoc_insertion_point(field_release:server.TGroupUpdate.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUpdate.lang)
}

// optional bytes metadata = 7;
inline void TGroupUpdate::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUpdate::metadata() const {
  // @@protoc_insertion_point(field_get:server.TGroupUpdate.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUpdate.metadata)
}
inline void TGroupUpdate::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUpdate.metadata)
}
inline void TGroupUpdate::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUpdate.metadata)
}
inline ::std::string* TGroupUpdate::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUpdate.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUpdate::release_metadata() {
  // @@protoc_insertion_point(field_release:server.TGroupUpdate.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUpdate::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUpdate.metadata)
}

inline const TGroupUpdate* TGroupUpdate::internal_default_instance() {
  return &TGroupUpdate_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupRemove

// optional bytes group_id = 1;
inline void TGroupRemove::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupRemove::group_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupRemove.group_id)
  return group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupRemove::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupRemove.group_id)
}
inline void TGroupRemove::set_group_id(const char* value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupRemove.group_id)
}
inline void TGroupRemove::set_group_id(const void* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupRemove.group_id)
}
inline ::std::string* TGroupRemove::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupRemove.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupRemove::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TGroupRemove.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupRemove::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupRemove.group_id)
}

inline const TGroupRemove* TGroupRemove::internal_default_instance() {
  return &TGroupRemove_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupsSelfList

inline const TGroupsSelfList* TGroupsSelfList::internal_default_instance() {
  return &TGroupsSelfList_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupsFetch_GroupIds

// repeated bytes group_ids = 1;
inline int TGroupsFetch_GroupIds::group_ids_size() const {
  return group_ids_.size();
}
inline void TGroupsFetch_GroupIds::clear_group_ids() {
  group_ids_.Clear();
}
inline const ::std::string& TGroupsFetch_GroupIds::group_ids(int index) const {
  // @@protoc_insertion_point(field_get:server.TGroupsFetch.GroupIds.group_ids)
  return group_ids_.Get(index);
}
inline ::std::string* TGroupsFetch_GroupIds::mutable_group_ids(int index) {
  // @@protoc_insertion_point(field_mutable:server.TGroupsFetch.GroupIds.group_ids)
  return group_ids_.Mutable(index);
}
inline void TGroupsFetch_GroupIds::set_group_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TGroupsFetch.GroupIds.group_ids)
  group_ids_.Mutable(index)->assign(value);
}
inline void TGroupsFetch_GroupIds::set_group_ids(int index, const char* value) {
  group_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:server.TGroupsFetch.GroupIds.group_ids)
}
inline void TGroupsFetch_GroupIds::set_group_ids(int index, const void* value, size_t size) {
  group_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:server.TGroupsFetch.GroupIds.group_ids)
}
inline ::std::string* TGroupsFetch_GroupIds::add_group_ids() {
  // @@protoc_insertion_point(field_add_mutable:server.TGroupsFetch.GroupIds.group_ids)
  return group_ids_.Add();
}
inline void TGroupsFetch_GroupIds::add_group_ids(const ::std::string& value) {
  group_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:server.TGroupsFetch.GroupIds.group_ids)
}
inline void TGroupsFetch_GroupIds::add_group_ids(const char* value) {
  group_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:server.TGroupsFetch.GroupIds.group_ids)
}
inline void TGroupsFetch_GroupIds::add_group_ids(const void* value, size_t size) {
  group_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:server.TGroupsFetch.GroupIds.group_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TGroupsFetch_GroupIds::group_ids() const {
  // @@protoc_insertion_point(field_list:server.TGroupsFetch.GroupIds.group_ids)
  return group_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TGroupsFetch_GroupIds::mutable_group_ids() {
  // @@protoc_insertion_point(field_mutable_list:server.TGroupsFetch.GroupIds.group_ids)
  return &group_ids_;
}

inline const TGroupsFetch_GroupIds* TGroupsFetch_GroupIds::internal_default_instance() {
  return &TGroupsFetch_GroupIds_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupsFetch_Names

// repeated string names = 1;
inline int TGroupsFetch_Names::names_size() const {
  return names_.size();
}
inline void TGroupsFetch_Names::clear_names() {
  names_.Clear();
}
inline const ::std::string& TGroupsFetch_Names::names(int index) const {
  // @@protoc_insertion_point(field_get:server.TGroupsFetch.Names.names)
  return names_.Get(index);
}
inline ::std::string* TGroupsFetch_Names::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:server.TGroupsFetch.Names.names)
  return names_.Mutable(index);
}
inline void TGroupsFetch_Names::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TGroupsFetch.Names.names)
  names_.Mutable(index)->assign(value);
}
inline void TGroupsFetch_Names::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:server.TGroupsFetch.Names.names)
}
inline void TGroupsFetch_Names::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:server.TGroupsFetch.Names.names)
}
inline ::std::string* TGroupsFetch_Names::add_names() {
  // @@protoc_insertion_point(field_add_mutable:server.TGroupsFetch.Names.names)
  return names_.Add();
}
inline void TGroupsFetch_Names::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:server.TGroupsFetch.Names.names)
}
inline void TGroupsFetch_Names::add_names(const char* value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:server.TGroupsFetch.Names.names)
}
inline void TGroupsFetch_Names::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:server.TGroupsFetch.Names.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TGroupsFetch_Names::names() const {
  // @@protoc_insertion_point(field_list:server.TGroupsFetch.Names.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TGroupsFetch_Names::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:server.TGroupsFetch.Names.names)
  return &names_;
}

inline const TGroupsFetch_Names* TGroupsFetch_Names::internal_default_instance() {
  return &TGroupsFetch_Names_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupsFetch

// optional .server.TGroupsFetch.GroupIds group_ids = 1;
inline bool TGroupsFetch::has_group_ids() const {
  return set_case() == kGroupIds;
}
inline void TGroupsFetch::set_has_group_ids() {
  _oneof_case_[0] = kGroupIds;
}
inline void TGroupsFetch::clear_group_ids() {
  if (has_group_ids()) {
    delete set_.group_ids_;
    clear_has_set();
  }
}
inline  const ::server::TGroupsFetch_GroupIds& TGroupsFetch::group_ids() const {
  // @@protoc_insertion_point(field_get:server.TGroupsFetch.group_ids)
  return has_group_ids()
      ? *set_.group_ids_
      : ::server::TGroupsFetch_GroupIds::default_instance();
}
inline ::server::TGroupsFetch_GroupIds* TGroupsFetch::mutable_group_ids() {
  if (!has_group_ids()) {
    clear_set();
    set_has_group_ids();
    set_.group_ids_ = new ::server::TGroupsFetch_GroupIds;
  }
  // @@protoc_insertion_point(field_mutable:server.TGroupsFetch.group_ids)
  return set_.group_ids_;
}
inline ::server::TGroupsFetch_GroupIds* TGroupsFetch::release_group_ids() {
  // @@protoc_insertion_point(field_release:server.TGroupsFetch.group_ids)
  if (has_group_ids()) {
    clear_has_set();
    ::server::TGroupsFetch_GroupIds* temp = set_.group_ids_;
    set_.group_ids_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TGroupsFetch::set_allocated_group_ids(::server::TGroupsFetch_GroupIds* group_ids) {
  clear_set();
  if (group_ids) {
    set_has_group_ids();
    set_.group_ids_ = group_ids;
  }
  // @@protoc_insertion_point(field_set_allocated:server.TGroupsFetch.group_ids)
}

// optional .server.TGroupsFetch.Names names = 2;
inline bool TGroupsFetch::has_names() const {
  return set_case() == kNames;
}
inline void TGroupsFetch::set_has_names() {
  _oneof_case_[0] = kNames;
}
inline void TGroupsFetch::clear_names() {
  if (has_names()) {
    delete set_.names_;
    clear_has_set();
  }
}
inline  const ::server::TGroupsFetch_Names& TGroupsFetch::names() const {
  // @@protoc_insertion_point(field_get:server.TGroupsFetch.names)
  return has_names()
      ? *set_.names_
      : ::server::TGroupsFetch_Names::default_instance();
}
inline ::server::TGroupsFetch_Names* TGroupsFetch::mutable_names() {
  if (!has_names()) {
    clear_set();
    set_has_names();
    set_.names_ = new ::server::TGroupsFetch_Names;
  }
  // @@protoc_insertion_point(field_mutable:server.TGroupsFetch.names)
  return set_.names_;
}
inline ::server::TGroupsFetch_Names* TGroupsFetch::release_names() {
  // @@protoc_insertion_point(field_release:server.TGroupsFetch.names)
  if (has_names()) {
    clear_has_set();
    ::server::TGroupsFetch_Names* temp = set_.names_;
    set_.names_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TGroupsFetch::set_allocated_names(::server::TGroupsFetch_Names* names) {
  clear_set();
  if (names) {
    set_has_names();
    set_.names_ = names;
  }
  // @@protoc_insertion_point(field_set_allocated:server.TGroupsFetch.names)
}

inline bool TGroupsFetch::has_set() const {
  return set_case() != SET_NOT_SET;
}
inline void TGroupsFetch::clear_has_set() {
  _oneof_case_[0] = SET_NOT_SET;
}
inline TGroupsFetch::SetCase TGroupsFetch::set_case() const {
  return TGroupsFetch::SetCase(_oneof_case_[0]);
}
inline const TGroupsFetch* TGroupsFetch::internal_default_instance() {
  return &TGroupsFetch_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupsList

// optional int64 page_limit = 1;
inline void TGroupsList::clear_page_limit() {
  page_limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TGroupsList::page_limit() const {
  // @@protoc_insertion_point(field_get:server.TGroupsList.page_limit)
  return page_limit_;
}
inline void TGroupsList::set_page_limit(::google::protobuf::int64 value) {
  
  page_limit_ = value;
  // @@protoc_insertion_point(field_set:server.TGroupsList.page_limit)
}

// optional bool order_by_asc = 2;
inline void TGroupsList::clear_order_by_asc() {
  order_by_asc_ = false;
}
inline bool TGroupsList::order_by_asc() const {
  // @@protoc_insertion_point(field_get:server.TGroupsList.order_by_asc)
  return order_by_asc_;
}
inline void TGroupsList::set_order_by_asc(bool value) {
  
  order_by_asc_ = value;
  // @@protoc_insertion_point(field_set:server.TGroupsList.order_by_asc)
}

// optional string lang = 3;
inline bool TGroupsList::has_lang() const {
  return filter_case() == kLang;
}
inline void TGroupsList::set_has_lang() {
  _oneof_case_[0] = kLang;
}
inline void TGroupsList::clear_lang() {
  if (has_lang()) {
    filter_.lang_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_filter();
  }
}
inline const ::std::string& TGroupsList::lang() const {
  // @@protoc_insertion_point(field_get:server.TGroupsList.lang)
  if (has_lang()) {
    return filter_.lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TGroupsList::set_lang(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TGroupsList.lang)
  if (!has_lang()) {
    clear_filter();
    set_has_lang();
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupsList.lang)
}
inline void TGroupsList::set_lang(const char* value) {
  if (!has_lang()) {
    clear_filter();
    set_has_lang();
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupsList.lang)
}
inline void TGroupsList::set_lang(const char* value, size_t size) {
  if (!has_lang()) {
    clear_filter();
    set_has_lang();
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupsList.lang)
}
inline ::std::string* TGroupsList::mutable_lang() {
  if (!has_lang()) {
    clear_filter();
    set_has_lang();
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TGroupsList.lang)
  return filter_.lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupsList::release_lang() {
  // @@protoc_insertion_point(field_release:server.TGroupsList.lang)
  if (has_lang()) {
    clear_has_filter();
    return filter_.lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TGroupsList::set_allocated_lang(::std::string* lang) {
  if (!has_lang()) {
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_filter();
  if (lang != NULL) {
    set_has_lang();
    filter_.lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        lang);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TGroupsList.lang)
}

// optional int64 created_at = 4;
inline bool TGroupsList::has_created_at() const {
  return filter_case() == kCreatedAt;
}
inline void TGroupsList::set_has_created_at() {
  _oneof_case_[0] = kCreatedAt;
}
inline void TGroupsList::clear_created_at() {
  if (has_created_at()) {
    filter_.created_at_ = GOOGLE_LONGLONG(0);
    clear_has_filter();
  }
}
inline ::google::protobuf::int64 TGroupsList::created_at() const {
  // @@protoc_insertion_point(field_get:server.TGroupsList.created_at)
  if (has_created_at()) {
    return filter_.created_at_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void TGroupsList::set_created_at(::google::protobuf::int64 value) {
  if (!has_created_at()) {
    clear_filter();
    set_has_created_at();
  }
  filter_.created_at_ = value;
  // @@protoc_insertion_point(field_set:server.TGroupsList.created_at)
}

// optional int64 count = 5;
inline bool TGroupsList::has_count() const {
  return filter_case() == kCount;
}
inline void TGroupsList::set_has_count() {
  _oneof_case_[0] = kCount;
}
inline void TGroupsList::clear_count() {
  if (has_count()) {
    filter_.count_ = GOOGLE_LONGLONG(0);
    clear_has_filter();
  }
}
inline ::google::protobuf::int64 TGroupsList::count() const {
  // @@protoc_insertion_point(field_get:server.TGroupsList.count)
  if (has_count()) {
    return filter_.count_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void TGroupsList::set_count(::google::protobuf::int64 value) {
  if (!has_count()) {
    clear_filter();
    set_has_count();
  }
  filter_.count_ = value;
  // @@protoc_insertion_point(field_set:server.TGroupsList.count)
}

// optional bytes cursor = 7;
inline void TGroupsList::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupsList::cursor() const {
  // @@protoc_insertion_point(field_get:server.TGroupsList.cursor)
  return cursor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupsList::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupsList.cursor)
}
inline void TGroupsList::set_cursor(const char* value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupsList.cursor)
}
inline void TGroupsList::set_cursor(const void* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupsList.cursor)
}
inline ::std::string* TGroupsList::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupsList.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupsList::release_cursor() {
  // @@protoc_insertion_point(field_release:server.TGroupsList.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupsList::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupsList.cursor)
}

inline bool TGroupsList::has_filter() const {
  return filter_case() != FILTER_NOT_SET;
}
inline void TGroupsList::clear_has_filter() {
  _oneof_case_[0] = FILTER_NOT_SET;
}
inline TGroupsList::FilterCase TGroupsList::filter_case() const {
  return TGroupsList::FilterCase(_oneof_case_[0]);
}
inline const TGroupsList* TGroupsList::internal_default_instance() {
  return &TGroupsList_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroups

// repeated .server.Group groups = 1;
inline int TGroups::groups_size() const {
  return groups_.size();
}
inline void TGroups::clear_groups() {
  groups_.Clear();
}
inline const ::server::Group& TGroups::groups(int index) const {
  // @@protoc_insertion_point(field_get:server.TGroups.groups)
  return groups_.Get(index);
}
inline ::server::Group* TGroups::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:server.TGroups.groups)
  return groups_.Mutable(index);
}
inline ::server::Group* TGroups::add_groups() {
  // @@protoc_insertion_point(field_add:server.TGroups.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::Group >*
TGroups::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:server.TGroups.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::Group >&
TGroups::groups() const {
  // @@protoc_insertion_point(field_list:server.TGroups.groups)
  return groups_;
}

// optional bytes cursor = 2;
inline void TGroups::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroups::cursor() const {
  // @@protoc_insertion_point(field_get:server.TGroups.cursor)
  return cursor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroups::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroups.cursor)
}
inline void TGroups::set_cursor(const char* value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroups.cursor)
}
inline void TGroups::set_cursor(const void* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroups.cursor)
}
inline ::std::string* TGroups::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroups.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroups::release_cursor() {
  // @@protoc_insertion_point(field_release:server.TGroups.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroups::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:server.TGroups.cursor)
}

inline const TGroups* TGroups::internal_default_instance() {
  return &TGroups_default_instance_.get();
}
// -------------------------------------------------------------------

// GroupUser

// optional .server.User user = 1;
inline bool GroupUser::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void GroupUser::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) delete user_;
  user_ = NULL;
}
inline const ::server::User& GroupUser::user() const {
  // @@protoc_insertion_point(field_get:server.GroupUser.user)
  return user_ != NULL ? *user_
                         : *::server::User::internal_default_instance();
}
inline ::server::User* GroupUser::mutable_user() {
  
  if (user_ == NULL) {
    user_ = new ::server::User;
  }
  // @@protoc_insertion_point(field_mutable:server.GroupUser.user)
  return user_;
}
inline ::server::User* GroupUser::release_user() {
  // @@protoc_insertion_point(field_release:server.GroupUser.user)
  
  ::server::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void GroupUser::set_allocated_user(::server::User* user) {
  delete user_;
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.GroupUser.user)
}

// optional int64 type = 2;
inline void GroupUser::clear_type() {
  type_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GroupUser::type() const {
  // @@protoc_insertion_point(field_get:server.GroupUser.type)
  return type_;
}
inline void GroupUser::set_type(::google::protobuf::int64 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:server.GroupUser.type)
}

inline const GroupUser* GroupUser::internal_default_instance() {
  return &GroupUser_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupUsersList

// optional bytes group_id = 1;
inline void TGroupUsersList::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUsersList::group_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupUsersList.group_id)
  return group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUsersList::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUsersList.group_id)
}
inline void TGroupUsersList::set_group_id(const char* value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUsersList.group_id)
}
inline void TGroupUsersList::set_group_id(const void* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUsersList.group_id)
}
inline ::std::string* TGroupUsersList::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUsersList.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUsersList::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TGroupUsersList.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUsersList::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUsersList.group_id)
}

inline const TGroupUsersList* TGroupUsersList::internal_default_instance() {
  return &TGroupUsersList_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupUsers

// repeated .server.GroupUser users = 1;
inline int TGroupUsers::users_size() const {
  return users_.size();
}
inline void TGroupUsers::clear_users() {
  users_.Clear();
}
inline const ::server::GroupUser& TGroupUsers::users(int index) const {
  // @@protoc_insertion_point(field_get:server.TGroupUsers.users)
  return users_.Get(index);
}
inline ::server::GroupUser* TGroupUsers::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:server.TGroupUsers.users)
  return users_.Mutable(index);
}
inline ::server::GroupUser* TGroupUsers::add_users() {
  // @@protoc_insertion_point(field_add:server.TGroupUsers.users)
  return users_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::GroupUser >*
TGroupUsers::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:server.TGroupUsers.users)
  return &users_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::GroupUser >&
TGroupUsers::users() const {
  // @@protoc_insertion_point(field_list:server.TGroupUsers.users)
  return users_;
}

inline const TGroupUsers* TGroupUsers::internal_default_instance() {
  return &TGroupUsers_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupJoin

// optional bytes group_id = 1;
inline void TGroupJoin::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupJoin::group_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupJoin.group_id)
  return group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupJoin::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupJoin.group_id)
}
inline void TGroupJoin::set_group_id(const char* value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupJoin.group_id)
}
inline void TGroupJoin::set_group_id(const void* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupJoin.group_id)
}
inline ::std::string* TGroupJoin::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupJoin.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupJoin::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TGroupJoin.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupJoin::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupJoin.group_id)
}

inline const TGroupJoin* TGroupJoin::internal_default_instance() {
  return &TGroupJoin_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupLeave

// optional bytes group_id = 1;
inline void TGroupLeave::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupLeave::group_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupLeave.group_id)
  return group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupLeave::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupLeave.group_id)
}
inline void TGroupLeave::set_group_id(const char* value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupLeave.group_id)
}
inline void TGroupLeave::set_group_id(const void* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupLeave.group_id)
}
inline ::std::string* TGroupLeave::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupLeave.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupLeave::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TGroupLeave.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupLeave::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupLeave.group_id)
}

inline const TGroupLeave* TGroupLeave::internal_default_instance() {
  return &TGroupLeave_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupUserAdd

// optional bytes group_id = 1;
inline void TGroupUserAdd::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUserAdd::group_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupUserAdd.group_id)
  return group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserAdd::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUserAdd.group_id)
}
inline void TGroupUserAdd::set_group_id(const char* value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUserAdd.group_id)
}
inline void TGroupUserAdd::set_group_id(const void* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUserAdd.group_id)
}
inline ::std::string* TGroupUserAdd::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUserAdd.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUserAdd::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TGroupUserAdd.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserAdd::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUserAdd.group_id)
}

// optional bytes user_id = 2;
inline void TGroupUserAdd::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUserAdd::user_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupUserAdd.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserAdd::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUserAdd.user_id)
}
inline void TGroupUserAdd::set_user_id(const char* value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUserAdd.user_id)
}
inline void TGroupUserAdd::set_user_id(const void* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUserAdd.user_id)
}
inline ::std::string* TGroupUserAdd::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUserAdd.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUserAdd::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TGroupUserAdd.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserAdd::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUserAdd.user_id)
}

inline const TGroupUserAdd* TGroupUserAdd::internal_default_instance() {
  return &TGroupUserAdd_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupUserKick

// optional bytes group_id = 1;
inline void TGroupUserKick::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUserKick::group_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupUserKick.group_id)
  return group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserKick::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUserKick.group_id)
}
inline void TGroupUserKick::set_group_id(const char* value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUserKick.group_id)
}
inline void TGroupUserKick::set_group_id(const void* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUserKick.group_id)
}
inline ::std::string* TGroupUserKick::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUserKick.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUserKick::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TGroupUserKick.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserKick::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUserKick.group_id)
}

// optional bytes user_id = 2;
inline void TGroupUserKick::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUserKick::user_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupUserKick.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserKick::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUserKick.user_id)
}
inline void TGroupUserKick::set_user_id(const char* value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUserKick.user_id)
}
inline void TGroupUserKick::set_user_id(const void* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUserKick.user_id)
}
inline ::std::string* TGroupUserKick::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUserKick.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUserKick::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TGroupUserKick.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserKick::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUserKick.user_id)
}

inline const TGroupUserKick* TGroupUserKick::internal_default_instance() {
  return &TGroupUserKick_default_instance_.get();
}
// -------------------------------------------------------------------

// TGroupUserPromote

// optional bytes group_id = 1;
inline void TGroupUserPromote::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUserPromote::group_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupUserPromote.group_id)
  return group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserPromote::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUserPromote.group_id)
}
inline void TGroupUserPromote::set_group_id(const char* value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUserPromote.group_id)
}
inline void TGroupUserPromote::set_group_id(const void* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUserPromote.group_id)
}
inline ::std::string* TGroupUserPromote::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUserPromote.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUserPromote::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TGroupUserPromote.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserPromote::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUserPromote.group_id)
}

// optional bytes user_id = 2;
inline void TGroupUserPromote::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TGroupUserPromote::user_id() const {
  // @@protoc_insertion_point(field_get:server.TGroupUserPromote.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserPromote::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TGroupUserPromote.user_id)
}
inline void TGroupUserPromote::set_user_id(const char* value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TGroupUserPromote.user_id)
}
inline void TGroupUserPromote::set_user_id(const void* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TGroupUserPromote.user_id)
}
inline ::std::string* TGroupUserPromote::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TGroupUserPromote.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGroupUserPromote::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TGroupUserPromote.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGroupUserPromote::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:server.TGroupUserPromote.user_id)
}

inline const TGroupUserPromote* TGroupUserPromote::internal_default_instance() {
  return &TGroupUserPromote_default_instance_.get();
}
// -------------------------------------------------------------------

// TopicId

// optional bytes dm = 1;
inline bool TopicId::has_dm() const {
  return id_case() == kDm;
}
inline void TopicId::set_has_dm() {
  _oneof_case_[0] = kDm;
}
inline void TopicId::clear_dm() {
  if (has_dm()) {
    id_.dm_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TopicId::dm() const {
  // @@protoc_insertion_point(field_get:server.TopicId.dm)
  if (has_dm()) {
    return id_.dm_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TopicId::set_dm(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TopicId.dm)
  if (!has_dm()) {
    clear_id();
    set_has_dm();
    id_.dm_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.dm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TopicId.dm)
}
inline void TopicId::set_dm(const char* value) {
  if (!has_dm()) {
    clear_id();
    set_has_dm();
    id_.dm_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.dm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TopicId.dm)
}
inline void TopicId::set_dm(const void* value, size_t size) {
  if (!has_dm()) {
    clear_id();
    set_has_dm();
    id_.dm_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.dm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TopicId.dm)
}
inline ::std::string* TopicId::mutable_dm() {
  if (!has_dm()) {
    clear_id();
    set_has_dm();
    id_.dm_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TopicId.dm)
  return id_.dm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicId::release_dm() {
  // @@protoc_insertion_point(field_release:server.TopicId.dm)
  if (has_dm()) {
    clear_has_id();
    return id_.dm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TopicId::set_allocated_dm(::std::string* dm) {
  if (!has_dm()) {
    id_.dm_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (dm != NULL) {
    set_has_dm();
    id_.dm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        dm);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TopicId.dm)
}

// optional bytes room = 2;
inline bool TopicId::has_room() const {
  return id_case() == kRoom;
}
inline void TopicId::set_has_room() {
  _oneof_case_[0] = kRoom;
}
inline void TopicId::clear_room() {
  if (has_room()) {
    id_.room_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TopicId::room() const {
  // @@protoc_insertion_point(field_get:server.TopicId.room)
  if (has_room()) {
    return id_.room_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TopicId::set_room(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TopicId.room)
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TopicId.room)
}
inline void TopicId::set_room(const char* value) {
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TopicId.room)
}
inline void TopicId::set_room(const void* value, size_t size) {
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TopicId.room)
}
inline ::std::string* TopicId::mutable_room() {
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TopicId.room)
  return id_.room_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicId::release_room() {
  // @@protoc_insertion_point(field_release:server.TopicId.room)
  if (has_room()) {
    clear_has_id();
    return id_.room_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TopicId::set_allocated_room(::std::string* room) {
  if (!has_room()) {
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (room != NULL) {
    set_has_room();
    id_.room_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        room);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TopicId.room)
}

// optional bytes group_id = 3;
inline bool TopicId::has_group_id() const {
  return id_case() == kGroupId;
}
inline void TopicId::set_has_group_id() {
  _oneof_case_[0] = kGroupId;
}
inline void TopicId::clear_group_id() {
  if (has_group_id()) {
    id_.group_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TopicId::group_id() const {
  // @@protoc_insertion_point(field_get:server.TopicId.group_id)
  if (has_group_id()) {
    return id_.group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TopicId::set_group_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TopicId.group_id)
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TopicId.group_id)
}
inline void TopicId::set_group_id(const char* value) {
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TopicId.group_id)
}
inline void TopicId::set_group_id(const void* value, size_t size) {
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TopicId.group_id)
}
inline ::std::string* TopicId::mutable_group_id() {
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TopicId.group_id)
  return id_.group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicId::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TopicId.group_id)
  if (has_group_id()) {
    clear_has_id();
    return id_.group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TopicId::set_allocated_group_id(::std::string* group_id) {
  if (!has_group_id()) {
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (group_id != NULL) {
    set_has_group_id();
    id_.group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        group_id);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TopicId.group_id)
}

inline bool TopicId::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void TopicId::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline TopicId::IdCase TopicId::id_case() const {
  return TopicId::IdCase(_oneof_case_[0]);
}
inline const TopicId* TopicId::internal_default_instance() {
  return &TopicId_default_instance_.get();
}
// -------------------------------------------------------------------

// UserPresence

// optional bytes user_id = 1;
inline void UserPresence::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserPresence::user_id() const {
  // @@protoc_insertion_point(field_get:server.UserPresence.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserPresence::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.UserPresence.user_id)
}
inline void UserPresence::set_user_id(const char* value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.UserPresence.user_id)
}
inline void UserPresence::set_user_id(const void* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.UserPresence.user_id)
}
inline ::std::string* UserPresence::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:server.UserPresence.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserPresence::release_user_id() {
  // @@protoc_insertion_point(field_release:server.UserPresence.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserPresence::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:server.UserPresence.user_id)
}

// optional bytes session_id = 2;
inline void UserPresence::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserPresence::session_id() const {
  // @@protoc_insertion_point(field_get:server.UserPresence.session_id)
  return session_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserPresence::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.UserPresence.session_id)
}
inline void UserPresence::set_session_id(const char* value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.UserPresence.session_id)
}
inline void UserPresence::set_session_id(const void* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.UserPresence.session_id)
}
inline ::std::string* UserPresence::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:server.UserPresence.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserPresence::release_session_id() {
  // @@protoc_insertion_point(field_release:server.UserPresence.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserPresence::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:server.UserPresence.session_id)
}

// optional string handle = 3;
inline void UserPresence::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserPresence::handle() const {
  // @@protoc_insertion_point(field_get:server.UserPresence.handle)
  return handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserPresence::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.UserPresence.handle)
}
inline void UserPresence::set_handle(const char* value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.UserPresence.handle)
}
inline void UserPresence::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.UserPresence.handle)
}
inline ::std::string* UserPresence::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:server.UserPresence.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserPresence::release_handle() {
  // @@protoc_insertion_point(field_release:server.UserPresence.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserPresence::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:server.UserPresence.handle)
}

inline const UserPresence* UserPresence::internal_default_instance() {
  return &UserPresence_default_instance_.get();
}
// -------------------------------------------------------------------

// TTopicJoin

// optional bytes user_id = 1;
inline bool TTopicJoin::has_user_id() const {
  return id_case() == kUserId;
}
inline void TTopicJoin::set_has_user_id() {
  _oneof_case_[0] = kUserId;
}
inline void TTopicJoin::clear_user_id() {
  if (has_user_id()) {
    id_.user_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TTopicJoin::user_id() const {
  // @@protoc_insertion_point(field_get:server.TTopicJoin.user_id)
  if (has_user_id()) {
    return id_.user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TTopicJoin::set_user_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TTopicJoin.user_id)
  if (!has_user_id()) {
    clear_id();
    set_has_user_id();
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicJoin.user_id)
}
inline void TTopicJoin::set_user_id(const char* value) {
  if (!has_user_id()) {
    clear_id();
    set_has_user_id();
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicJoin.user_id)
}
inline void TTopicJoin::set_user_id(const void* value, size_t size) {
  if (!has_user_id()) {
    clear_id();
    set_has_user_id();
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicJoin.user_id)
}
inline ::std::string* TTopicJoin::mutable_user_id() {
  if (!has_user_id()) {
    clear_id();
    set_has_user_id();
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TTopicJoin.user_id)
  return id_.user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicJoin::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TTopicJoin.user_id)
  if (has_user_id()) {
    clear_has_id();
    return id_.user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TTopicJoin::set_allocated_user_id(::std::string* user_id) {
  if (!has_user_id()) {
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (user_id != NULL) {
    set_has_user_id();
    id_.user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        user_id);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopicJoin.user_id)
}

// optional bytes room = 2;
inline bool TTopicJoin::has_room() const {
  return id_case() == kRoom;
}
inline void TTopicJoin::set_has_room() {
  _oneof_case_[0] = kRoom;
}
inline void TTopicJoin::clear_room() {
  if (has_room()) {
    id_.room_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TTopicJoin::room() const {
  // @@protoc_insertion_point(field_get:server.TTopicJoin.room)
  if (has_room()) {
    return id_.room_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TTopicJoin::set_room(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TTopicJoin.room)
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicJoin.room)
}
inline void TTopicJoin::set_room(const char* value) {
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicJoin.room)
}
inline void TTopicJoin::set_room(const void* value, size_t size) {
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicJoin.room)
}
inline ::std::string* TTopicJoin::mutable_room() {
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TTopicJoin.room)
  return id_.room_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicJoin::release_room() {
  // @@protoc_insertion_point(field_release:server.TTopicJoin.room)
  if (has_room()) {
    clear_has_id();
    return id_.room_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TTopicJoin::set_allocated_room(::std::string* room) {
  if (!has_room()) {
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (room != NULL) {
    set_has_room();
    id_.room_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        room);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopicJoin.room)
}

// optional bytes group_id = 3;
inline bool TTopicJoin::has_group_id() const {
  return id_case() == kGroupId;
}
inline void TTopicJoin::set_has_group_id() {
  _oneof_case_[0] = kGroupId;
}
inline void TTopicJoin::clear_group_id() {
  if (has_group_id()) {
    id_.group_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TTopicJoin::group_id() const {
  // @@protoc_insertion_point(field_get:server.TTopicJoin.group_id)
  if (has_group_id()) {
    return id_.group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TTopicJoin::set_group_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TTopicJoin.group_id)
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicJoin.group_id)
}
inline void TTopicJoin::set_group_id(const char* value) {
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicJoin.group_id)
}
inline void TTopicJoin::set_group_id(const void* value, size_t size) {
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicJoin.group_id)
}
inline ::std::string* TTopicJoin::mutable_group_id() {
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TTopicJoin.group_id)
  return id_.group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicJoin::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TTopicJoin.group_id)
  if (has_group_id()) {
    clear_has_id();
    return id_.group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TTopicJoin::set_allocated_group_id(::std::string* group_id) {
  if (!has_group_id()) {
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (group_id != NULL) {
    set_has_group_id();
    id_.group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        group_id);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopicJoin.group_id)
}

inline bool TTopicJoin::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void TTopicJoin::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline TTopicJoin::IdCase TTopicJoin::id_case() const {
  return TTopicJoin::IdCase(_oneof_case_[0]);
}
inline const TTopicJoin* TTopicJoin::internal_default_instance() {
  return &TTopicJoin_default_instance_.get();
}
// -------------------------------------------------------------------

// TTopic

// optional .server.TopicId topic = 1;
inline bool TTopic::has_topic() const {
  return this != internal_default_instance() && topic_ != NULL;
}
inline void TTopic::clear_topic() {
  if (GetArenaNoVirtual() == NULL && topic_ != NULL) delete topic_;
  topic_ = NULL;
}
inline const ::server::TopicId& TTopic::topic() const {
  // @@protoc_insertion_point(field_get:server.TTopic.topic)
  return topic_ != NULL ? *topic_
                         : *::server::TopicId::internal_default_instance();
}
inline ::server::TopicId* TTopic::mutable_topic() {
  
  if (topic_ == NULL) {
    topic_ = new ::server::TopicId;
  }
  // @@protoc_insertion_point(field_mutable:server.TTopic.topic)
  return topic_;
}
inline ::server::TopicId* TTopic::release_topic() {
  // @@protoc_insertion_point(field_release:server.TTopic.topic)
  
  ::server::TopicId* temp = topic_;
  topic_ = NULL;
  return temp;
}
inline void TTopic::set_allocated_topic(::server::TopicId* topic) {
  delete topic_;
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopic.topic)
}

// repeated .server.UserPresence presences = 2;
inline int TTopic::presences_size() const {
  return presences_.size();
}
inline void TTopic::clear_presences() {
  presences_.Clear();
}
inline const ::server::UserPresence& TTopic::presences(int index) const {
  // @@protoc_insertion_point(field_get:server.TTopic.presences)
  return presences_.Get(index);
}
inline ::server::UserPresence* TTopic::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:server.TTopic.presences)
  return presences_.Mutable(index);
}
inline ::server::UserPresence* TTopic::add_presences() {
  // @@protoc_insertion_point(field_add:server.TTopic.presences)
  return presences_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
TTopic::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:server.TTopic.presences)
  return &presences_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
TTopic::presences() const {
  // @@protoc_insertion_point(field_list:server.TTopic.presences)
  return presences_;
}

// optional .server.UserPresence self = 3;
inline bool TTopic::has_self() const {
  return this != internal_default_instance() && self_ != NULL;
}
inline void TTopic::clear_self() {
  if (GetArenaNoVirtual() == NULL && self_ != NULL) delete self_;
  self_ = NULL;
}
inline const ::server::UserPresence& TTopic::self() const {
  // @@protoc_insertion_point(field_get:server.TTopic.self)
  return self_ != NULL ? *self_
                         : *::server::UserPresence::internal_default_instance();
}
inline ::server::UserPresence* TTopic::mutable_self() {
  
  if (self_ == NULL) {
    self_ = new ::server::UserPresence;
  }
  // @@protoc_insertion_point(field_mutable:server.TTopic.self)
  return self_;
}
inline ::server::UserPresence* TTopic::release_self() {
  // @@protoc_insertion_point(field_release:server.TTopic.self)
  
  ::server::UserPresence* temp = self_;
  self_ = NULL;
  return temp;
}
inline void TTopic::set_allocated_self(::server::UserPresence* self) {
  delete self_;
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopic.self)
}

inline const TTopic* TTopic::internal_default_instance() {
  return &TTopic_default_instance_.get();
}
// -------------------------------------------------------------------

// TTopicLeave

// optional .server.TopicId topic = 1;
inline bool TTopicLeave::has_topic() const {
  return this != internal_default_instance() && topic_ != NULL;
}
inline void TTopicLeave::clear_topic() {
  if (GetArenaNoVirtual() == NULL && topic_ != NULL) delete topic_;
  topic_ = NULL;
}
inline const ::server::TopicId& TTopicLeave::topic() const {
  // @@protoc_insertion_point(field_get:server.TTopicLeave.topic)
  return topic_ != NULL ? *topic_
                         : *::server::TopicId::internal_default_instance();
}
inline ::server::TopicId* TTopicLeave::mutable_topic() {
  
  if (topic_ == NULL) {
    topic_ = new ::server::TopicId;
  }
  // @@protoc_insertion_point(field_mutable:server.TTopicLeave.topic)
  return topic_;
}
inline ::server::TopicId* TTopicLeave::release_topic() {
  // @@protoc_insertion_point(field_release:server.TTopicLeave.topic)
  
  ::server::TopicId* temp = topic_;
  topic_ = NULL;
  return temp;
}
inline void TTopicLeave::set_allocated_topic(::server::TopicId* topic) {
  delete topic_;
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopicLeave.topic)
}

inline const TTopicLeave* TTopicLeave::internal_default_instance() {
  return &TTopicLeave_default_instance_.get();
}
// -------------------------------------------------------------------

// TTopicMessageSend

// optional .server.TopicId topic = 1;
inline bool TTopicMessageSend::has_topic() const {
  return this != internal_default_instance() && topic_ != NULL;
}
inline void TTopicMessageSend::clear_topic() {
  if (GetArenaNoVirtual() == NULL && topic_ != NULL) delete topic_;
  topic_ = NULL;
}
inline const ::server::TopicId& TTopicMessageSend::topic() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessageSend.topic)
  return topic_ != NULL ? *topic_
                         : *::server::TopicId::internal_default_instance();
}
inline ::server::TopicId* TTopicMessageSend::mutable_topic() {
  
  if (topic_ == NULL) {
    topic_ = new ::server::TopicId;
  }
  // @@protoc_insertion_point(field_mutable:server.TTopicMessageSend.topic)
  return topic_;
}
inline ::server::TopicId* TTopicMessageSend::release_topic() {
  // @@protoc_insertion_point(field_release:server.TTopicMessageSend.topic)
  
  ::server::TopicId* temp = topic_;
  topic_ = NULL;
  return temp;
}
inline void TTopicMessageSend::set_allocated_topic(::server::TopicId* topic) {
  delete topic_;
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopicMessageSend.topic)
}

// optional bytes data = 2;
inline void TTopicMessageSend::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TTopicMessageSend::data() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessageSend.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessageSend::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicMessageSend.data)
}
inline void TTopicMessageSend::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicMessageSend.data)
}
inline void TTopicMessageSend::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicMessageSend.data)
}
inline ::std::string* TTopicMessageSend::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:server.TTopicMessageSend.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicMessageSend::release_data() {
  // @@protoc_insertion_point(field_release:server.TTopicMessageSend.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessageSend::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:server.TTopicMessageSend.data)
}

inline const TTopicMessageSend* TTopicMessageSend::internal_default_instance() {
  return &TTopicMessageSend_default_instance_.get();
}
// -------------------------------------------------------------------

// TTopicMessageAck

// optional bytes message_id = 1;
inline void TTopicMessageAck::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TTopicMessageAck::message_id() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessageAck.message_id)
  return message_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessageAck::set_message_id(const ::std::string& value) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicMessageAck.message_id)
}
inline void TTopicMessageAck::set_message_id(const char* value) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicMessageAck.message_id)
}
inline void TTopicMessageAck::set_message_id(const void* value, size_t size) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicMessageAck.message_id)
}
inline ::std::string* TTopicMessageAck::mutable_message_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TTopicMessageAck.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicMessageAck::release_message_id() {
  // @@protoc_insertion_point(field_release:server.TTopicMessageAck.message_id)
  
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessageAck::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    
  } else {
    
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:server.TTopicMessageAck.message_id)
}

// optional int64 created_at = 2;
inline void TTopicMessageAck::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TTopicMessageAck::created_at() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessageAck.created_at)
  return created_at_;
}
inline void TTopicMessageAck::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:server.TTopicMessageAck.created_at)
}

// optional int64 expires_at = 3;
inline void TTopicMessageAck::clear_expires_at() {
  expires_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TTopicMessageAck::expires_at() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessageAck.expires_at)
  return expires_at_;
}
inline void TTopicMessageAck::set_expires_at(::google::protobuf::int64 value) {
  
  expires_at_ = value;
  // @@protoc_insertion_point(field_set:server.TTopicMessageAck.expires_at)
}

// optional string handle = 4;
inline void TTopicMessageAck::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TTopicMessageAck::handle() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessageAck.handle)
  return handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessageAck::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicMessageAck.handle)
}
inline void TTopicMessageAck::set_handle(const char* value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicMessageAck.handle)
}
inline void TTopicMessageAck::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicMessageAck.handle)
}
inline ::std::string* TTopicMessageAck::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:server.TTopicMessageAck.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicMessageAck::release_handle() {
  // @@protoc_insertion_point(field_release:server.TTopicMessageAck.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessageAck::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:server.TTopicMessageAck.handle)
}

inline const TTopicMessageAck* TTopicMessageAck::internal_default_instance() {
  return &TTopicMessageAck_default_instance_.get();
}
// -------------------------------------------------------------------

// TopicMessage

// optional .server.TopicId topic = 1;
inline bool TopicMessage::has_topic() const {
  return this != internal_default_instance() && topic_ != NULL;
}
inline void TopicMessage::clear_topic() {
  if (GetArenaNoVirtual() == NULL && topic_ != NULL) delete topic_;
  topic_ = NULL;
}
inline const ::server::TopicId& TopicMessage::topic() const {
  // @@protoc_insertion_point(field_get:server.TopicMessage.topic)
  return topic_ != NULL ? *topic_
                         : *::server::TopicId::internal_default_instance();
}
inline ::server::TopicId* TopicMessage::mutable_topic() {
  
  if (topic_ == NULL) {
    topic_ = new ::server::TopicId;
  }
  // @@protoc_insertion_point(field_mutable:server.TopicMessage.topic)
  return topic_;
}
inline ::server::TopicId* TopicMessage::release_topic() {
  // @@protoc_insertion_point(field_release:server.TopicMessage.topic)
  
  ::server::TopicId* temp = topic_;
  topic_ = NULL;
  return temp;
}
inline void TopicMessage::set_allocated_topic(::server::TopicId* topic) {
  delete topic_;
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TopicMessage.topic)
}

// optional bytes user_id = 2;
inline void TopicMessage::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TopicMessage::user_id() const {
  // @@protoc_insertion_point(field_get:server.TopicMessage.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicMessage::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TopicMessage.user_id)
}
inline void TopicMessage::set_user_id(const char* value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TopicMessage.user_id)
}
inline void TopicMessage::set_user_id(const void* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TopicMessage.user_id)
}
inline ::std::string* TopicMessage::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TopicMessage.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicMessage::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TopicMessage.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicMessage::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:server.TopicMessage.user_id)
}

// optional bytes message_id = 3;
inline void TopicMessage::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TopicMessage::message_id() const {
  // @@protoc_insertion_point(field_get:server.TopicMessage.message_id)
  return message_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicMessage::set_message_id(const ::std::string& value) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TopicMessage.message_id)
}
inline void TopicMessage::set_message_id(const char* value) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TopicMessage.message_id)
}
inline void TopicMessage::set_message_id(const void* value, size_t size) {
  
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TopicMessage.message_id)
}
inline ::std::string* TopicMessage::mutable_message_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TopicMessage.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicMessage::release_message_id() {
  // @@protoc_insertion_point(field_release:server.TopicMessage.message_id)
  
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicMessage::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    
  } else {
    
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:server.TopicMessage.message_id)
}

// optional int64 created_at = 4;
inline void TopicMessage::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TopicMessage::created_at() const {
  // @@protoc_insertion_point(field_get:server.TopicMessage.created_at)
  return created_at_;
}
inline void TopicMessage::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:server.TopicMessage.created_at)
}

// optional int64 expires_at = 5;
inline void TopicMessage::clear_expires_at() {
  expires_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TopicMessage::expires_at() const {
  // @@protoc_insertion_point(field_get:server.TopicMessage.expires_at)
  return expires_at_;
}
inline void TopicMessage::set_expires_at(::google::protobuf::int64 value) {
  
  expires_at_ = value;
  // @@protoc_insertion_point(field_set:server.TopicMessage.expires_at)
}

// optional string handle = 6;
inline void TopicMessage::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TopicMessage::handle() const {
  // @@protoc_insertion_point(field_get:server.TopicMessage.handle)
  return handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicMessage::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TopicMessage.handle)
}
inline void TopicMessage::set_handle(const char* value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TopicMessage.handle)
}
inline void TopicMessage::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TopicMessage.handle)
}
inline ::std::string* TopicMessage::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:server.TopicMessage.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicMessage::release_handle() {
  // @@protoc_insertion_point(field_release:server.TopicMessage.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicMessage::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:server.TopicMessage.handle)
}

// optional int64 type = 7;
inline void TopicMessage::clear_type() {
  type_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TopicMessage::type() const {
  // @@protoc_insertion_point(field_get:server.TopicMessage.type)
  return type_;
}
inline void TopicMessage::set_type(::google::protobuf::int64 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:server.TopicMessage.type)
}

// optional bytes data = 8;
inline void TopicMessage::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TopicMessage::data() const {
  // @@protoc_insertion_point(field_get:server.TopicMessage.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicMessage::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TopicMessage.data)
}
inline void TopicMessage::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TopicMessage.data)
}
inline void TopicMessage::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TopicMessage.data)
}
inline ::std::string* TopicMessage::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:server.TopicMessage.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicMessage::release_data() {
  // @@protoc_insertion_point(field_release:server.TopicMessage.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicMessage::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:server.TopicMessage.data)
}

inline const TopicMessage* TopicMessage::internal_default_instance() {
  return &TopicMessage_default_instance_.get();
}
// -------------------------------------------------------------------

// TTopicMessagesList

// optional bytes user_id = 1;
inline bool TTopicMessagesList::has_user_id() const {
  return id_case() == kUserId;
}
inline void TTopicMessagesList::set_has_user_id() {
  _oneof_case_[0] = kUserId;
}
inline void TTopicMessagesList::clear_user_id() {
  if (has_user_id()) {
    id_.user_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TTopicMessagesList::user_id() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessagesList.user_id)
  if (has_user_id()) {
    return id_.user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TTopicMessagesList::set_user_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TTopicMessagesList.user_id)
  if (!has_user_id()) {
    clear_id();
    set_has_user_id();
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicMessagesList.user_id)
}
inline void TTopicMessagesList::set_user_id(const char* value) {
  if (!has_user_id()) {
    clear_id();
    set_has_user_id();
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicMessagesList.user_id)
}
inline void TTopicMessagesList::set_user_id(const void* value, size_t size) {
  if (!has_user_id()) {
    clear_id();
    set_has_user_id();
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicMessagesList.user_id)
}
inline ::std::string* TTopicMessagesList::mutable_user_id() {
  if (!has_user_id()) {
    clear_id();
    set_has_user_id();
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TTopicMessagesList.user_id)
  return id_.user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicMessagesList::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TTopicMessagesList.user_id)
  if (has_user_id()) {
    clear_has_id();
    return id_.user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TTopicMessagesList::set_allocated_user_id(::std::string* user_id) {
  if (!has_user_id()) {
    id_.user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (user_id != NULL) {
    set_has_user_id();
    id_.user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        user_id);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopicMessagesList.user_id)
}

// optional bytes room = 2;
inline bool TTopicMessagesList::has_room() const {
  return id_case() == kRoom;
}
inline void TTopicMessagesList::set_has_room() {
  _oneof_case_[0] = kRoom;
}
inline void TTopicMessagesList::clear_room() {
  if (has_room()) {
    id_.room_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TTopicMessagesList::room() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessagesList.room)
  if (has_room()) {
    return id_.room_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TTopicMessagesList::set_room(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TTopicMessagesList.room)
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicMessagesList.room)
}
inline void TTopicMessagesList::set_room(const char* value) {
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicMessagesList.room)
}
inline void TTopicMessagesList::set_room(const void* value, size_t size) {
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicMessagesList.room)
}
inline ::std::string* TTopicMessagesList::mutable_room() {
  if (!has_room()) {
    clear_id();
    set_has_room();
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TTopicMessagesList.room)
  return id_.room_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicMessagesList::release_room() {
  // @@protoc_insertion_point(field_release:server.TTopicMessagesList.room)
  if (has_room()) {
    clear_has_id();
    return id_.room_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TTopicMessagesList::set_allocated_room(::std::string* room) {
  if (!has_room()) {
    id_.room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (room != NULL) {
    set_has_room();
    id_.room_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        room);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopicMessagesList.room)
}

// optional bytes group_id = 3;
inline bool TTopicMessagesList::has_group_id() const {
  return id_case() == kGroupId;
}
inline void TTopicMessagesList::set_has_group_id() {
  _oneof_case_[0] = kGroupId;
}
inline void TTopicMessagesList::clear_group_id() {
  if (has_group_id()) {
    id_.group_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TTopicMessagesList::group_id() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessagesList.group_id)
  if (has_group_id()) {
    return id_.group_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TTopicMessagesList::set_group_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TTopicMessagesList.group_id)
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicMessagesList.group_id)
}
inline void TTopicMessagesList::set_group_id(const char* value) {
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicMessagesList.group_id)
}
inline void TTopicMessagesList::set_group_id(const void* value, size_t size) {
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicMessagesList.group_id)
}
inline ::std::string* TTopicMessagesList::mutable_group_id() {
  if (!has_group_id()) {
    clear_id();
    set_has_group_id();
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TTopicMessagesList.group_id)
  return id_.group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicMessagesList::release_group_id() {
  // @@protoc_insertion_point(field_release:server.TTopicMessagesList.group_id)
  if (has_group_id()) {
    clear_has_id();
    return id_.group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TTopicMessagesList::set_allocated_group_id(::std::string* group_id) {
  if (!has_group_id()) {
    id_.group_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (group_id != NULL) {
    set_has_group_id();
    id_.group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        group_id);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TTopicMessagesList.group_id)
}

// optional bytes cursor = 4;
inline void TTopicMessagesList::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TTopicMessagesList::cursor() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessagesList.cursor)
  return cursor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessagesList::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicMessagesList.cursor)
}
inline void TTopicMessagesList::set_cursor(const char* value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicMessagesList.cursor)
}
inline void TTopicMessagesList::set_cursor(const void* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicMessagesList.cursor)
}
inline ::std::string* TTopicMessagesList::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:server.TTopicMessagesList.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicMessagesList::release_cursor() {
  // @@protoc_insertion_point(field_release:server.TTopicMessagesList.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessagesList::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:server.TTopicMessagesList.cursor)
}

// optional bool forward = 5;
inline void TTopicMessagesList::clear_forward() {
  forward_ = false;
}
inline bool TTopicMessagesList::forward() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessagesList.forward)
  return forward_;
}
inline void TTopicMessagesList::set_forward(bool value) {
  
  forward_ = value;
  // @@protoc_insertion_point(field_set:server.TTopicMessagesList.forward)
}

// optional int64 limit = 6;
inline void TTopicMessagesList::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TTopicMessagesList::limit() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessagesList.limit)
  return limit_;
}
inline void TTopicMessagesList::set_limit(::google::protobuf::int64 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:server.TTopicMessagesList.limit)
}

inline bool TTopicMessagesList::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void TTopicMessagesList::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline TTopicMessagesList::IdCase TTopicMessagesList::id_case() const {
  return TTopicMessagesList::IdCase(_oneof_case_[0]);
}
inline const TTopicMessagesList* TTopicMessagesList::internal_default_instance() {
  return &TTopicMessagesList_default_instance_.get();
}
// -------------------------------------------------------------------

// TTopicMessages

// repeated .server.TopicMessage messages = 1;
inline int TTopicMessages::messages_size() const {
  return messages_.size();
}
inline void TTopicMessages::clear_messages() {
  messages_.Clear();
}
inline const ::server::TopicMessage& TTopicMessages::messages(int index) const {
  // @@protoc_insertion_point(field_get:server.TTopicMessages.messages)
  return messages_.Get(index);
}
inline ::server::TopicMessage* TTopicMessages::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:server.TTopicMessages.messages)
  return messages_.Mutable(index);
}
inline ::server::TopicMessage* TTopicMessages::add_messages() {
  // @@protoc_insertion_point(field_add:server.TTopicMessages.messages)
  return messages_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::TopicMessage >*
TTopicMessages::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:server.TTopicMessages.messages)
  return &messages_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::TopicMessage >&
TTopicMessages::messages() const {
  // @@protoc_insertion_point(field_list:server.TTopicMessages.messages)
  return messages_;
}

// optional bytes cursor = 2;
inline void TTopicMessages::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TTopicMessages::cursor() const {
  // @@protoc_insertion_point(field_get:server.TTopicMessages.cursor)
  return cursor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessages::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TTopicMessages.cursor)
}
inline void TTopicMessages::set_cursor(const char* value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TTopicMessages.cursor)
}
inline void TTopicMessages::set_cursor(const void* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TTopicMessages.cursor)
}
inline ::std::string* TTopicMessages::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:server.TTopicMessages.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TTopicMessages::release_cursor() {
  // @@protoc_insertion_point(field_release:server.TTopicMessages.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TTopicMessages::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:server.TTopicMessages.cursor)
}

inline const TTopicMessages* TTopicMessages::internal_default_instance() {
  return &TTopicMessages_default_instance_.get();
}
// -------------------------------------------------------------------

// TopicPresence

// optional .server.TopicId topic = 1;
inline bool TopicPresence::has_topic() const {
  return this != internal_default_instance() && topic_ != NULL;
}
inline void TopicPresence::clear_topic() {
  if (GetArenaNoVirtual() == NULL && topic_ != NULL) delete topic_;
  topic_ = NULL;
}
inline const ::server::TopicId& TopicPresence::topic() const {
  // @@protoc_insertion_point(field_get:server.TopicPresence.topic)
  return topic_ != NULL ? *topic_
                         : *::server::TopicId::internal_default_instance();
}
inline ::server::TopicId* TopicPresence::mutable_topic() {
  
  if (topic_ == NULL) {
    topic_ = new ::server::TopicId;
  }
  // @@protoc_insertion_point(field_mutable:server.TopicPresence.topic)
  return topic_;
}
inline ::server::TopicId* TopicPresence::release_topic() {
  // @@protoc_insertion_point(field_release:server.TopicPresence.topic)
  
  ::server::TopicId* temp = topic_;
  topic_ = NULL;
  return temp;
}
inline void TopicPresence::set_allocated_topic(::server::TopicId* topic) {
  delete topic_;
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TopicPresence.topic)
}

// repeated .server.UserPresence joins = 2;
inline int TopicPresence::joins_size() const {
  return joins_.size();
}
inline void TopicPresence::clear_joins() {
  joins_.Clear();
}
inline const ::server::UserPresence& TopicPresence::joins(int index) const {
  // @@protoc_insertion_point(field_get:server.TopicPresence.joins)
  return joins_.Get(index);
}
inline ::server::UserPresence* TopicPresence::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:server.TopicPresence.joins)
  return joins_.Mutable(index);
}
inline ::server::UserPresence* TopicPresence::add_joins() {
  // @@protoc_insertion_point(field_add:server.TopicPresence.joins)
  return joins_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
TopicPresence::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:server.TopicPresence.joins)
  return &joins_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
TopicPresence::joins() const {
  // @@protoc_insertion_point(field_list:server.TopicPresence.joins)
  return joins_;
}

// repeated .server.UserPresence leaves = 3;
inline int TopicPresence::leaves_size() const {
  return leaves_.size();
}
inline void TopicPresence::clear_leaves() {
  leaves_.Clear();
}
inline const ::server::UserPresence& TopicPresence::leaves(int index) const {
  // @@protoc_insertion_point(field_get:server.TopicPresence.leaves)
  return leaves_.Get(index);
}
inline ::server::UserPresence* TopicPresence::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:server.TopicPresence.leaves)
  return leaves_.Mutable(index);
}
inline ::server::UserPresence* TopicPresence::add_leaves() {
  // @@protoc_insertion_point(field_add:server.TopicPresence.leaves)
  return leaves_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
TopicPresence::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:server.TopicPresence.leaves)
  return &leaves_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
TopicPresence::leaves() const {
  // @@protoc_insertion_point(field_list:server.TopicPresence.leaves)
  return leaves_;
}

inline const TopicPresence* TopicPresence::internal_default_instance() {
  return &TopicPresence_default_instance_.get();
}
// -------------------------------------------------------------------

// TMatchmakeAdd

// optional int64 requiredCount = 1;
inline void TMatchmakeAdd::clear_requiredcount() {
  requiredcount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TMatchmakeAdd::requiredcount() const {
  // @@protoc_insertion_point(field_get:server.TMatchmakeAdd.requiredCount)
  return requiredcount_;
}
inline void TMatchmakeAdd::set_requiredcount(::google::protobuf::int64 value) {
  
  requiredcount_ = value;
  // @@protoc_insertion_point(field_set:server.TMatchmakeAdd.requiredCount)
}

inline const TMatchmakeAdd* TMatchmakeAdd::internal_default_instance() {
  return &TMatchmakeAdd_default_instance_.get();
}
// -------------------------------------------------------------------

// TMatchmakeTicket

// optional bytes ticket = 1;
inline void TMatchmakeTicket::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TMatchmakeTicket::ticket() const {
  // @@protoc_insertion_point(field_get:server.TMatchmakeTicket.ticket)
  return ticket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TMatchmakeTicket::set_ticket(const ::std::string& value) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TMatchmakeTicket.ticket)
}
inline void TMatchmakeTicket::set_ticket(const char* value) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TMatchmakeTicket.ticket)
}
inline void TMatchmakeTicket::set_ticket(const void* value, size_t size) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TMatchmakeTicket.ticket)
}
inline ::std::string* TMatchmakeTicket::mutable_ticket() {
  
  // @@protoc_insertion_point(field_mutable:server.TMatchmakeTicket.ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TMatchmakeTicket::release_ticket() {
  // @@protoc_insertion_point(field_release:server.TMatchmakeTicket.ticket)
  
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TMatchmakeTicket::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    
  } else {
    
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:server.TMatchmakeTicket.ticket)
}

inline const TMatchmakeTicket* TMatchmakeTicket::internal_default_instance() {
  return &TMatchmakeTicket_default_instance_.get();
}
// -------------------------------------------------------------------

// TMatchmakeRemove

// optional bytes ticket = 1;
inline void TMatchmakeRemove::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TMatchmakeRemove::ticket() const {
  // @@protoc_insertion_point(field_get:server.TMatchmakeRemove.ticket)
  return ticket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TMatchmakeRemove::set_ticket(const ::std::string& value) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TMatchmakeRemove.ticket)
}
inline void TMatchmakeRemove::set_ticket(const char* value) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TMatchmakeRemove.ticket)
}
inline void TMatchmakeRemove::set_ticket(const void* value, size_t size) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TMatchmakeRemove.ticket)
}
inline ::std::string* TMatchmakeRemove::mutable_ticket() {
  
  // @@protoc_insertion_point(field_mutable:server.TMatchmakeRemove.ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TMatchmakeRemove::release_ticket() {
  // @@protoc_insertion_point(field_release:server.TMatchmakeRemove.ticket)
  
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TMatchmakeRemove::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    
  } else {
    
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:server.TMatchmakeRemove.ticket)
}

inline const TMatchmakeRemove* TMatchmakeRemove::internal_default_instance() {
  return &TMatchmakeRemove_default_instance_.get();
}
// -------------------------------------------------------------------

// MatchmakeMatched

// optional bytes ticket = 1;
inline void MatchmakeMatched::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchmakeMatched::ticket() const {
  // @@protoc_insertion_point(field_get:server.MatchmakeMatched.ticket)
  return ticket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchmakeMatched::set_ticket(const ::std::string& value) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.MatchmakeMatched.ticket)
}
inline void MatchmakeMatched::set_ticket(const char* value) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.MatchmakeMatched.ticket)
}
inline void MatchmakeMatched::set_ticket(const void* value, size_t size) {
  
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.MatchmakeMatched.ticket)
}
inline ::std::string* MatchmakeMatched::mutable_ticket() {
  
  // @@protoc_insertion_point(field_mutable:server.MatchmakeMatched.ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchmakeMatched::release_ticket() {
  // @@protoc_insertion_point(field_release:server.MatchmakeMatched.ticket)
  
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchmakeMatched::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    
  } else {
    
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:server.MatchmakeMatched.ticket)
}

// optional bytes token = 2;
inline void MatchmakeMatched::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchmakeMatched::token() const {
  // @@protoc_insertion_point(field_get:server.MatchmakeMatched.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchmakeMatched::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.MatchmakeMatched.token)
}
inline void MatchmakeMatched::set_token(const char* value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.MatchmakeMatched.token)
}
inline void MatchmakeMatched::set_token(const void* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.MatchmakeMatched.token)
}
inline ::std::string* MatchmakeMatched::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:server.MatchmakeMatched.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchmakeMatched::release_token() {
  // @@protoc_insertion_point(field_release:server.MatchmakeMatched.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchmakeMatched::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:server.MatchmakeMatched.token)
}

// repeated .server.UserPresence presences = 3;
inline int MatchmakeMatched::presences_size() const {
  return presences_.size();
}
inline void MatchmakeMatched::clear_presences() {
  presences_.Clear();
}
inline const ::server::UserPresence& MatchmakeMatched::presences(int index) const {
  // @@protoc_insertion_point(field_get:server.MatchmakeMatched.presences)
  return presences_.Get(index);
}
inline ::server::UserPresence* MatchmakeMatched::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:server.MatchmakeMatched.presences)
  return presences_.Mutable(index);
}
inline ::server::UserPresence* MatchmakeMatched::add_presences() {
  // @@protoc_insertion_point(field_add:server.MatchmakeMatched.presences)
  return presences_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
MatchmakeMatched::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:server.MatchmakeMatched.presences)
  return &presences_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
MatchmakeMatched::presences() const {
  // @@protoc_insertion_point(field_list:server.MatchmakeMatched.presences)
  return presences_;
}

// optional .server.UserPresence self = 4;
inline bool MatchmakeMatched::has_self() const {
  return this != internal_default_instance() && self_ != NULL;
}
inline void MatchmakeMatched::clear_self() {
  if (GetArenaNoVirtual() == NULL && self_ != NULL) delete self_;
  self_ = NULL;
}
inline const ::server::UserPresence& MatchmakeMatched::self() const {
  // @@protoc_insertion_point(field_get:server.MatchmakeMatched.self)
  return self_ != NULL ? *self_
                         : *::server::UserPresence::internal_default_instance();
}
inline ::server::UserPresence* MatchmakeMatched::mutable_self() {
  
  if (self_ == NULL) {
    self_ = new ::server::UserPresence;
  }
  // @@protoc_insertion_point(field_mutable:server.MatchmakeMatched.self)
  return self_;
}
inline ::server::UserPresence* MatchmakeMatched::release_self() {
  // @@protoc_insertion_point(field_release:server.MatchmakeMatched.self)
  
  ::server::UserPresence* temp = self_;
  self_ = NULL;
  return temp;
}
inline void MatchmakeMatched::set_allocated_self(::server::UserPresence* self) {
  delete self_;
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.MatchmakeMatched.self)
}

inline const MatchmakeMatched* MatchmakeMatched::internal_default_instance() {
  return &MatchmakeMatched_default_instance_.get();
}
// -------------------------------------------------------------------

// TMatchCreate

inline const TMatchCreate* TMatchCreate::internal_default_instance() {
  return &TMatchCreate_default_instance_.get();
}
// -------------------------------------------------------------------

// TMatchJoin

// optional bytes match_id = 1;
inline bool TMatchJoin::has_match_id() const {
  return id_case() == kMatchId;
}
inline void TMatchJoin::set_has_match_id() {
  _oneof_case_[0] = kMatchId;
}
inline void TMatchJoin::clear_match_id() {
  if (has_match_id()) {
    id_.match_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TMatchJoin::match_id() const {
  // @@protoc_insertion_point(field_get:server.TMatchJoin.match_id)
  if (has_match_id()) {
    return id_.match_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TMatchJoin::set_match_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TMatchJoin.match_id)
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TMatchJoin.match_id)
}
inline void TMatchJoin::set_match_id(const char* value) {
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TMatchJoin.match_id)
}
inline void TMatchJoin::set_match_id(const void* value, size_t size) {
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TMatchJoin.match_id)
}
inline ::std::string* TMatchJoin::mutable_match_id() {
  if (!has_match_id()) {
    clear_id();
    set_has_match_id();
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TMatchJoin.match_id)
  return id_.match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TMatchJoin::release_match_id() {
  // @@protoc_insertion_point(field_release:server.TMatchJoin.match_id)
  if (has_match_id()) {
    clear_has_id();
    return id_.match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TMatchJoin::set_allocated_match_id(::std::string* match_id) {
  if (!has_match_id()) {
    id_.match_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (match_id != NULL) {
    set_has_match_id();
    id_.match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        match_id);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TMatchJoin.match_id)
}

// optional bytes token = 2;
inline bool TMatchJoin::has_token() const {
  return id_case() == kToken;
}
inline void TMatchJoin::set_has_token() {
  _oneof_case_[0] = kToken;
}
inline void TMatchJoin::clear_token() {
  if (has_token()) {
    id_.token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_id();
  }
}
inline const ::std::string& TMatchJoin::token() const {
  // @@protoc_insertion_point(field_get:server.TMatchJoin.token)
  if (has_token()) {
    return id_.token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TMatchJoin::set_token(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TMatchJoin.token)
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TMatchJoin.token)
}
inline void TMatchJoin::set_token(const char* value) {
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TMatchJoin.token)
}
inline void TMatchJoin::set_token(const void* value, size_t size) {
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  id_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TMatchJoin.token)
}
inline ::std::string* TMatchJoin::mutable_token() {
  if (!has_token()) {
    clear_id();
    set_has_token();
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TMatchJoin.token)
  return id_.token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TMatchJoin::release_token() {
  // @@protoc_insertion_point(field_release:server.TMatchJoin.token)
  if (has_token()) {
    clear_has_id();
    return id_.token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TMatchJoin::set_allocated_token(::std::string* token) {
  if (!has_token()) {
    id_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_id();
  if (token != NULL) {
    set_has_token();
    id_.token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        token);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TMatchJoin.token)
}

inline bool TMatchJoin::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void TMatchJoin::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline TMatchJoin::IdCase TMatchJoin::id_case() const {
  return TMatchJoin::IdCase(_oneof_case_[0]);
}
inline const TMatchJoin* TMatchJoin::internal_default_instance() {
  return &TMatchJoin_default_instance_.get();
}
// -------------------------------------------------------------------

// TMatch

// optional bytes match_id = 1;
inline void TMatch::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TMatch::match_id() const {
  // @@protoc_insertion_point(field_get:server.TMatch.match_id)
  return match_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TMatch::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TMatch.match_id)
}
inline void TMatch::set_match_id(const char* value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TMatch.match_id)
}
inline void TMatch::set_match_id(const void* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TMatch.match_id)
}
inline ::std::string* TMatch::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TMatch.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TMatch::release_match_id() {
  // @@protoc_insertion_point(field_release:server.TMatch.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TMatch::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:server.TMatch.match_id)
}

// repeated .server.UserPresence presences = 2;
inline int TMatch::presences_size() const {
  return presences_.size();
}
inline void TMatch::clear_presences() {
  presences_.Clear();
}
inline const ::server::UserPresence& TMatch::presences(int index) const {
  // @@protoc_insertion_point(field_get:server.TMatch.presences)
  return presences_.Get(index);
}
inline ::server::UserPresence* TMatch::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:server.TMatch.presences)
  return presences_.Mutable(index);
}
inline ::server::UserPresence* TMatch::add_presences() {
  // @@protoc_insertion_point(field_add:server.TMatch.presences)
  return presences_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
TMatch::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:server.TMatch.presences)
  return &presences_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
TMatch::presences() const {
  // @@protoc_insertion_point(field_list:server.TMatch.presences)
  return presences_;
}

// optional .server.UserPresence self = 3;
inline bool TMatch::has_self() const {
  return this != internal_default_instance() && self_ != NULL;
}
inline void TMatch::clear_self() {
  if (GetArenaNoVirtual() == NULL && self_ != NULL) delete self_;
  self_ = NULL;
}
inline const ::server::UserPresence& TMatch::self() const {
  // @@protoc_insertion_point(field_get:server.TMatch.self)
  return self_ != NULL ? *self_
                         : *::server::UserPresence::internal_default_instance();
}
inline ::server::UserPresence* TMatch::mutable_self() {
  
  if (self_ == NULL) {
    self_ = new ::server::UserPresence;
  }
  // @@protoc_insertion_point(field_mutable:server.TMatch.self)
  return self_;
}
inline ::server::UserPresence* TMatch::release_self() {
  // @@protoc_insertion_point(field_release:server.TMatch.self)
  
  ::server::UserPresence* temp = self_;
  self_ = NULL;
  return temp;
}
inline void TMatch::set_allocated_self(::server::UserPresence* self) {
  delete self_;
  self_ = self;
  if (self) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TMatch.self)
}

inline const TMatch* TMatch::internal_default_instance() {
  return &TMatch_default_instance_.get();
}
// -------------------------------------------------------------------

// MatchDataSend

// optional bytes match_id = 1;
inline void MatchDataSend::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchDataSend::match_id() const {
  // @@protoc_insertion_point(field_get:server.MatchDataSend.match_id)
  return match_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchDataSend::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.MatchDataSend.match_id)
}
inline void MatchDataSend::set_match_id(const char* value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.MatchDataSend.match_id)
}
inline void MatchDataSend::set_match_id(const void* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.MatchDataSend.match_id)
}
inline ::std::string* MatchDataSend::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:server.MatchDataSend.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchDataSend::release_match_id() {
  // @@protoc_insertion_point(field_release:server.MatchDataSend.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchDataSend::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:server.MatchDataSend.match_id)
}

// optional int64 op_code = 2;
inline void MatchDataSend::clear_op_code() {
  op_code_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MatchDataSend::op_code() const {
  // @@protoc_insertion_point(field_get:server.MatchDataSend.op_code)
  return op_code_;
}
inline void MatchDataSend::set_op_code(::google::protobuf::int64 value) {
  
  op_code_ = value;
  // @@protoc_insertion_point(field_set:server.MatchDataSend.op_code)
}

// optional bytes data = 3;
inline void MatchDataSend::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchDataSend::data() const {
  // @@protoc_insertion_point(field_get:server.MatchDataSend.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchDataSend::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.MatchDataSend.data)
}
inline void MatchDataSend::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.MatchDataSend.data)
}
inline void MatchDataSend::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.MatchDataSend.data)
}
inline ::std::string* MatchDataSend::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:server.MatchDataSend.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchDataSend::release_data() {
  // @@protoc_insertion_point(field_release:server.MatchDataSend.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchDataSend::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:server.MatchDataSend.data)
}

// repeated .server.UserPresence presences = 4;
inline int MatchDataSend::presences_size() const {
  return presences_.size();
}
inline void MatchDataSend::clear_presences() {
  presences_.Clear();
}
inline const ::server::UserPresence& MatchDataSend::presences(int index) const {
  // @@protoc_insertion_point(field_get:server.MatchDataSend.presences)
  return presences_.Get(index);
}
inline ::server::UserPresence* MatchDataSend::mutable_presences(int index) {
  // @@protoc_insertion_point(field_mutable:server.MatchDataSend.presences)
  return presences_.Mutable(index);
}
inline ::server::UserPresence* MatchDataSend::add_presences() {
  // @@protoc_insertion_point(field_add:server.MatchDataSend.presences)
  return presences_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
MatchDataSend::mutable_presences() {
  // @@protoc_insertion_point(field_mutable_list:server.MatchDataSend.presences)
  return &presences_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
MatchDataSend::presences() const {
  // @@protoc_insertion_point(field_list:server.MatchDataSend.presences)
  return presences_;
}

inline const MatchDataSend* MatchDataSend::internal_default_instance() {
  return &MatchDataSend_default_instance_.get();
}
// -------------------------------------------------------------------

// MatchData

// optional bytes match_id = 1;
inline void MatchData::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchData::match_id() const {
  // @@protoc_insertion_point(field_get:server.MatchData.match_id)
  return match_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchData::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.MatchData.match_id)
}
inline void MatchData::set_match_id(const char* value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.MatchData.match_id)
}
inline void MatchData::set_match_id(const void* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.MatchData.match_id)
}
inline ::std::string* MatchData::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:server.MatchData.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchData::release_match_id() {
  // @@protoc_insertion_point(field_release:server.MatchData.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchData::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:server.MatchData.match_id)
}

// optional .server.UserPresence presence = 2;
inline bool MatchData::has_presence() const {
  return this != internal_default_instance() && presence_ != NULL;
}
inline void MatchData::clear_presence() {
  if (GetArenaNoVirtual() == NULL && presence_ != NULL) delete presence_;
  presence_ = NULL;
}
inline const ::server::UserPresence& MatchData::presence() const {
  // @@protoc_insertion_point(field_get:server.MatchData.presence)
  return presence_ != NULL ? *presence_
                         : *::server::UserPresence::internal_default_instance();
}
inline ::server::UserPresence* MatchData::mutable_presence() {
  
  if (presence_ == NULL) {
    presence_ = new ::server::UserPresence;
  }
  // @@protoc_insertion_point(field_mutable:server.MatchData.presence)
  return presence_;
}
inline ::server::UserPresence* MatchData::release_presence() {
  // @@protoc_insertion_point(field_release:server.MatchData.presence)
  
  ::server::UserPresence* temp = presence_;
  presence_ = NULL;
  return temp;
}
inline void MatchData::set_allocated_presence(::server::UserPresence* presence) {
  delete presence_;
  presence_ = presence;
  if (presence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.MatchData.presence)
}

// optional int64 op_code = 3;
inline void MatchData::clear_op_code() {
  op_code_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MatchData::op_code() const {
  // @@protoc_insertion_point(field_get:server.MatchData.op_code)
  return op_code_;
}
inline void MatchData::set_op_code(::google::protobuf::int64 value) {
  
  op_code_ = value;
  // @@protoc_insertion_point(field_set:server.MatchData.op_code)
}

// optional bytes data = 4;
inline void MatchData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchData::data() const {
  // @@protoc_insertion_point(field_get:server.MatchData.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.MatchData.data)
}
inline void MatchData::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.MatchData.data)
}
inline void MatchData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.MatchData.data)
}
inline ::std::string* MatchData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:server.MatchData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchData::release_data() {
  // @@protoc_insertion_point(field_release:server.MatchData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:server.MatchData.data)
}

inline const MatchData* MatchData::internal_default_instance() {
  return &MatchData_default_instance_.get();
}
// -------------------------------------------------------------------

// TMatchLeave

// optional bytes match_id = 1;
inline void TMatchLeave::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TMatchLeave::match_id() const {
  // @@protoc_insertion_point(field_get:server.TMatchLeave.match_id)
  return match_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TMatchLeave::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TMatchLeave.match_id)
}
inline void TMatchLeave::set_match_id(const char* value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TMatchLeave.match_id)
}
inline void TMatchLeave::set_match_id(const void* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TMatchLeave.match_id)
}
inline ::std::string* TMatchLeave::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TMatchLeave.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TMatchLeave::release_match_id() {
  // @@protoc_insertion_point(field_release:server.TMatchLeave.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TMatchLeave::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:server.TMatchLeave.match_id)
}

inline const TMatchLeave* TMatchLeave::internal_default_instance() {
  return &TMatchLeave_default_instance_.get();
}
// -------------------------------------------------------------------

// MatchPresence

// optional bytes match_id = 1;
inline void MatchPresence::clear_match_id() {
  match_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchPresence::match_id() const {
  // @@protoc_insertion_point(field_get:server.MatchPresence.match_id)
  return match_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchPresence::set_match_id(const ::std::string& value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.MatchPresence.match_id)
}
inline void MatchPresence::set_match_id(const char* value) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.MatchPresence.match_id)
}
inline void MatchPresence::set_match_id(const void* value, size_t size) {
  
  match_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.MatchPresence.match_id)
}
inline ::std::string* MatchPresence::mutable_match_id() {
  
  // @@protoc_insertion_point(field_mutable:server.MatchPresence.match_id)
  return match_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchPresence::release_match_id() {
  // @@protoc_insertion_point(field_release:server.MatchPresence.match_id)
  
  return match_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchPresence::set_allocated_match_id(::std::string* match_id) {
  if (match_id != NULL) {
    
  } else {
    
  }
  match_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_id);
  // @@protoc_insertion_point(field_set_allocated:server.MatchPresence.match_id)
}

// repeated .server.UserPresence joins = 2;
inline int MatchPresence::joins_size() const {
  return joins_.size();
}
inline void MatchPresence::clear_joins() {
  joins_.Clear();
}
inline const ::server::UserPresence& MatchPresence::joins(int index) const {
  // @@protoc_insertion_point(field_get:server.MatchPresence.joins)
  return joins_.Get(index);
}
inline ::server::UserPresence* MatchPresence::mutable_joins(int index) {
  // @@protoc_insertion_point(field_mutable:server.MatchPresence.joins)
  return joins_.Mutable(index);
}
inline ::server::UserPresence* MatchPresence::add_joins() {
  // @@protoc_insertion_point(field_add:server.MatchPresence.joins)
  return joins_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
MatchPresence::mutable_joins() {
  // @@protoc_insertion_point(field_mutable_list:server.MatchPresence.joins)
  return &joins_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
MatchPresence::joins() const {
  // @@protoc_insertion_point(field_list:server.MatchPresence.joins)
  return joins_;
}

// repeated .server.UserPresence leaves = 3;
inline int MatchPresence::leaves_size() const {
  return leaves_.size();
}
inline void MatchPresence::clear_leaves() {
  leaves_.Clear();
}
inline const ::server::UserPresence& MatchPresence::leaves(int index) const {
  // @@protoc_insertion_point(field_get:server.MatchPresence.leaves)
  return leaves_.Get(index);
}
inline ::server::UserPresence* MatchPresence::mutable_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:server.MatchPresence.leaves)
  return leaves_.Mutable(index);
}
inline ::server::UserPresence* MatchPresence::add_leaves() {
  // @@protoc_insertion_point(field_add:server.MatchPresence.leaves)
  return leaves_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::UserPresence >*
MatchPresence::mutable_leaves() {
  // @@protoc_insertion_point(field_mutable_list:server.MatchPresence.leaves)
  return &leaves_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::UserPresence >&
MatchPresence::leaves() const {
  // @@protoc_insertion_point(field_list:server.MatchPresence.leaves)
  return leaves_;
}

inline const MatchPresence* MatchPresence::internal_default_instance() {
  return &MatchPresence_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageFetch_StorageKey

// optional string bucket = 1;
inline void TStorageFetch_StorageKey::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageFetch_StorageKey::bucket() const {
  // @@protoc_insertion_point(field_get:server.TStorageFetch.StorageKey.bucket)
  return bucket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageFetch_StorageKey::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageFetch.StorageKey.bucket)
}
inline void TStorageFetch_StorageKey::set_bucket(const char* value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageFetch.StorageKey.bucket)
}
inline void TStorageFetch_StorageKey::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageFetch.StorageKey.bucket)
}
inline ::std::string* TStorageFetch_StorageKey::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageFetch.StorageKey.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageFetch_StorageKey::release_bucket() {
  // @@protoc_insertion_point(field_release:server.TStorageFetch.StorageKey.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageFetch_StorageKey::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageFetch.StorageKey.bucket)
}

// optional string collection = 2;
inline void TStorageFetch_StorageKey::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageFetch_StorageKey::collection() const {
  // @@protoc_insertion_point(field_get:server.TStorageFetch.StorageKey.collection)
  return collection_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageFetch_StorageKey::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageFetch.StorageKey.collection)
}
inline void TStorageFetch_StorageKey::set_collection(const char* value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageFetch.StorageKey.collection)
}
inline void TStorageFetch_StorageKey::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageFetch.StorageKey.collection)
}
inline ::std::string* TStorageFetch_StorageKey::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageFetch.StorageKey.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageFetch_StorageKey::release_collection() {
  // @@protoc_insertion_point(field_release:server.TStorageFetch.StorageKey.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageFetch_StorageKey::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageFetch.StorageKey.collection)
}

// optional string record = 3;
inline void TStorageFetch_StorageKey::clear_record() {
  record_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageFetch_StorageKey::record() const {
  // @@protoc_insertion_point(field_get:server.TStorageFetch.StorageKey.record)
  return record_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageFetch_StorageKey::set_record(const ::std::string& value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageFetch.StorageKey.record)
}
inline void TStorageFetch_StorageKey::set_record(const char* value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageFetch.StorageKey.record)
}
inline void TStorageFetch_StorageKey::set_record(const char* value, size_t size) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageFetch.StorageKey.record)
}
inline ::std::string* TStorageFetch_StorageKey::mutable_record() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageFetch.StorageKey.record)
  return record_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageFetch_StorageKey::release_record() {
  // @@protoc_insertion_point(field_release:server.TStorageFetch.StorageKey.record)
  
  return record_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageFetch_StorageKey::set_allocated_record(::std::string* record) {
  if (record != NULL) {
    
  } else {
    
  }
  record_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), record);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageFetch.StorageKey.record)
}

// optional bytes user_id = 4;
inline void TStorageFetch_StorageKey::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageFetch_StorageKey::user_id() const {
  // @@protoc_insertion_point(field_get:server.TStorageFetch.StorageKey.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageFetch_StorageKey::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageFetch.StorageKey.user_id)
}
inline void TStorageFetch_StorageKey::set_user_id(const char* value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageFetch.StorageKey.user_id)
}
inline void TStorageFetch_StorageKey::set_user_id(const void* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageFetch.StorageKey.user_id)
}
inline ::std::string* TStorageFetch_StorageKey::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageFetch.StorageKey.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageFetch_StorageKey::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TStorageFetch.StorageKey.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageFetch_StorageKey::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageFetch.StorageKey.user_id)
}

inline const TStorageFetch_StorageKey* TStorageFetch_StorageKey::internal_default_instance() {
  return &TStorageFetch_StorageKey_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageFetch

// repeated .server.TStorageFetch.StorageKey keys = 1;
inline int TStorageFetch::keys_size() const {
  return keys_.size();
}
inline void TStorageFetch::clear_keys() {
  keys_.Clear();
}
inline const ::server::TStorageFetch_StorageKey& TStorageFetch::keys(int index) const {
  // @@protoc_insertion_point(field_get:server.TStorageFetch.keys)
  return keys_.Get(index);
}
inline ::server::TStorageFetch_StorageKey* TStorageFetch::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:server.TStorageFetch.keys)
  return keys_.Mutable(index);
}
inline ::server::TStorageFetch_StorageKey* TStorageFetch::add_keys() {
  // @@protoc_insertion_point(field_add:server.TStorageFetch.keys)
  return keys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::TStorageFetch_StorageKey >*
TStorageFetch::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:server.TStorageFetch.keys)
  return &keys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::TStorageFetch_StorageKey >&
TStorageFetch::keys() const {
  // @@protoc_insertion_point(field_list:server.TStorageFetch.keys)
  return keys_;
}

inline const TStorageFetch* TStorageFetch::internal_default_instance() {
  return &TStorageFetch_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageData_StorageData

// optional string bucket = 1;
inline void TStorageData_StorageData::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageData_StorageData::bucket() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.bucket)
  return bucket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.bucket)
}
inline void TStorageData_StorageData::set_bucket(const char* value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageData.StorageData.bucket)
}
inline void TStorageData_StorageData::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageData.StorageData.bucket)
}
inline ::std::string* TStorageData_StorageData::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageData.StorageData.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageData_StorageData::release_bucket() {
  // @@protoc_insertion_point(field_release:server.TStorageData.StorageData.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageData.StorageData.bucket)
}

// optional string collection = 2;
inline void TStorageData_StorageData::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageData_StorageData::collection() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.collection)
  return collection_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.collection)
}
inline void TStorageData_StorageData::set_collection(const char* value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageData.StorageData.collection)
}
inline void TStorageData_StorageData::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageData.StorageData.collection)
}
inline ::std::string* TStorageData_StorageData::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageData.StorageData.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageData_StorageData::release_collection() {
  // @@protoc_insertion_point(field_release:server.TStorageData.StorageData.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageData.StorageData.collection)
}

// optional string record = 3;
inline void TStorageData_StorageData::clear_record() {
  record_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageData_StorageData::record() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.record)
  return record_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_record(const ::std::string& value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.record)
}
inline void TStorageData_StorageData::set_record(const char* value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageData.StorageData.record)
}
inline void TStorageData_StorageData::set_record(const char* value, size_t size) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageData.StorageData.record)
}
inline ::std::string* TStorageData_StorageData::mutable_record() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageData.StorageData.record)
  return record_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageData_StorageData::release_record() {
  // @@protoc_insertion_point(field_release:server.TStorageData.StorageData.record)
  
  return record_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_allocated_record(::std::string* record) {
  if (record != NULL) {
    
  } else {
    
  }
  record_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), record);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageData.StorageData.record)
}

// optional bytes user_id = 4;
inline void TStorageData_StorageData::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageData_StorageData::user_id() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.user_id)
}
inline void TStorageData_StorageData::set_user_id(const char* value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageData.StorageData.user_id)
}
inline void TStorageData_StorageData::set_user_id(const void* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageData.StorageData.user_id)
}
inline ::std::string* TStorageData_StorageData::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageData.StorageData.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageData_StorageData::release_user_id() {
  // @@protoc_insertion_point(field_release:server.TStorageData.StorageData.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageData.StorageData.user_id)
}

// optional bytes value = 5;
inline void TStorageData_StorageData::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageData_StorageData::value() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.value)
}
inline void TStorageData_StorageData::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageData.StorageData.value)
}
inline void TStorageData_StorageData::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageData.StorageData.value)
}
inline ::std::string* TStorageData_StorageData::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageData.StorageData.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageData_StorageData::release_value() {
  // @@protoc_insertion_point(field_release:server.TStorageData.StorageData.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageData.StorageData.value)
}

// optional bytes version = 6;
inline void TStorageData_StorageData::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageData_StorageData::version() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.version)
}
inline void TStorageData_StorageData::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageData.StorageData.version)
}
inline void TStorageData_StorageData::set_version(const void* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageData.StorageData.version)
}
inline ::std::string* TStorageData_StorageData::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageData.StorageData.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageData_StorageData::release_version() {
  // @@protoc_insertion_point(field_release:server.TStorageData.StorageData.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageData_StorageData::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageData.StorageData.version)
}

// optional int32 permission_read = 7;
inline void TStorageData_StorageData::clear_permission_read() {
  permission_read_ = 0;
}
inline ::google::protobuf::int32 TStorageData_StorageData::permission_read() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.permission_read)
  return permission_read_;
}
inline void TStorageData_StorageData::set_permission_read(::google::protobuf::int32 value) {
  
  permission_read_ = value;
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.permission_read)
}

// optional int32 permission_write = 8;
inline void TStorageData_StorageData::clear_permission_write() {
  permission_write_ = 0;
}
inline ::google::protobuf::int32 TStorageData_StorageData::permission_write() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.permission_write)
  return permission_write_;
}
inline void TStorageData_StorageData::set_permission_write(::google::protobuf::int32 value) {
  
  permission_write_ = value;
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.permission_write)
}

// optional int64 created_at = 9;
inline void TStorageData_StorageData::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TStorageData_StorageData::created_at() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.created_at)
  return created_at_;
}
inline void TStorageData_StorageData::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.created_at)
}

// optional int64 updated_at = 10;
inline void TStorageData_StorageData::clear_updated_at() {
  updated_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TStorageData_StorageData::updated_at() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.updated_at)
  return updated_at_;
}
inline void TStorageData_StorageData::set_updated_at(::google::protobuf::int64 value) {
  
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.updated_at)
}

// optional int64 expires_at = 11;
inline void TStorageData_StorageData::clear_expires_at() {
  expires_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TStorageData_StorageData::expires_at() const {
  // @@protoc_insertion_point(field_get:server.TStorageData.StorageData.expires_at)
  return expires_at_;
}
inline void TStorageData_StorageData::set_expires_at(::google::protobuf::int64 value) {
  
  expires_at_ = value;
  // @@protoc_insertion_point(field_set:server.TStorageData.StorageData.expires_at)
}

inline const TStorageData_StorageData* TStorageData_StorageData::internal_default_instance() {
  return &TStorageData_StorageData_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageData

// repeated .server.TStorageData.StorageData data = 1;
inline int TStorageData::data_size() const {
  return data_.size();
}
inline void TStorageData::clear_data() {
  data_.Clear();
}
inline const ::server::TStorageData_StorageData& TStorageData::data(int index) const {
  // @@protoc_insertion_point(field_get:server.TStorageData.data)
  return data_.Get(index);
}
inline ::server::TStorageData_StorageData* TStorageData::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:server.TStorageData.data)
  return data_.Mutable(index);
}
inline ::server::TStorageData_StorageData* TStorageData::add_data() {
  // @@protoc_insertion_point(field_add:server.TStorageData.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::TStorageData_StorageData >*
TStorageData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:server.TStorageData.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::TStorageData_StorageData >&
TStorageData::data() const {
  // @@protoc_insertion_point(field_list:server.TStorageData.data)
  return data_;
}

inline const TStorageData* TStorageData::internal_default_instance() {
  return &TStorageData_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageWrite_StorageData

// optional string bucket = 1;
inline void TStorageWrite_StorageData::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageWrite_StorageData::bucket() const {
  // @@protoc_insertion_point(field_get:server.TStorageWrite.StorageData.bucket)
  return bucket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageWrite.StorageData.bucket)
}
inline void TStorageWrite_StorageData::set_bucket(const char* value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageWrite.StorageData.bucket)
}
inline void TStorageWrite_StorageData::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageWrite.StorageData.bucket)
}
inline ::std::string* TStorageWrite_StorageData::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageWrite.StorageData.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageWrite_StorageData::release_bucket() {
  // @@protoc_insertion_point(field_release:server.TStorageWrite.StorageData.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageWrite.StorageData.bucket)
}

// optional string collection = 2;
inline void TStorageWrite_StorageData::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageWrite_StorageData::collection() const {
  // @@protoc_insertion_point(field_get:server.TStorageWrite.StorageData.collection)
  return collection_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageWrite.StorageData.collection)
}
inline void TStorageWrite_StorageData::set_collection(const char* value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageWrite.StorageData.collection)
}
inline void TStorageWrite_StorageData::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageWrite.StorageData.collection)
}
inline ::std::string* TStorageWrite_StorageData::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageWrite.StorageData.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageWrite_StorageData::release_collection() {
  // @@protoc_insertion_point(field_release:server.TStorageWrite.StorageData.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageWrite.StorageData.collection)
}

// optional string record = 3;
inline void TStorageWrite_StorageData::clear_record() {
  record_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageWrite_StorageData::record() const {
  // @@protoc_insertion_point(field_get:server.TStorageWrite.StorageData.record)
  return record_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_record(const ::std::string& value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageWrite.StorageData.record)
}
inline void TStorageWrite_StorageData::set_record(const char* value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageWrite.StorageData.record)
}
inline void TStorageWrite_StorageData::set_record(const char* value, size_t size) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageWrite.StorageData.record)
}
inline ::std::string* TStorageWrite_StorageData::mutable_record() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageWrite.StorageData.record)
  return record_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageWrite_StorageData::release_record() {
  // @@protoc_insertion_point(field_release:server.TStorageWrite.StorageData.record)
  
  return record_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_allocated_record(::std::string* record) {
  if (record != NULL) {
    
  } else {
    
  }
  record_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), record);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageWrite.StorageData.record)
}

// optional bytes value = 4;
inline void TStorageWrite_StorageData::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageWrite_StorageData::value() const {
  // @@protoc_insertion_point(field_get:server.TStorageWrite.StorageData.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageWrite.StorageData.value)
}
inline void TStorageWrite_StorageData::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageWrite.StorageData.value)
}
inline void TStorageWrite_StorageData::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageWrite.StorageData.value)
}
inline ::std::string* TStorageWrite_StorageData::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageWrite.StorageData.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageWrite_StorageData::release_value() {
  // @@protoc_insertion_point(field_release:server.TStorageWrite.StorageData.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageWrite.StorageData.value)
}

// optional bytes version = 5;
inline void TStorageWrite_StorageData::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageWrite_StorageData::version() const {
  // @@protoc_insertion_point(field_get:server.TStorageWrite.StorageData.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageWrite.StorageData.version)
}
inline void TStorageWrite_StorageData::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageWrite.StorageData.version)
}
inline void TStorageWrite_StorageData::set_version(const void* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageWrite.StorageData.version)
}
inline ::std::string* TStorageWrite_StorageData::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageWrite.StorageData.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageWrite_StorageData::release_version() {
  // @@protoc_insertion_point(field_release:server.TStorageWrite.StorageData.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageWrite_StorageData::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageWrite.StorageData.version)
}

// optional int32 permission_read = 6;
inline void TStorageWrite_StorageData::clear_permission_read() {
  permission_read_ = 0;
}
inline ::google::protobuf::int32 TStorageWrite_StorageData::permission_read() const {
  // @@protoc_insertion_point(field_get:server.TStorageWrite.StorageData.permission_read)
  return permission_read_;
}
inline void TStorageWrite_StorageData::set_permission_read(::google::protobuf::int32 value) {
  
  permission_read_ = value;
  // @@protoc_insertion_point(field_set:server.TStorageWrite.StorageData.permission_read)
}

// optional int32 permission_write = 7;
inline void TStorageWrite_StorageData::clear_permission_write() {
  permission_write_ = 0;
}
inline ::google::protobuf::int32 TStorageWrite_StorageData::permission_write() const {
  // @@protoc_insertion_point(field_get:server.TStorageWrite.StorageData.permission_write)
  return permission_write_;
}
inline void TStorageWrite_StorageData::set_permission_write(::google::protobuf::int32 value) {
  
  permission_write_ = value;
  // @@protoc_insertion_point(field_set:server.TStorageWrite.StorageData.permission_write)
}

inline const TStorageWrite_StorageData* TStorageWrite_StorageData::internal_default_instance() {
  return &TStorageWrite_StorageData_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageWrite

// repeated .server.TStorageWrite.StorageData data = 3;
inline int TStorageWrite::data_size() const {
  return data_.size();
}
inline void TStorageWrite::clear_data() {
  data_.Clear();
}
inline const ::server::TStorageWrite_StorageData& TStorageWrite::data(int index) const {
  // @@protoc_insertion_point(field_get:server.TStorageWrite.data)
  return data_.Get(index);
}
inline ::server::TStorageWrite_StorageData* TStorageWrite::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:server.TStorageWrite.data)
  return data_.Mutable(index);
}
inline ::server::TStorageWrite_StorageData* TStorageWrite::add_data() {
  // @@protoc_insertion_point(field_add:server.TStorageWrite.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::TStorageWrite_StorageData >*
TStorageWrite::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:server.TStorageWrite.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::TStorageWrite_StorageData >&
TStorageWrite::data() const {
  // @@protoc_insertion_point(field_list:server.TStorageWrite.data)
  return data_;
}

inline const TStorageWrite* TStorageWrite::internal_default_instance() {
  return &TStorageWrite_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageKey_StorageKey

// optional string bucket = 1;
inline void TStorageKey_StorageKey::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageKey_StorageKey::bucket() const {
  // @@protoc_insertion_point(field_get:server.TStorageKey.StorageKey.bucket)
  return bucket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageKey_StorageKey::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageKey.StorageKey.bucket)
}
inline void TStorageKey_StorageKey::set_bucket(const char* value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageKey.StorageKey.bucket)
}
inline void TStorageKey_StorageKey::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageKey.StorageKey.bucket)
}
inline ::std::string* TStorageKey_StorageKey::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageKey.StorageKey.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageKey_StorageKey::release_bucket() {
  // @@protoc_insertion_point(field_release:server.TStorageKey.StorageKey.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageKey_StorageKey::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageKey.StorageKey.bucket)
}

// optional string collection = 2;
inline void TStorageKey_StorageKey::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageKey_StorageKey::collection() const {
  // @@protoc_insertion_point(field_get:server.TStorageKey.StorageKey.collection)
  return collection_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageKey_StorageKey::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageKey.StorageKey.collection)
}
inline void TStorageKey_StorageKey::set_collection(const char* value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageKey.StorageKey.collection)
}
inline void TStorageKey_StorageKey::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageKey.StorageKey.collection)
}
inline ::std::string* TStorageKey_StorageKey::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageKey.StorageKey.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageKey_StorageKey::release_collection() {
  // @@protoc_insertion_point(field_release:server.TStorageKey.StorageKey.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageKey_StorageKey::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageKey.StorageKey.collection)
}

// optional string record = 3;
inline void TStorageKey_StorageKey::clear_record() {
  record_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageKey_StorageKey::record() const {
  // @@protoc_insertion_point(field_get:server.TStorageKey.StorageKey.record)
  return record_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageKey_StorageKey::set_record(const ::std::string& value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageKey.StorageKey.record)
}
inline void TStorageKey_StorageKey::set_record(const char* value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageKey.StorageKey.record)
}
inline void TStorageKey_StorageKey::set_record(const char* value, size_t size) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageKey.StorageKey.record)
}
inline ::std::string* TStorageKey_StorageKey::mutable_record() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageKey.StorageKey.record)
  return record_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageKey_StorageKey::release_record() {
  // @@protoc_insertion_point(field_release:server.TStorageKey.StorageKey.record)
  
  return record_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageKey_StorageKey::set_allocated_record(::std::string* record) {
  if (record != NULL) {
    
  } else {
    
  }
  record_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), record);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageKey.StorageKey.record)
}

// optional bytes version = 4;
inline void TStorageKey_StorageKey::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageKey_StorageKey::version() const {
  // @@protoc_insertion_point(field_get:server.TStorageKey.StorageKey.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageKey_StorageKey::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageKey.StorageKey.version)
}
inline void TStorageKey_StorageKey::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageKey.StorageKey.version)
}
inline void TStorageKey_StorageKey::set_version(const void* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageKey.StorageKey.version)
}
inline ::std::string* TStorageKey_StorageKey::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageKey.StorageKey.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageKey_StorageKey::release_version() {
  // @@protoc_insertion_point(field_release:server.TStorageKey.StorageKey.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageKey_StorageKey::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageKey.StorageKey.version)
}

inline const TStorageKey_StorageKey* TStorageKey_StorageKey::internal_default_instance() {
  return &TStorageKey_StorageKey_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageKey

// repeated .server.TStorageKey.StorageKey keys = 1;
inline int TStorageKey::keys_size() const {
  return keys_.size();
}
inline void TStorageKey::clear_keys() {
  keys_.Clear();
}
inline const ::server::TStorageKey_StorageKey& TStorageKey::keys(int index) const {
  // @@protoc_insertion_point(field_get:server.TStorageKey.keys)
  return keys_.Get(index);
}
inline ::server::TStorageKey_StorageKey* TStorageKey::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:server.TStorageKey.keys)
  return keys_.Mutable(index);
}
inline ::server::TStorageKey_StorageKey* TStorageKey::add_keys() {
  // @@protoc_insertion_point(field_add:server.TStorageKey.keys)
  return keys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::TStorageKey_StorageKey >*
TStorageKey::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:server.TStorageKey.keys)
  return &keys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::TStorageKey_StorageKey >&
TStorageKey::keys() const {
  // @@protoc_insertion_point(field_list:server.TStorageKey.keys)
  return keys_;
}

inline const TStorageKey* TStorageKey::internal_default_instance() {
  return &TStorageKey_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageRemove_StorageKey

// optional string bucket = 1;
inline void TStorageRemove_StorageKey::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageRemove_StorageKey::bucket() const {
  // @@protoc_insertion_point(field_get:server.TStorageRemove.StorageKey.bucket)
  return bucket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageRemove_StorageKey::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageRemove.StorageKey.bucket)
}
inline void TStorageRemove_StorageKey::set_bucket(const char* value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageRemove.StorageKey.bucket)
}
inline void TStorageRemove_StorageKey::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageRemove.StorageKey.bucket)
}
inline ::std::string* TStorageRemove_StorageKey::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageRemove.StorageKey.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageRemove_StorageKey::release_bucket() {
  // @@protoc_insertion_point(field_release:server.TStorageRemove.StorageKey.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageRemove_StorageKey::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageRemove.StorageKey.bucket)
}

// optional string collection = 2;
inline void TStorageRemove_StorageKey::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageRemove_StorageKey::collection() const {
  // @@protoc_insertion_point(field_get:server.TStorageRemove.StorageKey.collection)
  return collection_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageRemove_StorageKey::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageRemove.StorageKey.collection)
}
inline void TStorageRemove_StorageKey::set_collection(const char* value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageRemove.StorageKey.collection)
}
inline void TStorageRemove_StorageKey::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageRemove.StorageKey.collection)
}
inline ::std::string* TStorageRemove_StorageKey::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageRemove.StorageKey.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageRemove_StorageKey::release_collection() {
  // @@protoc_insertion_point(field_release:server.TStorageRemove.StorageKey.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageRemove_StorageKey::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageRemove.StorageKey.collection)
}

// optional string record = 3;
inline void TStorageRemove_StorageKey::clear_record() {
  record_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageRemove_StorageKey::record() const {
  // @@protoc_insertion_point(field_get:server.TStorageRemove.StorageKey.record)
  return record_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageRemove_StorageKey::set_record(const ::std::string& value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageRemove.StorageKey.record)
}
inline void TStorageRemove_StorageKey::set_record(const char* value) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageRemove.StorageKey.record)
}
inline void TStorageRemove_StorageKey::set_record(const char* value, size_t size) {
  
  record_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageRemove.StorageKey.record)
}
inline ::std::string* TStorageRemove_StorageKey::mutable_record() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageRemove.StorageKey.record)
  return record_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageRemove_StorageKey::release_record() {
  // @@protoc_insertion_point(field_release:server.TStorageRemove.StorageKey.record)
  
  return record_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageRemove_StorageKey::set_allocated_record(::std::string* record) {
  if (record != NULL) {
    
  } else {
    
  }
  record_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), record);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageRemove.StorageKey.record)
}

// optional bytes version = 4;
inline void TStorageRemove_StorageKey::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TStorageRemove_StorageKey::version() const {
  // @@protoc_insertion_point(field_get:server.TStorageRemove.StorageKey.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageRemove_StorageKey::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TStorageRemove.StorageKey.version)
}
inline void TStorageRemove_StorageKey::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TStorageRemove.StorageKey.version)
}
inline void TStorageRemove_StorageKey::set_version(const void* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TStorageRemove.StorageKey.version)
}
inline ::std::string* TStorageRemove_StorageKey::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:server.TStorageRemove.StorageKey.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStorageRemove_StorageKey::release_version() {
  // @@protoc_insertion_point(field_release:server.TStorageRemove.StorageKey.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStorageRemove_StorageKey::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:server.TStorageRemove.StorageKey.version)
}

inline const TStorageRemove_StorageKey* TStorageRemove_StorageKey::internal_default_instance() {
  return &TStorageRemove_StorageKey_default_instance_.get();
}
// -------------------------------------------------------------------

// TStorageRemove

// repeated .server.TStorageRemove.StorageKey keys = 1;
inline int TStorageRemove::keys_size() const {
  return keys_.size();
}
inline void TStorageRemove::clear_keys() {
  keys_.Clear();
}
inline const ::server::TStorageRemove_StorageKey& TStorageRemove::keys(int index) const {
  // @@protoc_insertion_point(field_get:server.TStorageRemove.keys)
  return keys_.Get(index);
}
inline ::server::TStorageRemove_StorageKey* TStorageRemove::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:server.TStorageRemove.keys)
  return keys_.Mutable(index);
}
inline ::server::TStorageRemove_StorageKey* TStorageRemove::add_keys() {
  // @@protoc_insertion_point(field_add:server.TStorageRemove.keys)
  return keys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::TStorageRemove_StorageKey >*
TStorageRemove::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:server.TStorageRemove.keys)
  return &keys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::TStorageRemove_StorageKey >&
TStorageRemove::keys() const {
  // @@protoc_insertion_point(field_list:server.TStorageRemove.keys)
  return keys_;
}

inline const TStorageRemove* TStorageRemove::internal_default_instance() {
  return &TStorageRemove_default_instance_.get();
}
// -------------------------------------------------------------------

// Leaderboard

// optional bytes id = 1;
inline void Leaderboard::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Leaderboard::id() const {
  // @@protoc_insertion_point(field_get:server.Leaderboard.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Leaderboard.id)
}
inline void Leaderboard::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Leaderboard.id)
}
inline void Leaderboard::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Leaderboard.id)
}
inline ::std::string* Leaderboard::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Leaderboard.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Leaderboard::release_id() {
  // @@protoc_insertion_point(field_release:server.Leaderboard.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:server.Leaderboard.id)
}

// optional bool authoritative = 2;
inline void Leaderboard::clear_authoritative() {
  authoritative_ = false;
}
inline bool Leaderboard::authoritative() const {
  // @@protoc_insertion_point(field_get:server.Leaderboard.authoritative)
  return authoritative_;
}
inline void Leaderboard::set_authoritative(bool value) {
  
  authoritative_ = value;
  // @@protoc_insertion_point(field_set:server.Leaderboard.authoritative)
}

// optional int64 sort = 3;
inline void Leaderboard::clear_sort() {
  sort_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Leaderboard::sort() const {
  // @@protoc_insertion_point(field_get:server.Leaderboard.sort)
  return sort_;
}
inline void Leaderboard::set_sort(::google::protobuf::int64 value) {
  
  sort_ = value;
  // @@protoc_insertion_point(field_set:server.Leaderboard.sort)
}

// optional int64 count = 4;
inline void Leaderboard::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Leaderboard::count() const {
  // @@protoc_insertion_point(field_get:server.Leaderboard.count)
  return count_;
}
inline void Leaderboard::set_count(::google::protobuf::int64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:server.Leaderboard.count)
}

// optional string reset_schedule = 5;
inline void Leaderboard::clear_reset_schedule() {
  reset_schedule_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Leaderboard::reset_schedule() const {
  // @@protoc_insertion_point(field_get:server.Leaderboard.reset_schedule)
  return reset_schedule_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_reset_schedule(const ::std::string& value) {
  
  reset_schedule_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Leaderboard.reset_schedule)
}
inline void Leaderboard::set_reset_schedule(const char* value) {
  
  reset_schedule_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Leaderboard.reset_schedule)
}
inline void Leaderboard::set_reset_schedule(const char* value, size_t size) {
  
  reset_schedule_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Leaderboard.reset_schedule)
}
inline ::std::string* Leaderboard::mutable_reset_schedule() {
  
  // @@protoc_insertion_point(field_mutable:server.Leaderboard.reset_schedule)
  return reset_schedule_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Leaderboard::release_reset_schedule() {
  // @@protoc_insertion_point(field_release:server.Leaderboard.reset_schedule)
  
  return reset_schedule_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_allocated_reset_schedule(::std::string* reset_schedule) {
  if (reset_schedule != NULL) {
    
  } else {
    
  }
  reset_schedule_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reset_schedule);
  // @@protoc_insertion_point(field_set_allocated:server.Leaderboard.reset_schedule)
}

// optional bytes metadata = 6;
inline void Leaderboard::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Leaderboard::metadata() const {
  // @@protoc_insertion_point(field_get:server.Leaderboard.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Leaderboard.metadata)
}
inline void Leaderboard::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Leaderboard.metadata)
}
inline void Leaderboard::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Leaderboard.metadata)
}
inline ::std::string* Leaderboard::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:server.Leaderboard.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Leaderboard::release_metadata() {
  // @@protoc_insertion_point(field_release:server.Leaderboard.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:server.Leaderboard.metadata)
}

// optional bytes next_id = 7;
inline void Leaderboard::clear_next_id() {
  next_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Leaderboard::next_id() const {
  // @@protoc_insertion_point(field_get:server.Leaderboard.next_id)
  return next_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_next_id(const ::std::string& value) {
  
  next_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Leaderboard.next_id)
}
inline void Leaderboard::set_next_id(const char* value) {
  
  next_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Leaderboard.next_id)
}
inline void Leaderboard::set_next_id(const void* value, size_t size) {
  
  next_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Leaderboard.next_id)
}
inline ::std::string* Leaderboard::mutable_next_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Leaderboard.next_id)
  return next_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Leaderboard::release_next_id() {
  // @@protoc_insertion_point(field_release:server.Leaderboard.next_id)
  
  return next_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_allocated_next_id(::std::string* next_id) {
  if (next_id != NULL) {
    
  } else {
    
  }
  next_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_id);
  // @@protoc_insertion_point(field_set_allocated:server.Leaderboard.next_id)
}

// optional bytes prev_id = 8;
inline void Leaderboard::clear_prev_id() {
  prev_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Leaderboard::prev_id() const {
  // @@protoc_insertion_point(field_get:server.Leaderboard.prev_id)
  return prev_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_prev_id(const ::std::string& value) {
  
  prev_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.Leaderboard.prev_id)
}
inline void Leaderboard::set_prev_id(const char* value) {
  
  prev_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.Leaderboard.prev_id)
}
inline void Leaderboard::set_prev_id(const void* value, size_t size) {
  
  prev_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.Leaderboard.prev_id)
}
inline ::std::string* Leaderboard::mutable_prev_id() {
  
  // @@protoc_insertion_point(field_mutable:server.Leaderboard.prev_id)
  return prev_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Leaderboard::release_prev_id() {
  // @@protoc_insertion_point(field_release:server.Leaderboard.prev_id)
  
  return prev_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Leaderboard::set_allocated_prev_id(::std::string* prev_id) {
  if (prev_id != NULL) {
    
  } else {
    
  }
  prev_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_id);
  // @@protoc_insertion_point(field_set_allocated:server.Leaderboard.prev_id)
}

inline const Leaderboard* Leaderboard::internal_default_instance() {
  return &Leaderboard_default_instance_.get();
}
// -------------------------------------------------------------------

// LeaderboardRecord

// optional bytes leaderboard_id = 1;
inline void LeaderboardRecord::clear_leaderboard_id() {
  leaderboard_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::leaderboard_id() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.leaderboard_id)
  return leaderboard_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_leaderboard_id(const ::std::string& value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.leaderboard_id)
}
inline void LeaderboardRecord::set_leaderboard_id(const char* value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.LeaderboardRecord.leaderboard_id)
}
inline void LeaderboardRecord::set_leaderboard_id(const void* value, size_t size) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.LeaderboardRecord.leaderboard_id)
}
inline ::std::string* LeaderboardRecord::mutable_leaderboard_id() {
  
  // @@protoc_insertion_point(field_mutable:server.LeaderboardRecord.leaderboard_id)
  return leaderboard_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_leaderboard_id() {
  // @@protoc_insertion_point(field_release:server.LeaderboardRecord.leaderboard_id)
  
  return leaderboard_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_leaderboard_id(::std::string* leaderboard_id) {
  if (leaderboard_id != NULL) {
    
  } else {
    
  }
  leaderboard_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leaderboard_id);
  // @@protoc_insertion_point(field_set_allocated:server.LeaderboardRecord.leaderboard_id)
}

// optional bytes owner_id = 2;
inline void LeaderboardRecord::clear_owner_id() {
  owner_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::owner_id() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.owner_id)
  return owner_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_owner_id(const ::std::string& value) {
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.owner_id)
}
inline void LeaderboardRecord::set_owner_id(const char* value) {
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.LeaderboardRecord.owner_id)
}
inline void LeaderboardRecord::set_owner_id(const void* value, size_t size) {
  
  owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.LeaderboardRecord.owner_id)
}
inline ::std::string* LeaderboardRecord::mutable_owner_id() {
  
  // @@protoc_insertion_point(field_mutable:server.LeaderboardRecord.owner_id)
  return owner_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_owner_id() {
  // @@protoc_insertion_point(field_release:server.LeaderboardRecord.owner_id)
  
  return owner_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_owner_id(::std::string* owner_id) {
  if (owner_id != NULL) {
    
  } else {
    
  }
  owner_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_id);
  // @@protoc_insertion_point(field_set_allocated:server.LeaderboardRecord.owner_id)
}

// optional string handle = 3;
inline void LeaderboardRecord::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::handle() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.handle)
  return handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.handle)
}
inline void LeaderboardRecord::set_handle(const char* value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.LeaderboardRecord.handle)
}
inline void LeaderboardRecord::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.LeaderboardRecord.handle)
}
inline ::std::string* LeaderboardRecord::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:server.LeaderboardRecord.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_handle() {
  // @@protoc_insertion_point(field_release:server.LeaderboardRecord.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:server.LeaderboardRecord.handle)
}

// optional string lang = 4;
inline void LeaderboardRecord::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::lang() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.lang)
}
inline void LeaderboardRecord::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.LeaderboardRecord.lang)
}
inline void LeaderboardRecord::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.LeaderboardRecord.lang)
}
inline ::std::string* LeaderboardRecord::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:server.LeaderboardRecord.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_lang() {
  // @@protoc_insertion_point(field_release:server.LeaderboardRecord.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:server.LeaderboardRecord.lang)
}

// optional string location = 5;
inline void LeaderboardRecord::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::location() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.location)
}
inline void LeaderboardRecord::set_location(const char* value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.LeaderboardRecord.location)
}
inline void LeaderboardRecord::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.LeaderboardRecord.location)
}
inline ::std::string* LeaderboardRecord::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:server.LeaderboardRecord.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_location() {
  // @@protoc_insertion_point(field_release:server.LeaderboardRecord.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:server.LeaderboardRecord.location)
}

// optional string timezone = 6;
inline void LeaderboardRecord::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::timezone() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.timezone)
  return timezone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_timezone(const ::std::string& value) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.timezone)
}
inline void LeaderboardRecord::set_timezone(const char* value) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.LeaderboardRecord.timezone)
}
inline void LeaderboardRecord::set_timezone(const char* value, size_t size) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.LeaderboardRecord.timezone)
}
inline ::std::string* LeaderboardRecord::mutable_timezone() {
  
  // @@protoc_insertion_point(field_mutable:server.LeaderboardRecord.timezone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_timezone() {
  // @@protoc_insertion_point(field_release:server.LeaderboardRecord.timezone)
  
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    
  } else {
    
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:server.LeaderboardRecord.timezone)
}

// optional int64 rank = 7;
inline void LeaderboardRecord::clear_rank() {
  rank_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LeaderboardRecord::rank() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.rank)
  return rank_;
}
inline void LeaderboardRecord::set_rank(::google::protobuf::int64 value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.rank)
}

// optional int64 score = 8;
inline void LeaderboardRecord::clear_score() {
  score_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LeaderboardRecord::score() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.score)
  return score_;
}
inline void LeaderboardRecord::set_score(::google::protobuf::int64 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.score)
}

// optional int64 num_score = 9;
inline void LeaderboardRecord::clear_num_score() {
  num_score_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LeaderboardRecord::num_score() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.num_score)
  return num_score_;
}
inline void LeaderboardRecord::set_num_score(::google::protobuf::int64 value) {
  
  num_score_ = value;
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.num_score)
}

// optional bytes metadata = 10;
inline void LeaderboardRecord::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderboardRecord::metadata() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.metadata)
}
inline void LeaderboardRecord::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.LeaderboardRecord.metadata)
}
inline void LeaderboardRecord::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.LeaderboardRecord.metadata)
}
inline ::std::string* LeaderboardRecord::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:server.LeaderboardRecord.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderboardRecord::release_metadata() {
  // @@protoc_insertion_point(field_release:server.LeaderboardRecord.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderboardRecord::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:server.LeaderboardRecord.metadata)
}

// optional int64 ranked_at = 11;
inline void LeaderboardRecord::clear_ranked_at() {
  ranked_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LeaderboardRecord::ranked_at() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.ranked_at)
  return ranked_at_;
}
inline void LeaderboardRecord::set_ranked_at(::google::protobuf::int64 value) {
  
  ranked_at_ = value;
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.ranked_at)
}

// optional int64 updated_at = 12;
inline void LeaderboardRecord::clear_updated_at() {
  updated_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LeaderboardRecord::updated_at() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.updated_at)
  return updated_at_;
}
inline void LeaderboardRecord::set_updated_at(::google::protobuf::int64 value) {
  
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.updated_at)
}

// optional int64 expires_at = 13;
inline void LeaderboardRecord::clear_expires_at() {
  expires_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LeaderboardRecord::expires_at() const {
  // @@protoc_insertion_point(field_get:server.LeaderboardRecord.expires_at)
  return expires_at_;
}
inline void LeaderboardRecord::set_expires_at(::google::protobuf::int64 value) {
  
  expires_at_ = value;
  // @@protoc_insertion_point(field_set:server.LeaderboardRecord.expires_at)
}

inline const LeaderboardRecord* LeaderboardRecord::internal_default_instance() {
  return &LeaderboardRecord_default_instance_.get();
}
// -------------------------------------------------------------------

// TLeaderboardsList

// optional int64 limit = 1;
inline void TLeaderboardsList::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TLeaderboardsList::limit() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardsList.limit)
  return limit_;
}
inline void TLeaderboardsList::set_limit(::google::protobuf::int64 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:server.TLeaderboardsList.limit)
}

// optional bytes cursor = 2;
inline void TLeaderboardsList::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboardsList::cursor() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardsList.cursor)
  return cursor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardsList::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardsList.cursor)
}
inline void TLeaderboardsList::set_cursor(const char* value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardsList.cursor)
}
inline void TLeaderboardsList::set_cursor(const void* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardsList.cursor)
}
inline ::std::string* TLeaderboardsList::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardsList.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardsList::release_cursor() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardsList.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardsList::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardsList.cursor)
}

// repeated bytes filter_leaderboard_id = 3;
inline int TLeaderboardsList::filter_leaderboard_id_size() const {
  return filter_leaderboard_id_.size();
}
inline void TLeaderboardsList::clear_filter_leaderboard_id() {
  filter_leaderboard_id_.Clear();
}
inline const ::std::string& TLeaderboardsList::filter_leaderboard_id(int index) const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardsList.filter_leaderboard_id)
  return filter_leaderboard_id_.Get(index);
}
inline ::std::string* TLeaderboardsList::mutable_filter_leaderboard_id(int index) {
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardsList.filter_leaderboard_id)
  return filter_leaderboard_id_.Mutable(index);
}
inline void TLeaderboardsList::set_filter_leaderboard_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLeaderboardsList.filter_leaderboard_id)
  filter_leaderboard_id_.Mutable(index)->assign(value);
}
inline void TLeaderboardsList::set_filter_leaderboard_id(int index, const char* value) {
  filter_leaderboard_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardsList.filter_leaderboard_id)
}
inline void TLeaderboardsList::set_filter_leaderboard_id(int index, const void* value, size_t size) {
  filter_leaderboard_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardsList.filter_leaderboard_id)
}
inline ::std::string* TLeaderboardsList::add_filter_leaderboard_id() {
  // @@protoc_insertion_point(field_add_mutable:server.TLeaderboardsList.filter_leaderboard_id)
  return filter_leaderboard_id_.Add();
}
inline void TLeaderboardsList::add_filter_leaderboard_id(const ::std::string& value) {
  filter_leaderboard_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:server.TLeaderboardsList.filter_leaderboard_id)
}
inline void TLeaderboardsList::add_filter_leaderboard_id(const char* value) {
  filter_leaderboard_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:server.TLeaderboardsList.filter_leaderboard_id)
}
inline void TLeaderboardsList::add_filter_leaderboard_id(const void* value, size_t size) {
  filter_leaderboard_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:server.TLeaderboardsList.filter_leaderboard_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TLeaderboardsList::filter_leaderboard_id() const {
  // @@protoc_insertion_point(field_list:server.TLeaderboardsList.filter_leaderboard_id)
  return filter_leaderboard_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TLeaderboardsList::mutable_filter_leaderboard_id() {
  // @@protoc_insertion_point(field_mutable_list:server.TLeaderboardsList.filter_leaderboard_id)
  return &filter_leaderboard_id_;
}

inline const TLeaderboardsList* TLeaderboardsList::internal_default_instance() {
  return &TLeaderboardsList_default_instance_.get();
}
// -------------------------------------------------------------------

// TLeaderboards

// repeated .server.Leaderboard leaderboards = 1;
inline int TLeaderboards::leaderboards_size() const {
  return leaderboards_.size();
}
inline void TLeaderboards::clear_leaderboards() {
  leaderboards_.Clear();
}
inline const ::server::Leaderboard& TLeaderboards::leaderboards(int index) const {
  // @@protoc_insertion_point(field_get:server.TLeaderboards.leaderboards)
  return leaderboards_.Get(index);
}
inline ::server::Leaderboard* TLeaderboards::mutable_leaderboards(int index) {
  // @@protoc_insertion_point(field_mutable:server.TLeaderboards.leaderboards)
  return leaderboards_.Mutable(index);
}
inline ::server::Leaderboard* TLeaderboards::add_leaderboards() {
  // @@protoc_insertion_point(field_add:server.TLeaderboards.leaderboards)
  return leaderboards_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::Leaderboard >*
TLeaderboards::mutable_leaderboards() {
  // @@protoc_insertion_point(field_mutable_list:server.TLeaderboards.leaderboards)
  return &leaderboards_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::Leaderboard >&
TLeaderboards::leaderboards() const {
  // @@protoc_insertion_point(field_list:server.TLeaderboards.leaderboards)
  return leaderboards_;
}

// optional bytes cursor = 2;
inline void TLeaderboards::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboards::cursor() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboards.cursor)
  return cursor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboards::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboards.cursor)
}
inline void TLeaderboards::set_cursor(const char* value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboards.cursor)
}
inline void TLeaderboards::set_cursor(const void* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboards.cursor)
}
inline ::std::string* TLeaderboards::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboards.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboards::release_cursor() {
  // @@protoc_insertion_point(field_release:server.TLeaderboards.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboards::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboards.cursor)
}

inline const TLeaderboards* TLeaderboards::internal_default_instance() {
  return &TLeaderboards_default_instance_.get();
}
// -------------------------------------------------------------------

// TLeaderboardRecordWrite

// optional bytes leaderboard_id = 1;
inline void TLeaderboardRecordWrite::clear_leaderboard_id() {
  leaderboard_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboardRecordWrite::leaderboard_id() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordWrite.leaderboard_id)
  return leaderboard_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordWrite::set_leaderboard_id(const ::std::string& value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordWrite.leaderboard_id)
}
inline void TLeaderboardRecordWrite::set_leaderboard_id(const char* value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordWrite.leaderboard_id)
}
inline void TLeaderboardRecordWrite::set_leaderboard_id(const void* value, size_t size) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordWrite.leaderboard_id)
}
inline ::std::string* TLeaderboardRecordWrite::mutable_leaderboard_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordWrite.leaderboard_id)
  return leaderboard_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordWrite::release_leaderboard_id() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordWrite.leaderboard_id)
  
  return leaderboard_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordWrite::set_allocated_leaderboard_id(::std::string* leaderboard_id) {
  if (leaderboard_id != NULL) {
    
  } else {
    
  }
  leaderboard_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leaderboard_id);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordWrite.leaderboard_id)
}

// optional int64 incr = 2;
inline bool TLeaderboardRecordWrite::has_incr() const {
  return op_case() == kIncr;
}
inline void TLeaderboardRecordWrite::set_has_incr() {
  _oneof_case_[0] = kIncr;
}
inline void TLeaderboardRecordWrite::clear_incr() {
  if (has_incr()) {
    op_.incr_ = GOOGLE_LONGLONG(0);
    clear_has_op();
  }
}
inline ::google::protobuf::int64 TLeaderboardRecordWrite::incr() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordWrite.incr)
  if (has_incr()) {
    return op_.incr_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void TLeaderboardRecordWrite::set_incr(::google::protobuf::int64 value) {
  if (!has_incr()) {
    clear_op();
    set_has_incr();
  }
  op_.incr_ = value;
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordWrite.incr)
}

// optional int64 decr = 3;
inline bool TLeaderboardRecordWrite::has_decr() const {
  return op_case() == kDecr;
}
inline void TLeaderboardRecordWrite::set_has_decr() {
  _oneof_case_[0] = kDecr;
}
inline void TLeaderboardRecordWrite::clear_decr() {
  if (has_decr()) {
    op_.decr_ = GOOGLE_LONGLONG(0);
    clear_has_op();
  }
}
inline ::google::protobuf::int64 TLeaderboardRecordWrite::decr() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordWrite.decr)
  if (has_decr()) {
    return op_.decr_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void TLeaderboardRecordWrite::set_decr(::google::protobuf::int64 value) {
  if (!has_decr()) {
    clear_op();
    set_has_decr();
  }
  op_.decr_ = value;
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordWrite.decr)
}

// optional int64 set = 4;
inline bool TLeaderboardRecordWrite::has_set() const {
  return op_case() == kSet;
}
inline void TLeaderboardRecordWrite::set_has_set() {
  _oneof_case_[0] = kSet;
}
inline void TLeaderboardRecordWrite::clear_set() {
  if (has_set()) {
    op_.set_ = GOOGLE_LONGLONG(0);
    clear_has_op();
  }
}
inline ::google::protobuf::int64 TLeaderboardRecordWrite::set() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordWrite.set)
  if (has_set()) {
    return op_.set_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void TLeaderboardRecordWrite::set_set(::google::protobuf::int64 value) {
  if (!has_set()) {
    clear_op();
    set_has_set();
  }
  op_.set_ = value;
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordWrite.set)
}

// optional int64 best = 5;
inline bool TLeaderboardRecordWrite::has_best() const {
  return op_case() == kBest;
}
inline void TLeaderboardRecordWrite::set_has_best() {
  _oneof_case_[0] = kBest;
}
inline void TLeaderboardRecordWrite::clear_best() {
  if (has_best()) {
    op_.best_ = GOOGLE_LONGLONG(0);
    clear_has_op();
  }
}
inline ::google::protobuf::int64 TLeaderboardRecordWrite::best() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordWrite.best)
  if (has_best()) {
    return op_.best_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void TLeaderboardRecordWrite::set_best(::google::protobuf::int64 value) {
  if (!has_best()) {
    clear_op();
    set_has_best();
  }
  op_.best_ = value;
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordWrite.best)
}

// optional string location = 6;
inline void TLeaderboardRecordWrite::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboardRecordWrite::location() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordWrite.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordWrite::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordWrite.location)
}
inline void TLeaderboardRecordWrite::set_location(const char* value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordWrite.location)
}
inline void TLeaderboardRecordWrite::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordWrite.location)
}
inline ::std::string* TLeaderboardRecordWrite::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordWrite.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordWrite::release_location() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordWrite.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordWrite::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordWrite.location)
}

// optional string timezone = 7;
inline void TLeaderboardRecordWrite::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboardRecordWrite::timezone() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordWrite.timezone)
  return timezone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordWrite::set_timezone(const ::std::string& value) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordWrite.timezone)
}
inline void TLeaderboardRecordWrite::set_timezone(const char* value) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordWrite.timezone)
}
inline void TLeaderboardRecordWrite::set_timezone(const char* value, size_t size) {
  
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordWrite.timezone)
}
inline ::std::string* TLeaderboardRecordWrite::mutable_timezone() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordWrite.timezone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordWrite::release_timezone() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordWrite.timezone)
  
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordWrite::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    
  } else {
    
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordWrite.timezone)
}

// optional bytes metadata = 8;
inline void TLeaderboardRecordWrite::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboardRecordWrite::metadata() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordWrite.metadata)
  return metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordWrite::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordWrite.metadata)
}
inline void TLeaderboardRecordWrite::set_metadata(const char* value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordWrite.metadata)
}
inline void TLeaderboardRecordWrite::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordWrite.metadata)
}
inline ::std::string* TLeaderboardRecordWrite::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordWrite.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordWrite::release_metadata() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordWrite.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordWrite::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordWrite.metadata)
}

inline bool TLeaderboardRecordWrite::has_op() const {
  return op_case() != OP_NOT_SET;
}
inline void TLeaderboardRecordWrite::clear_has_op() {
  _oneof_case_[0] = OP_NOT_SET;
}
inline TLeaderboardRecordWrite::OpCase TLeaderboardRecordWrite::op_case() const {
  return TLeaderboardRecordWrite::OpCase(_oneof_case_[0]);
}
inline const TLeaderboardRecordWrite* TLeaderboardRecordWrite::internal_default_instance() {
  return &TLeaderboardRecordWrite_default_instance_.get();
}
// -------------------------------------------------------------------

// TLeaderboardRecord

// optional .server.LeaderboardRecord record = 1;
inline bool TLeaderboardRecord::has_record() const {
  return this != internal_default_instance() && record_ != NULL;
}
inline void TLeaderboardRecord::clear_record() {
  if (GetArenaNoVirtual() == NULL && record_ != NULL) delete record_;
  record_ = NULL;
}
inline const ::server::LeaderboardRecord& TLeaderboardRecord::record() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecord.record)
  return record_ != NULL ? *record_
                         : *::server::LeaderboardRecord::internal_default_instance();
}
inline ::server::LeaderboardRecord* TLeaderboardRecord::mutable_record() {
  
  if (record_ == NULL) {
    record_ = new ::server::LeaderboardRecord;
  }
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecord.record)
  return record_;
}
inline ::server::LeaderboardRecord* TLeaderboardRecord::release_record() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecord.record)
  
  ::server::LeaderboardRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void TLeaderboardRecord::set_allocated_record(::server::LeaderboardRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecord.record)
}

inline const TLeaderboardRecord* TLeaderboardRecord::internal_default_instance() {
  return &TLeaderboardRecord_default_instance_.get();
}
// -------------------------------------------------------------------

// TLeaderboardRecordsFetch

// repeated bytes leaderboard_ids = 1;
inline int TLeaderboardRecordsFetch::leaderboard_ids_size() const {
  return leaderboard_ids_.size();
}
inline void TLeaderboardRecordsFetch::clear_leaderboard_ids() {
  leaderboard_ids_.Clear();
}
inline const ::std::string& TLeaderboardRecordsFetch::leaderboard_ids(int index) const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsFetch.leaderboard_ids)
  return leaderboard_ids_.Get(index);
}
inline ::std::string* TLeaderboardRecordsFetch::mutable_leaderboard_ids(int index) {
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsFetch.leaderboard_ids)
  return leaderboard_ids_.Mutable(index);
}
inline void TLeaderboardRecordsFetch::set_leaderboard_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsFetch.leaderboard_ids)
  leaderboard_ids_.Mutable(index)->assign(value);
}
inline void TLeaderboardRecordsFetch::set_leaderboard_ids(int index, const char* value) {
  leaderboard_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordsFetch.leaderboard_ids)
}
inline void TLeaderboardRecordsFetch::set_leaderboard_ids(int index, const void* value, size_t size) {
  leaderboard_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordsFetch.leaderboard_ids)
}
inline ::std::string* TLeaderboardRecordsFetch::add_leaderboard_ids() {
  // @@protoc_insertion_point(field_add_mutable:server.TLeaderboardRecordsFetch.leaderboard_ids)
  return leaderboard_ids_.Add();
}
inline void TLeaderboardRecordsFetch::add_leaderboard_ids(const ::std::string& value) {
  leaderboard_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:server.TLeaderboardRecordsFetch.leaderboard_ids)
}
inline void TLeaderboardRecordsFetch::add_leaderboard_ids(const char* value) {
  leaderboard_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:server.TLeaderboardRecordsFetch.leaderboard_ids)
}
inline void TLeaderboardRecordsFetch::add_leaderboard_ids(const void* value, size_t size) {
  leaderboard_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:server.TLeaderboardRecordsFetch.leaderboard_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TLeaderboardRecordsFetch::leaderboard_ids() const {
  // @@protoc_insertion_point(field_list:server.TLeaderboardRecordsFetch.leaderboard_ids)
  return leaderboard_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TLeaderboardRecordsFetch::mutable_leaderboard_ids() {
  // @@protoc_insertion_point(field_mutable_list:server.TLeaderboardRecordsFetch.leaderboard_ids)
  return &leaderboard_ids_;
}

// optional int64 limit = 2;
inline void TLeaderboardRecordsFetch::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TLeaderboardRecordsFetch::limit() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsFetch.limit)
  return limit_;
}
inline void TLeaderboardRecordsFetch::set_limit(::google::protobuf::int64 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsFetch.limit)
}

// optional bytes cursor = 3;
inline void TLeaderboardRecordsFetch::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboardRecordsFetch::cursor() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsFetch.cursor)
  return cursor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordsFetch::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsFetch.cursor)
}
inline void TLeaderboardRecordsFetch::set_cursor(const char* value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordsFetch.cursor)
}
inline void TLeaderboardRecordsFetch::set_cursor(const void* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordsFetch.cursor)
}
inline ::std::string* TLeaderboardRecordsFetch::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsFetch.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordsFetch::release_cursor() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordsFetch.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordsFetch::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordsFetch.cursor)
}

inline const TLeaderboardRecordsFetch* TLeaderboardRecordsFetch::internal_default_instance() {
  return &TLeaderboardRecordsFetch_default_instance_.get();
}
// -------------------------------------------------------------------

// TLeaderboardRecordsList_Owners

// repeated bytes owner_ids = 1;
inline int TLeaderboardRecordsList_Owners::owner_ids_size() const {
  return owner_ids_.size();
}
inline void TLeaderboardRecordsList_Owners::clear_owner_ids() {
  owner_ids_.Clear();
}
inline const ::std::string& TLeaderboardRecordsList_Owners::owner_ids(int index) const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsList.Owners.owner_ids)
  return owner_ids_.Get(index);
}
inline ::std::string* TLeaderboardRecordsList_Owners::mutable_owner_ids(int index) {
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsList.Owners.owner_ids)
  return owner_ids_.Mutable(index);
}
inline void TLeaderboardRecordsList_Owners::set_owner_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.Owners.owner_ids)
  owner_ids_.Mutable(index)->assign(value);
}
inline void TLeaderboardRecordsList_Owners::set_owner_ids(int index, const char* value) {
  owner_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordsList.Owners.owner_ids)
}
inline void TLeaderboardRecordsList_Owners::set_owner_ids(int index, const void* value, size_t size) {
  owner_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordsList.Owners.owner_ids)
}
inline ::std::string* TLeaderboardRecordsList_Owners::add_owner_ids() {
  // @@protoc_insertion_point(field_add_mutable:server.TLeaderboardRecordsList.Owners.owner_ids)
  return owner_ids_.Add();
}
inline void TLeaderboardRecordsList_Owners::add_owner_ids(const ::std::string& value) {
  owner_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:server.TLeaderboardRecordsList.Owners.owner_ids)
}
inline void TLeaderboardRecordsList_Owners::add_owner_ids(const char* value) {
  owner_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:server.TLeaderboardRecordsList.Owners.owner_ids)
}
inline void TLeaderboardRecordsList_Owners::add_owner_ids(const void* value, size_t size) {
  owner_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:server.TLeaderboardRecordsList.Owners.owner_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TLeaderboardRecordsList_Owners::owner_ids() const {
  // @@protoc_insertion_point(field_list:server.TLeaderboardRecordsList.Owners.owner_ids)
  return owner_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TLeaderboardRecordsList_Owners::mutable_owner_ids() {
  // @@protoc_insertion_point(field_mutable_list:server.TLeaderboardRecordsList.Owners.owner_ids)
  return &owner_ids_;
}

inline const TLeaderboardRecordsList_Owners* TLeaderboardRecordsList_Owners::internal_default_instance() {
  return &TLeaderboardRecordsList_Owners_default_instance_.get();
}
// -------------------------------------------------------------------

// TLeaderboardRecordsList

// optional bytes leaderboard_id = 1;
inline void TLeaderboardRecordsList::clear_leaderboard_id() {
  leaderboard_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboardRecordsList::leaderboard_id() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsList.leaderboard_id)
  return leaderboard_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordsList::set_leaderboard_id(const ::std::string& value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.leaderboard_id)
}
inline void TLeaderboardRecordsList::set_leaderboard_id(const char* value) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordsList.leaderboard_id)
}
inline void TLeaderboardRecordsList::set_leaderboard_id(const void* value, size_t size) {
  
  leaderboard_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordsList.leaderboard_id)
}
inline ::std::string* TLeaderboardRecordsList::mutable_leaderboard_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsList.leaderboard_id)
  return leaderboard_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordsList::release_leaderboard_id() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordsList.leaderboard_id)
  
  return leaderboard_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordsList::set_allocated_leaderboard_id(::std::string* leaderboard_id) {
  if (leaderboard_id != NULL) {
    
  } else {
    
  }
  leaderboard_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leaderboard_id);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordsList.leaderboard_id)
}

// optional bytes owner_id = 2;
inline bool TLeaderboardRecordsList::has_owner_id() const {
  return filter_case() == kOwnerId;
}
inline void TLeaderboardRecordsList::set_has_owner_id() {
  _oneof_case_[0] = kOwnerId;
}
inline void TLeaderboardRecordsList::clear_owner_id() {
  if (has_owner_id()) {
    filter_.owner_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_filter();
  }
}
inline const ::std::string& TLeaderboardRecordsList::owner_id() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsList.owner_id)
  if (has_owner_id()) {
    return filter_.owner_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TLeaderboardRecordsList::set_owner_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.owner_id)
  if (!has_owner_id()) {
    clear_filter();
    set_has_owner_id();
    filter_.owner_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.owner_id)
}
inline void TLeaderboardRecordsList::set_owner_id(const char* value) {
  if (!has_owner_id()) {
    clear_filter();
    set_has_owner_id();
    filter_.owner_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordsList.owner_id)
}
inline void TLeaderboardRecordsList::set_owner_id(const void* value, size_t size) {
  if (!has_owner_id()) {
    clear_filter();
    set_has_owner_id();
    filter_.owner_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.owner_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordsList.owner_id)
}
inline ::std::string* TLeaderboardRecordsList::mutable_owner_id() {
  if (!has_owner_id()) {
    clear_filter();
    set_has_owner_id();
    filter_.owner_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsList.owner_id)
  return filter_.owner_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordsList::release_owner_id() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordsList.owner_id)
  if (has_owner_id()) {
    clear_has_filter();
    return filter_.owner_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TLeaderboardRecordsList::set_allocated_owner_id(::std::string* owner_id) {
  if (!has_owner_id()) {
    filter_.owner_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_filter();
  if (owner_id != NULL) {
    set_has_owner_id();
    filter_.owner_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        owner_id);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordsList.owner_id)
}

// optional .server.TLeaderboardRecordsList.Owners owner_ids = 3;
inline bool TLeaderboardRecordsList::has_owner_ids() const {
  return filter_case() == kOwnerIds;
}
inline void TLeaderboardRecordsList::set_has_owner_ids() {
  _oneof_case_[0] = kOwnerIds;
}
inline void TLeaderboardRecordsList::clear_owner_ids() {
  if (has_owner_ids()) {
    delete filter_.owner_ids_;
    clear_has_filter();
  }
}
inline  const ::server::TLeaderboardRecordsList_Owners& TLeaderboardRecordsList::owner_ids() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsList.owner_ids)
  return has_owner_ids()
      ? *filter_.owner_ids_
      : ::server::TLeaderboardRecordsList_Owners::default_instance();
}
inline ::server::TLeaderboardRecordsList_Owners* TLeaderboardRecordsList::mutable_owner_ids() {
  if (!has_owner_ids()) {
    clear_filter();
    set_has_owner_ids();
    filter_.owner_ids_ = new ::server::TLeaderboardRecordsList_Owners;
  }
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsList.owner_ids)
  return filter_.owner_ids_;
}
inline ::server::TLeaderboardRecordsList_Owners* TLeaderboardRecordsList::release_owner_ids() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordsList.owner_ids)
  if (has_owner_ids()) {
    clear_has_filter();
    ::server::TLeaderboardRecordsList_Owners* temp = filter_.owner_ids_;
    filter_.owner_ids_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TLeaderboardRecordsList::set_allocated_owner_ids(::server::TLeaderboardRecordsList_Owners* owner_ids) {
  clear_filter();
  if (owner_ids) {
    set_has_owner_ids();
    filter_.owner_ids_ = owner_ids;
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordsList.owner_ids)
}

// optional string lang = 4;
inline bool TLeaderboardRecordsList::has_lang() const {
  return filter_case() == kLang;
}
inline void TLeaderboardRecordsList::set_has_lang() {
  _oneof_case_[0] = kLang;
}
inline void TLeaderboardRecordsList::clear_lang() {
  if (has_lang()) {
    filter_.lang_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_filter();
  }
}
inline const ::std::string& TLeaderboardRecordsList::lang() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsList.lang)
  if (has_lang()) {
    return filter_.lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TLeaderboardRecordsList::set_lang(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.lang)
  if (!has_lang()) {
    clear_filter();
    set_has_lang();
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.lang)
}
inline void TLeaderboardRecordsList::set_lang(const char* value) {
  if (!has_lang()) {
    clear_filter();
    set_has_lang();
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordsList.lang)
}
inline void TLeaderboardRecordsList::set_lang(const char* value, size_t size) {
  if (!has_lang()) {
    clear_filter();
    set_has_lang();
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordsList.lang)
}
inline ::std::string* TLeaderboardRecordsList::mutable_lang() {
  if (!has_lang()) {
    clear_filter();
    set_has_lang();
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsList.lang)
  return filter_.lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordsList::release_lang() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordsList.lang)
  if (has_lang()) {
    clear_has_filter();
    return filter_.lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TLeaderboardRecordsList::set_allocated_lang(::std::string* lang) {
  if (!has_lang()) {
    filter_.lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_filter();
  if (lang != NULL) {
    set_has_lang();
    filter_.lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        lang);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordsList.lang)
}

// optional string location = 5;
inline bool TLeaderboardRecordsList::has_location() const {
  return filter_case() == kLocation;
}
inline void TLeaderboardRecordsList::set_has_location() {
  _oneof_case_[0] = kLocation;
}
inline void TLeaderboardRecordsList::clear_location() {
  if (has_location()) {
    filter_.location_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_filter();
  }
}
inline const ::std::string& TLeaderboardRecordsList::location() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsList.location)
  if (has_location()) {
    return filter_.location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TLeaderboardRecordsList::set_location(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.location)
  if (!has_location()) {
    clear_filter();
    set_has_location();
    filter_.location_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.location)
}
inline void TLeaderboardRecordsList::set_location(const char* value) {
  if (!has_location()) {
    clear_filter();
    set_has_location();
    filter_.location_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordsList.location)
}
inline void TLeaderboardRecordsList::set_location(const char* value, size_t size) {
  if (!has_location()) {
    clear_filter();
    set_has_location();
    filter_.location_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordsList.location)
}
inline ::std::string* TLeaderboardRecordsList::mutable_location() {
  if (!has_location()) {
    clear_filter();
    set_has_location();
    filter_.location_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsList.location)
  return filter_.location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordsList::release_location() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordsList.location)
  if (has_location()) {
    clear_has_filter();
    return filter_.location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TLeaderboardRecordsList::set_allocated_location(::std::string* location) {
  if (!has_location()) {
    filter_.location_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_filter();
  if (location != NULL) {
    set_has_location();
    filter_.location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        location);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordsList.location)
}

// optional string timezone = 6;
inline bool TLeaderboardRecordsList::has_timezone() const {
  return filter_case() == kTimezone;
}
inline void TLeaderboardRecordsList::set_has_timezone() {
  _oneof_case_[0] = kTimezone;
}
inline void TLeaderboardRecordsList::clear_timezone() {
  if (has_timezone()) {
    filter_.timezone_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_filter();
  }
}
inline const ::std::string& TLeaderboardRecordsList::timezone() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsList.timezone)
  if (has_timezone()) {
    return filter_.timezone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TLeaderboardRecordsList::set_timezone(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.timezone)
  if (!has_timezone()) {
    clear_filter();
    set_has_timezone();
    filter_.timezone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.timezone)
}
inline void TLeaderboardRecordsList::set_timezone(const char* value) {
  if (!has_timezone()) {
    clear_filter();
    set_has_timezone();
    filter_.timezone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordsList.timezone)
}
inline void TLeaderboardRecordsList::set_timezone(const char* value, size_t size) {
  if (!has_timezone()) {
    clear_filter();
    set_has_timezone();
    filter_.timezone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  filter_.timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordsList.timezone)
}
inline ::std::string* TLeaderboardRecordsList::mutable_timezone() {
  if (!has_timezone()) {
    clear_filter();
    set_has_timezone();
    filter_.timezone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsList.timezone)
  return filter_.timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordsList::release_timezone() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordsList.timezone)
  if (has_timezone()) {
    clear_has_filter();
    return filter_.timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TLeaderboardRecordsList::set_allocated_timezone(::std::string* timezone) {
  if (!has_timezone()) {
    filter_.timezone_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_filter();
  if (timezone != NULL) {
    set_has_timezone();
    filter_.timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        timezone);
  }
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordsList.timezone)
}

// optional int64 limit = 7;
inline void TLeaderboardRecordsList::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TLeaderboardRecordsList::limit() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsList.limit)
  return limit_;
}
inline void TLeaderboardRecordsList::set_limit(::google::protobuf::int64 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.limit)
}

// optional bytes cursor = 8;
inline void TLeaderboardRecordsList::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboardRecordsList::cursor() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecordsList.cursor)
  return cursor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordsList::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecordsList.cursor)
}
inline void TLeaderboardRecordsList::set_cursor(const char* value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecordsList.cursor)
}
inline void TLeaderboardRecordsList::set_cursor(const void* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecordsList.cursor)
}
inline ::std::string* TLeaderboardRecordsList::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecordsList.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecordsList::release_cursor() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecordsList.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecordsList::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecordsList.cursor)
}

inline bool TLeaderboardRecordsList::has_filter() const {
  return filter_case() != FILTER_NOT_SET;
}
inline void TLeaderboardRecordsList::clear_has_filter() {
  _oneof_case_[0] = FILTER_NOT_SET;
}
inline TLeaderboardRecordsList::FilterCase TLeaderboardRecordsList::filter_case() const {
  return TLeaderboardRecordsList::FilterCase(_oneof_case_[0]);
}
inline const TLeaderboardRecordsList* TLeaderboardRecordsList::internal_default_instance() {
  return &TLeaderboardRecordsList_default_instance_.get();
}
// -------------------------------------------------------------------

// TLeaderboardRecords

// repeated .server.LeaderboardRecord records = 1;
inline int TLeaderboardRecords::records_size() const {
  return records_.size();
}
inline void TLeaderboardRecords::clear_records() {
  records_.Clear();
}
inline const ::server::LeaderboardRecord& TLeaderboardRecords::records(int index) const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecords.records)
  return records_.Get(index);
}
inline ::server::LeaderboardRecord* TLeaderboardRecords::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecords.records)
  return records_.Mutable(index);
}
inline ::server::LeaderboardRecord* TLeaderboardRecords::add_records() {
  // @@protoc_insertion_point(field_add:server.TLeaderboardRecords.records)
  return records_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::server::LeaderboardRecord >*
TLeaderboardRecords::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:server.TLeaderboardRecords.records)
  return &records_;
}
inline const ::google::protobuf::RepeatedPtrField< ::server::LeaderboardRecord >&
TLeaderboardRecords::records() const {
  // @@protoc_insertion_point(field_list:server.TLeaderboardRecords.records)
  return records_;
}

// optional bytes cursor = 2;
inline void TLeaderboardRecords::clear_cursor() {
  cursor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TLeaderboardRecords::cursor() const {
  // @@protoc_insertion_point(field_get:server.TLeaderboardRecords.cursor)
  return cursor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecords::set_cursor(const ::std::string& value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TLeaderboardRecords.cursor)
}
inline void TLeaderboardRecords::set_cursor(const char* value) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TLeaderboardRecords.cursor)
}
inline void TLeaderboardRecords::set_cursor(const void* value, size_t size) {
  
  cursor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TLeaderboardRecords.cursor)
}
inline ::std::string* TLeaderboardRecords::mutable_cursor() {
  
  // @@protoc_insertion_point(field_mutable:server.TLeaderboardRecords.cursor)
  return cursor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TLeaderboardRecords::release_cursor() {
  // @@protoc_insertion_point(field_release:server.TLeaderboardRecords.cursor)
  
  return cursor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TLeaderboardRecords::set_allocated_cursor(::std::string* cursor) {
  if (cursor != NULL) {
    
  } else {
    
  }
  cursor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cursor);
  // @@protoc_insertion_point(field_set_allocated:server.TLeaderboardRecords.cursor)
}

inline const TLeaderboardRecords* TLeaderboardRecords::internal_default_instance() {
  return &TLeaderboardRecords_default_instance_.get();
}
// -------------------------------------------------------------------

// TRpc

// optional string id = 1;
inline void TRpc::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TRpc::id() const {
  // @@protoc_insertion_point(field_get:server.TRpc.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TRpc::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TRpc.id)
}
inline void TRpc::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TRpc.id)
}
inline void TRpc::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TRpc.id)
}
inline ::std::string* TRpc::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:server.TRpc.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TRpc::release_id() {
  // @@protoc_insertion_point(field_release:server.TRpc.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TRpc::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:server.TRpc.id)
}

// optional bytes payload = 2;
inline void TRpc::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TRpc::payload() const {
  // @@protoc_insertion_point(field_get:server.TRpc.payload)
  return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TRpc::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:server.TRpc.payload)
}
inline void TRpc::set_payload(const char* value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:server.TRpc.payload)
}
inline void TRpc::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:server.TRpc.payload)
}
inline ::std::string* TRpc::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:server.TRpc.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TRpc::release_payload() {
  // @@protoc_insertion_point(field_release:server.TRpc.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TRpc::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:server.TRpc.payload)
}

inline const TRpc* TRpc::internal_default_instance() {
  return &TRpc_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace server

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::server::Error_Code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::Error_Code>() {
  return ::server::Error_Code_descriptor();
}
template <> struct is_proto_enum< ::server::StoragePermissionRead> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::StoragePermissionRead>() {
  return ::server::StoragePermissionRead_descriptor();
}
template <> struct is_proto_enum< ::server::StoragePermissionWrite> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::StoragePermissionWrite>() {
  return ::server::StoragePermissionWrite_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2eproto__INCLUDED
